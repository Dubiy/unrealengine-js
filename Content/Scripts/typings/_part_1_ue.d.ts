declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	Tooltip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static GetDefaultObject(): BrushBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject | any): BrushBuilder;
	Build(InWorld: World,InBrush: Brush): boolean;
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	Type: number;
	index: number;
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject | any): GeomSelection;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bDisplayShadedVolume: boolean;
	ShadedVolumeOpacityValue: number;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	static GetDefaultObject(): Brush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject | any): Brush;
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
}

declare class Volume extends Brush { 
	static GetDefaultObject(): Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject | any): Volume;
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	static GetDefaultObject(): PhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject | any): PhysicsVolume;
}

declare type EDetachmentRule = 'KeepRelative' | 'KeepWorld' | 'EDetachmentRule_MAX';
declare var EDetachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',EDetachmentRule_MAX:'EDetachmentRule_MAX', };
declare type EMoveComponentAction = 'Move' | 'Stop' | 'Return' | 'EMoveComponentAction_MAX';
declare var EMoveComponentAction : { Move:'Move',Stop:'Stop',Return:'Return',EMoveComponentAction_MAX:'EMoveComponentAction_MAX', };
declare class ARPin extends UObject { 
	TrackedGeometry: ARTrackedGeometry;
	PinnedComponent: SceneComponent;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	OnARTrackingStateChanged: UnrealEngineMulticastDelegate<(NewTrackingState: EARTrackingState) => void>;
	OnARTransformUpdated: UnrealEngineMulticastDelegate<(OldToNewTransform: Transform) => void>;
	static Load(ResourceName: string): ARPin;
	static Find(Outer: UObject, ResourceName: string): ARPin;
	static GetDefaultObject(): ARPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPin;
	GetTrackingState(): EARTrackingState;
	GetTrackedGeometry(): ARTrackedGeometry;
	GetPinnedComponent(): SceneComponent;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetDebugName(): string;
	DebugDraw(World: World,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static C(Other: UObject | any): ARPin;
	DebugDrawPin(WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	RemovePin(): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static RemovePin(PinToRemove: ARPin): void;
}

declare class SceneComponent extends ActorComponent { 
	PhysicsVolume: any;
	AttachParent: SceneComponent;
	AttachSocketName: string;
	AttachChildren: SceneComponent[];
	ClientAttachedChildren: SceneComponent[];
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	ComponentVelocity: Vector;
	bComponentToWorldUpdated: boolean;
	bAbsoluteLocation: boolean;
	bAbsoluteRotation: boolean;
	bAbsoluteScale: boolean;
	bVisible: boolean;
	bShouldBeAttached: boolean;
	bShouldSnapLocationWhenAttached: boolean;
	bShouldSnapRotationWhenAttached: boolean;
	bShouldUpdatePhysicsVolume: boolean;
	bHiddenInGame: boolean;
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	bUseAttachParentBound: boolean;
	bComputeFastLocalBounds: boolean;
	bComputeBoundsOnceForGame: boolean;
	bComputedBoundsOnceForGame: boolean;
	bVisualizeComponent: boolean;
	Mobility: EComponentMobility;
	DetailMode: EDetailMode;
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	ReplacementSceneComponent: SceneComponent;
	static Load(ResourceName: string): SceneComponent;
	static Find(Outer: UObject, ResourceName: string): SceneComponent;
	static GetDefaultObject(): SceneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	ToggleVisibility(bPropagateToChildren: boolean): void;
	SetWorldScale3D(NewScale: Vector): void;
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean): void;
	SetRelativeScale3D(NewScale3D: Vector): void;
	SetMobility(NewMobility: EComponentMobility): void;
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	ResetRelativeTransform(): void;
	OnRep_Visibility(OldValue: boolean): void;
	OnRep_Transform(): void;
	OnRep_AttachSocketName(): void;
	OnRep_AttachParent(): void;
	OnRep_AttachChildren(): void;
	K2_SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_GetComponentToWorld(): Transform;
	K2_GetComponentScale(): Vector;
	K2_GetComponentRotation(): Rotator;
	K2_GetComponentLocation(): Vector;
	K2_DetachFromComponent(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule,bCallModify: boolean): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): boolean;
	K2_AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): boolean;
	K2_AddWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsVisible(): boolean;
	IsSimulatingPhysics(BoneName: string): boolean;
	IsAnySimulatingPhysics(): boolean;
	GetUpVector(): Vector;
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	GetSocketRotation(InSocketName: string): Rotator;
	GetSocketQuaternion(InSocketName: string): Quat;
	GetSocketLocation(InSocketName: string): Vector;
	GetShouldUpdatePhysicsVolume(): boolean;
	GetRightVector(): Vector;
	GetRelativeTransform(): Transform;
	GetPhysicsVolume(): PhysicsVolume;
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	GetNumChildrenComponents(): number;
	GetForwardVector(): Vector;
	GetComponentVelocity(): Vector;
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	GetChildComponent(ChildIndex: number): SceneComponent;
	GetAttachSocketName(): string;
	GetAttachParent(): SceneComponent;
	GetAllSocketNames(): string[];
	DoesSocketExist(InSocketName: string): boolean;
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
	static C(Other: UObject | any): SceneComponent;
	SetMobile(): void;
	SetMobility(Type: EComponentMobility): void;
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	PinComponent(PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	PinComponentToARPin(Pin: ARPin): boolean;
	PinComponentToTraceResult(TraceResult: ARTraceResult,DebugName: string): ARPin;
	UnpinComponent(): void;
	static SetMobile(SceneComponent: SceneComponent): void;
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
}

declare type ESceneDepthPriorityGroup = 'SDPG_World' | 'SDPG_Foreground' | 'SDPG_MAX';
declare var ESceneDepthPriorityGroup : { SDPG_World:'SDPG_World',SDPG_Foreground:'SDPG_Foreground',SDPG_MAX:'SDPG_MAX', };
declare type EIndirectLightingCacheQuality = 'ILCQ_Off' | 'ILCQ_Point' | 'ILCQ_Volume' | 'ILCQ_MAX';
declare var EIndirectLightingCacheQuality : { ILCQ_Off:'ILCQ_Off',ILCQ_Point:'ILCQ_Point',ILCQ_Volume:'ILCQ_Volume',ILCQ_MAX:'ILCQ_MAX', };
declare type ELightmapType = 'Default' | 'ForceSurface' | 'ForceVolumetric' | 'ELightmapType_MAX';
declare var ELightmapType : { Default:'Default',ForceSurface:'ForceSurface',ForceVolumetric:'ForceVolumetric',ELightmapType_MAX:'ELightmapType_MAX', };
declare type EHLODBatchingPolicy = 'None' | 'MeshSection' | 'Instancing' | 'EHLODBatchingPolicy_MAX';
declare var EHLODBatchingPolicy : { None:'None',MeshSection:'MeshSection',Instancing:'Instancing',EHLODBatchingPolicy_MAX:'EHLODBatchingPolicy_MAX', };
declare type EHasCustomNavigableGeometry = 'No' | 'Yes' | 'EvenIfNotCollidable' | 'DontExport' | 'EHasCustomNavigableGeometry_MAX';
declare var EHasCustomNavigableGeometry : { No:'No',Yes:'Yes',EvenIfNotCollidable:'EvenIfNotCollidable',DontExport:'DontExport',EHasCustomNavigableGeometry_MAX:'EHasCustomNavigableGeometry_MAX', };
declare type EHitProxyPriority = 'HPP_World' | 'HPP_Wireframe' | 'HPP_Foreground' | 'HPP_UI' | 'HPP_MAX';
declare var EHitProxyPriority : { HPP_World:'HPP_World',HPP_Wireframe:'HPP_Wireframe',HPP_Foreground:'HPP_Foreground',HPP_UI:'HPP_UI',HPP_MAX:'HPP_MAX', };
declare type ECanBeCharacterBase = 'ECB_No' | 'ECB_Yes' | 'ECB_Owner' | 'ECB_MAX';
declare var ECanBeCharacterBase : { ECB_No:'ECB_No',ECB_Yes:'ECB_Yes',ECB_Owner:'ECB_Owner',ECB_MAX:'ECB_MAX', };
declare class LightingChannels { 
	bChannel0: boolean;
	bChannel1: boolean;
	bChannel2: boolean;
	clone() : LightingChannels;
	static C(Other: UObject | any): LightingChannels;
}

declare class CustomPrimitiveData { 
	Data: number[];
	clone() : CustomPrimitiveData;
	static C(Other: UObject | any): CustomPrimitiveData;
}

declare type ERuntimeVirtualTextureMainPassType = 'Never' | 'Exclusive' | 'Always' | 'ERuntimeVirtualTextureMainPassType_MAX';
declare var ERuntimeVirtualTextureMainPassType : { Never:'Never',Exclusive:'Exclusive',Always:'Always',ERuntimeVirtualTextureMainPassType_MAX:'ERuntimeVirtualTextureMainPassType_MAX', };
declare type ERayTracingGroupCullingPriority = 'CP_0_NEVER_CULL' | 'CP_1' | 'CP_2' | 'CP_3' | 'CP_4_DEFAULT' | 'CP_5' | 'CP_6' | 'CP_7' | 'CP_8_QUICKLY_CULL' | 'CP_MAX';
declare var ERayTracingGroupCullingPriority : { CP_0_NEVER_CULL:'CP_0_NEVER_CULL',CP_1:'CP_1',CP_2:'CP_2',CP_3:'CP_3',CP_4_DEFAULT:'CP_4_DEFAULT',CP_5:'CP_5',CP_6:'CP_6',CP_7:'CP_7',CP_8_QUICKLY_CULL:'CP_8_QUICKLY_CULL',CP_MAX:'CP_MAX', };
declare type ERadialImpulseFalloff = 'RIF_Constant' | 'RIF_Linear' | 'RIF_MAX';
declare var ERadialImpulseFalloff : { RIF_Constant:'RIF_Constant',RIF_Linear:'RIF_Linear',RIF_MAX:'RIF_MAX', };
declare class PrimitiveComponent extends SceneComponent { 
	MinDrawDistance: number;
	LDMaxDrawDistance: number;
	CachedMaxDrawDistance: number;
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	LightmapType: ELightmapType;
	bEnableAutoLODGeneration: boolean;
	ExcludeForSpecificHLODLevels: number[];
	HLODBatchingPolicy: EHLODBatchingPolicy;
	bIsActorTextureStreamingBuiltData: boolean;
	bIsValidTextureStreamingBuiltData: boolean;
	bNeverDistanceCull: boolean;
	bAlwaysCreatePhysicsState: boolean;
	bGenerateOverlapEvents: boolean;
	bMultiBodyOverlap: boolean;
	bTraceComplexOnMove: boolean;
	bReturnMaterialOnMove: boolean;
	bUseViewOwnerDepthPriorityGroup: boolean;
	bAllowCullDistanceVolume: boolean;
	bHasMotionBlurVelocityMeshes: boolean;
	bVisibleInReflectionCaptures: boolean;
	bVisibleInRealTimeSkyCaptures: boolean;
	bVisibleInRayTracing: boolean;
	bRenderInMainPass: boolean;
	bRenderInDepthPass: boolean;
	bReceivesDecals: boolean;
	bOwnerNoSee: boolean;
	bOnlyOwnerSee: boolean;
	bTreatAsBackgroundForOcclusion: boolean;
	bUseAsOccluder: boolean;
	bSelectable: boolean;
	bConsiderForActorPlacementWhenHidden: boolean;
	bForceMipStreaming: boolean;
	bHasPerInstanceHitProxies: boolean;
	CastShadow: boolean;
	bEmissiveLightSource: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastVolumetricTranslucentShadow: boolean;
	bCastContactShadow: boolean;
	bSelfShadowOnly: boolean;
	bCastFarShadow: boolean;
	bCastInsetShadow: boolean;
	bCastCinematicShadow: boolean;
	bCastHiddenShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bLightAsIfStatic: boolean;
	bLightAttachmentsAsGroup: boolean;
	bExcludeFromLightAttachmentGroup: boolean;
	bReceiveMobileCSMShadows: boolean;
	bSingleSampleShadowFromStationaryLights: boolean;
	bIgnoreRadialImpulse: boolean;
	bIgnoreRadialForce: boolean;
	bApplyImpulseOnDamage: boolean;
	bReplicatePhysicsToAutonomousProxy: boolean;
	bFillCollisionUnderneathForNavmesh: boolean;
	AlwaysLoadOnClient: boolean;
	AlwaysLoadOnServer: boolean;
	bUseEditorCompositing: boolean;
	bIsBeingMovedByEditor: boolean;
	bRenderCustomDepth: boolean;
	bVisibleInSceneCaptureOnly: boolean;
	bHiddenInSceneCapture: boolean;
	bRayTracingFarField: boolean;
	bHasNoStreamableTextures: boolean;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	HitProxyPriority: EHitProxyPriority;
	CanBeCharacterBase: ECanBeCharacterBase;
	bUseMaxLODAsImposter: boolean;
	bBatchImpostersAsInstances: boolean;
	CanCharacterStepUpOn: ECanBeCharacterBase;
	LightingChannels: LightingChannels;
	RayTracingGroupId: number;
	VisibilityId: number;
	CustomDepthStencilValue: number;
	CustomPrimitiveData: CustomPrimitiveData;
	CustomPrimitiveDataInternal: CustomPrimitiveData;
	TranslucencySortPriority: number;
	TranslucencySortDistanceOffset: number;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureLodBias: any;
	VirtualTextureCullMips: any;
	VirtualTextureMinCoverage: any;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	BoundsScale: number;
	MoveIgnoreActors: Actor[];
	MoveIgnoreComponents: PrimitiveComponent[];
	BodyInstance: BodyInstance;
	OnComponentHit: UnrealEngineMulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	OnComponentWake: UnrealEngineMulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentSleep: UnrealEngineMulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	RayTracingGroupCullingPriority: ERayTracingGroupCullingPriority;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	LODParentPrimitive: PrimitiveComponent;
	static Load(ResourceName: string): PrimitiveComponent;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponent;
	static GetDefaultObject(): PrimitiveComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	WasRecentlyRendered(Tolerance: number): boolean;
	WakeRigidBody(BoneName: string): void;
	WakeAllRigidBodies(): void;
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	SetVisibleInSceneCaptureOnly(bValue: boolean): void;
	SetVisibleInRayTracing(bNewVisibleInRayTracing: boolean): void;
	SetVectorParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetVectorParameterForCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetUseCCD(InUseCCD: boolean,BoneName: string): void;
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	SetTranslucencySortDistanceOffset(NewTranslucencySortDistanceOffset: number): void;
	SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;
	SetSimulatePhysics(bSimulate: boolean): void;
	SetScalarParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetScalarParameterForCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetRenderInMainPass(bValue: boolean): void;
	SetRenderInDepthPass(bValue: boolean): void;
	SetRenderCustomDepth(bValue: boolean): void;
	SetReceivesDecals(bNewReceivesDecals: boolean): void;
	SetPhysMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	SetMaterialByName(MaterialSlotName: string,Material: MaterialInterface): void;
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	SetMassScale(BoneName: string,InMassScale: number): void;
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	SetLinearDamping(InDamping: number): void;
	SetLightingChannels(bChannel0: boolean,bChannel1: boolean,bChannel2: boolean): void;
	SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean): void;
	SetHiddenInSceneCapture(bValue: boolean): void;
	SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean): void;
	SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean): void;
	SetEnableGravity(bGravityEnabled: boolean): void;
	SetEmissiveLightSource(NewEmissiveLightSource: boolean): void;
	SetDefaultCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetDefaultCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetDefaultCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetDefaultCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomDepthStencilWriteMask(WriteMaskBit: ERendererStencilMask): void;
	SetCustomDepthStencilValue(Value: number): void;
	SetCullDistance(NewCullDistance: number): void;
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	SetCollisionProfileName(InCollisionProfileName: string,bUpdateOverlaps: boolean): void;
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	SetCastShadow(NewCastShadow: boolean): void;
	SetCastInsetShadow(bInCastInsetShadow: boolean): void;
	SetCastHiddenShadow(NewCastHiddenShadow: boolean): void;
	SetCastContactShadow(bInCastContactShadow: boolean): void;
	SetBoundsScale(NewBoundsScale: number): void;
	SetAngularDamping(InDamping: number): void;
	SetAllUseCCD(InUseCCD: boolean): void;
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllMassScale(InMassScale: number): void;
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	PutRigidBodyToSleep(BoneName: string): void;
	K2_SphereTraceComponent(TraceStart: Vector,TraceEnd: Vector,SphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_SphereOverlapComponent(InSphereCentre: Vector,InSphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_IsQueryCollisionEnabled(): boolean;
	K2_IsPhysicsCollisionEnabled(): boolean;
	K2_IsCollisionEnabled(): boolean;
	K2_BoxOverlapComponent(InBoxCentre: Vector,InBox: Box,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsGravityEnabled(): boolean;
	IsAnyRigidBodyAwake(): boolean;
	IgnoreComponentWhenMoving(Component: PrimitiveComponent,bShouldIgnore: boolean): void;
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	GetPhysicsAngularVelocityInRadians(BoneName: string): Vector;
	GetPhysicsAngularVelocityInDegrees(BoneName: string): Vector;
	GetOverlappingComponents(OutOverlappingComponents?: PrimitiveComponent[]): {OutOverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetNumMaterials(): number;
	GetMaterialFromCollisionFaceIndex(FaceIndex: number,SectionIndex?: number): {SectionIndex: number, $: MaterialInterface};
	GetMaterial(ElementIndex: number): MaterialInterface;
	GetMassScale(BoneName: string): number;
	GetMass(): number;
	GetLinearDamping(): number;
	GetInertiaTensor(BoneName: string): Vector;
	GetGenerateOverlapEvents(): boolean;
	GetCustomPrimitiveDataIndexForVectorParameter(ParameterName: string): number;
	GetCustomPrimitiveDataIndexForScalarParameter(ParameterName: string): number;
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	GetCollisionProfileName(): string;
	GetCollisionObjectType(): ECollisionChannel;
	GetCollisionEnabled(): ECollisionEnabled;
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	GetCenterOfMass(BoneName: string): Vector;
	GetAngularDamping(): number;
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface,OptionalName: string): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;
	CopyArrayOfMoveIgnoreComponents(): PrimitiveComponent[];
	CopyArrayOfMoveIgnoreActors(): Actor[];
	ClearMoveIgnoreComponents(): void;
	ClearMoveIgnoreActors(): void;
	CanCharacterStepUp(Pawn: Pawn): boolean;
	AddVelocityChangeImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddTorqueInRadians(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddTorqueInDegrees(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddForceAtLocationLocal(Force: Vector,Location: Vector,BoneName: string): void;
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	AddAngularImpulseInRadians(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddAngularImpulseInDegrees(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	static C(Other: UObject | any): PrimitiveComponent;
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SetCastInsetShadowForAllAttachments(bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent,bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
}

declare class MRMeshBodyHolder extends UObject { 
	BodySetup: BodySetup;
	BodyInstance: BodyInstance;
	static Load(ResourceName: string): MRMeshBodyHolder;
	static Find(Outer: UObject, ResourceName: string): MRMeshBodyHolder;
	static GetDefaultObject(): MRMeshBodyHolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshBodyHolder;
	static C(Other: UObject | any): MRMeshBodyHolder;
}

declare class MRMeshComponent extends PrimitiveComponent { 
	Material: MaterialInterface;
	WireframeMaterial: MaterialInterface;
	bCreateMeshProxySections: boolean;
	bUpdateNavMeshOnMeshUpdate: boolean;
	bNeverCreateCollisionMesh: boolean;
	BodyHolders: MRMeshBodyHolder[];
	static Load(ResourceName: string): MRMeshComponent;
	static Find(Outer: UObject, ResourceName: string): MRMeshComponent;
	static GetDefaultObject(): MRMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshComponent;
	SetWireframeMaterial(InMaterial: MaterialInterface): void;
	SetWireframeColor(InColor: LinearColor): void;
	SetUseWireframe(bUseWireframe: boolean): void;
	SetEnableMeshOcclusion(bEnable: boolean): void;
	RequestNavMeshUpdate(): void;
	IsConnected(): boolean;
	GetWireframeColor(): LinearColor;
	GetUseWireframe(): boolean;
	GetEnableMeshOcclusion(): boolean;
	ForceNavMeshUpdate(): void;
	Clear(): void;
	static C(Other: UObject | any): MRMeshComponent;
}

declare type EARObjectClassification = 'NotApplicable' | 'Unknown' | 'Wall' | 'Ceiling' | 'Floor' | 'Table' | 'Seat' | 'Face' | 'Image' | 'World' | 'SceneObject' | 'HandMesh' | 'Door' | 'Window' | 'EARObjectClassification_MAX';
declare var EARObjectClassification : { NotApplicable:'NotApplicable',Unknown:'Unknown',Wall:'Wall',Ceiling:'Ceiling',Floor:'Floor',Table:'Table',Seat:'Seat',Face:'Face',Image:'Image',World:'World',SceneObject:'SceneObject',HandMesh:'HandMesh',Door:'Door',Window:'Window',EARObjectClassification_MAX:'EARObjectClassification_MAX', };
declare type EARSpatialMeshUsageFlags = 'NotApplicable' | 'Visible' | 'Collision' | 'EARSpatialMeshUsageFlags_MAX';
declare var EARSpatialMeshUsageFlags : { NotApplicable:'NotApplicable',Visible:'Visible',Collision:'Collision',EARSpatialMeshUsageFlags_MAX:'EARSpatialMeshUsageFlags_MAX', };
declare class ARTrackedGeometry extends UObject { 
	UniqueId: Guid;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	UnderlyingMesh: MRMeshComponent;
	ObjectClassification: EARObjectClassification;
	SpatialMeshUsageFlags: EARSpatialMeshUsageFlags;
	LastUpdateFrameNumber: number;
	DebugName: string;
	static Load(ResourceName: string): ARTrackedGeometry;
	static Find(Outer: UObject, ResourceName: string): ARTrackedGeometry;
	static GetDefaultObject(): ARTrackedGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedGeometry;
	IsTracked(): boolean;
	HasSpatialMeshUsageFlag(InFlag: EARSpatialMeshUsageFlags): boolean;
	GetUnderlyingMesh(): MRMeshComponent;
	GetTrackingState(): EARTrackingState;
	GetObjectClassification(): EARObjectClassification;
	GetName(): string;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetLastUpdateTimestamp(): number;
	GetLastUpdateFrameNumber(): number;
	GetDebugName(): string;
	static C(Other: UObject | any): ARTrackedGeometry;
	DebugDrawTrackedGeometry(WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
}

declare class ARTraceResult { 
	DistanceFromCamera: number;
	TraceChannel: EARLineTraceChannels;
	LocalTransform: Transform;
	TrackedGeometry: ARTrackedGeometry;
	clone() : ARTraceResult;
	static C(Other: UObject | any): ARTraceResult;
	GetDistanceFromCamera(): number;
	GetLocalToTrackingTransform(): Transform;
	GetLocalToWorldTransform(): Transform;
	GetLocalTransform(): Transform;
	GetTraceChannel(): EARLineTraceChannels;
	GetTrackedGeometry(): ARTrackedGeometry;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
}

declare type EHMDTrackingOrigin = 'Floor' | 'Eye' | 'Stage' | 'EHMDTrackingOrigin_MAX';
declare var EHMDTrackingOrigin : { Floor:'Floor',Eye:'Eye',Stage:'Stage',EHMDTrackingOrigin_MAX:'EHMDTrackingOrigin_MAX', };
declare class Vector2D { 
	X: any;
	Y: any;
	clone() : Vector2D;
	static C(Other: UObject | any): Vector2D;
	Conv_Vector2dToText(): string;
	Conv_Vector2dToString(): string;
	Add_Vector2DFloat(B: any): Vector2D;
	Add_Vector2DVector2D(B: Vector2D): Vector2D;
	BreakVector2D(X?: any,Y?: any): {X: any, Y: any};
	ClampAxes2D(MinAxisVal: any,MaxAxisVal: any): Vector2D;
	Conv_Vector2DToIntPoint(): IntPoint;
	Conv_Vector2DToVector(Z: number): Vector;
	CrossProduct2D(B: Vector2D): any;
	Distance2D(v2: Vector2D): any;
	DistanceSquared2D(v2: Vector2D): any;
	Divide_Vector2DFloat(B: any): Vector2D;
	Divide_Vector2DVector2D(B: Vector2D): Vector2D;
	DotProduct2D(B: Vector2D): any;
	EqualEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	EqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	GetAbs2D(): Vector2D;
	GetAbsMax2D(): any;
	GetMax2D(): any;
	GetMin2D(): any;
	GetRotated2D(AngleDeg: number): Vector2D;
	IsNearlyZero2D(Tolerance: number): boolean;
	IsZero2D(): boolean;
	MakeBox2D(Max: Vector2D): Box2D;
	Multiply_Vector2DFloat(B: any): Vector2D;
	Multiply_Vector2DVector2D(B: Vector2D): Vector2D;
	Negated2D(): Vector2D;
	Normal2D(): Vector2D;
	Normalize2D(Tolerance?: number): {A: Vector2D};
	NormalSafe2D(Tolerance: number): Vector2D;
	NotEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	NotEqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	Set2D(X?: any,Y?: any): {A: Vector2D};
	Spherical2DToUnitCartesian(): Vector;
	Subtract_Vector2DFloat(B: any): Vector2D;
	Subtract_Vector2DVector2D(B: Vector2D): Vector2D;
	ToDirectionAndLength2D(OutDir?: Vector2D,OutLength?: any): {OutDir: Vector2D, OutLength: any};
	ToRounded2D(): Vector2D;
	ToSign2D(): Vector2D;
	Vector2DInterpTo(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	Vector2DInterpTo_Constant(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	VSize2D(): any;
	VSize2DSquared(): any;
	SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	LineTraceTrackedObjects(bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static Conv_Vector2dToText(InVec: Vector2D): string;
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Add_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static BreakVector2D(InVec: Vector2D,X?: any,Y?: any): {X: any, Y: any};
	static ClampAxes2D(A: Vector2D,MinAxisVal: any,MaxAxisVal: any): Vector2D;
	static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;
	static Conv_Vector2DToVector(InVector2D: Vector2D,Z: number): Vector;
	static CrossProduct2D(A: Vector2D,B: Vector2D): any;
	static Distance2D(v1: Vector2D,v2: Vector2D): any;
	static DistanceSquared2D(v1: Vector2D,v2: Vector2D): any;
	static Divide_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Divide_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static DotProduct2D(A: Vector2D,B: Vector2D): any;
	static EqualEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static EqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static GetAbs2D(A: Vector2D): Vector2D;
	static GetAbsMax2D(A: Vector2D): any;
	static GetMax2D(A: Vector2D): any;
	static GetMin2D(A: Vector2D): any;
	static GetRotated2D(A: Vector2D,AngleDeg: number): Vector2D;
	static IsNearlyZero2D(A: Vector2D,Tolerance: number): boolean;
	static IsZero2D(A: Vector2D): boolean;
	static MakeBox2D(Min: Vector2D,Max: Vector2D): Box2D;
	static Multiply_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Negated2D(A: Vector2D): Vector2D;
	static Normal2D(A: Vector2D): Vector2D;
	static Normalize2D(A?: Vector2D,Tolerance?: number): {A: Vector2D};
	static NormalSafe2D(A: Vector2D,Tolerance: number): Vector2D;
	static NotEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static NotEqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static Set2D(A?: Vector2D,X?: any,Y?: any): {A: Vector2D};
	static Spherical2DToUnitCartesian(A: Vector2D): Vector;
	static Subtract_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static ToDirectionAndLength2D(A: Vector2D,OutDir?: Vector2D,OutLength?: any): {OutDir: Vector2D, OutLength: any};
	static ToRounded2D(A: Vector2D): Vector2D;
	static ToSign2D(A: Vector2D): Vector2D;
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static VSize2D(A: Vector2D): any;
	static VSize2DSquared(A: Vector2D): any;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	static MakeVector2D(X: any,Y: any): Vector2D;
	static Vector2D_One(): Vector2D;
	static Vector2D_Unit45Deg(): Vector2D;
	static Vector2D_Zero(): Vector2D;
	static NextSobolCell2D(index: number,NumCells: number,PreviousValue: Vector2D): Vector2D;
	static RandomSobolCell2D(index: number,NumCells: number,Cell: Vector2D,Seed: Vector2D): Vector2D;
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
}

declare class VectorSpringState { 
	clone() : VectorSpringState;
	static C(Other: UObject | any): VectorSpringState;
	ResetVectorSpringState(): {SpringState: VectorSpringState};
	SetVectorSpringStateVelocity(Velocity?: Vector): {SpringState: VectorSpringState};
	static ResetVectorSpringState(SpringState?: VectorSpringState): {SpringState: VectorSpringState};
	static SetVectorSpringStateVelocity(SpringState?: VectorSpringState,Velocity?: Vector): {SpringState: VectorSpringState};
}

declare class Vector { 
	X: any;
	Y: any;
	Z: any;
	clone() : Vector;
	static C(Other: UObject | any): Vector;
	GenerateBoxMesh(Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	GetLevelViewportCameraInfo(CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	SetLevelViewportCameraInfo(CameraRotation: Rotator): void;
	GetSelectionBounds(BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	SegmentIntersection2D(SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	Conv_VectorToText(): string;
	Conv_VectorToString(): string;
	Add_VectorFloat(B: any): Vector;
	Add_VectorInt(B: number): Vector;
	Add_VectorVector(B: Vector): Vector;
	BreakVector(X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	ClampVectorSize(Min: any,Max: any): Vector;
	Conv_VectorToLinearColor(): LinearColor;
	Conv_VectorToQuaternion(): Quat;
	Conv_VectorToRotator(): Rotator;
	Conv_VectorToTransform(): Transform;
	Conv_VectorToVector2D(): Vector2D;
	Cross_VectorVector(B: Vector): Vector;
	Divide_VectorFloat(B: any): Vector;
	Divide_VectorInt(B: number): Vector;
	Divide_VectorVector(B: Vector): Vector;
	Dot_VectorVector(B: Vector): any;
	DynamicWeightedMovingAverage_FVector(PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	EqualEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	EqualExactly_VectorVector(B: Vector): boolean;
	FindClosestPointOnLine(LineOrigin: Vector,LineDirection: Vector): Vector;
	FindClosestPointOnSegment(SegmentStart: Vector,SegmentEnd: Vector): Vector;
	FindLookAtRotation(Target: Vector): Rotator;
	FindNearestPointsOnLineSegments(Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	FTruncVector(): IntVector;
	GetAzimuthAndElevation(ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	GetDirectionUnitVector(To: Vector): Vector;
	GetMaxElement(): any;
	GetMinElement(): any;
	GetPointDistanceToLine(LineOrigin: Vector,LineDirection: Vector): number;
	GetPointDistanceToSegment(SegmentStart: Vector,SegmentEnd: Vector): number;
	GetReflectionVector(SurfaceNormal: Vector): Vector;
	GetSlopeDegreeAngles(FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	GetYawPitchFromVector(Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	GreaterGreater_VectorRotator(B: Rotator): Vector;
	IsPointInBox(BoxOrigin: Vector,BoxExtent: Vector): boolean;
	IsPointInBoxWithTransform(BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	LessLess_VectorRotator(B: Rotator): Vector;
	LinePlaneIntersection(LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	LinePlaneIntersection_OriginNormal(LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	MakeBox(Max: Vector): Box;
	MakeBoxSphereBounds(BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	MakePlaneFromPointAndNormal(Normal: Vector): Plane;
	MakeRotationFromAxes(Right: Vector,Up: Vector): Rotator;
	MakeRotFromX(): Rotator;
	MakeRotFromXY(Y: Vector): Rotator;
	MakeRotFromXZ(Z: Vector): Rotator;
	MakeRotFromY(): Rotator;
	MakeRotFromYX(X: Vector): Rotator;
	MakeRotFromYZ(Z: Vector): Rotator;
	MakeRotFromZ(): Rotator;
	MakeRotFromZX(X: Vector): Rotator;
	MakeRotFromZY(Y: Vector): Rotator;
	MakeTransform(Rotation: Rotator,Scale: Vector): Transform;
	MirrorVectorByNormal(InNormal: Vector): Vector;
	Multiply_VectorFloat(B: any): Vector;
	Multiply_VectorInt(B: number): Vector;
	Multiply_VectorVector(B: Vector): Vector;
	NegateVector(): Vector;
	Normal(Tolerance: number): Vector;
	NotEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	NotEqualExactly_VectorVector(B: Vector): boolean;
	ProjectPointOnToPlane(PlaneBase: Vector,PlaneNormal: Vector): Vector;
	ProjectVectorOnToPlane(PlaneNormal: Vector): Vector;
	ProjectVectorOnToVector(Target: Vector): Vector;
	Quat_MakeFromEuler(): Quat;
	RandomPointInBoundingBox(HalfSize: Vector): Vector;
	RandomPointInBoundingBoxFromStream(HalfSize: Vector,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInDegrees(ConeHalfAngleInDegrees: number): Vector;
	RandomUnitVectorInConeInDegreesFromStream(ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInRadians(ConeHalfAngleInRadians: number): Vector;
	RandomUnitVectorInConeInRadiansFromStream(ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInDegrees(MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	RandomUnitVectorInEllipticalConeInDegreesFromStream(MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInRadians(MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	RandomUnitVectorInEllipticalConeInRadiansFromStream(MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	RotateAngleAxis(AngleDeg: number,Axis: Vector): Vector;
	RotatorFromAxisAndAngle(Angle: number): Rotator;
	SelectVector(B: Vector,bPickA: boolean): Vector;
	Subtract_VectorFloat(B: any): Vector;
	Subtract_VectorInt(B: number): Vector;
	Subtract_VectorVector(B: Vector): Vector;
	VEase(B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	Vector_AddBounded(InAddVect?: Vector,InRadius?: number): {A: Vector};
	Vector_Assign(InVector?: Vector): {A: Vector};
	Vector_BoundedToBox(InBoxMin: Vector,InBoxMax: Vector): Vector;
	Vector_BoundedToCube(InRadius: number): Vector;
	Vector_ClampSize2D(Min: any,Max: any): Vector;
	Vector_ClampSizeMax(Max: any): Vector;
	Vector_ClampSizeMax2D(Max: any): Vector;
	Vector_ComponentMax(B: Vector): Vector;
	Vector_ComponentMin(B: Vector): Vector;
	Vector_CosineAngle2D(B: Vector): any;
	Vector_Distance(v2: Vector): any;
	Vector_Distance2D(v2: Vector): any;
	Vector_Distance2DSquared(v2: Vector): any;
	Vector_DistanceSquared(v2: Vector): any;
	Vector_GetAbs(): Vector;
	Vector_GetAbsMax(): any;
	Vector_GetAbsMin(): any;
	Vector_GetProjection(): Vector;
	Vector_GetSignVector(): Vector;
	Vector_HeadingAngle(): any;
	Vector_IsNAN(): boolean;
	Vector_IsNearlyZero(Tolerance: number): boolean;
	Vector_IsNormal(): boolean;
	Vector_IsUniform(Tolerance: number): boolean;
	Vector_IsUnit(SquaredLenthTolerance: number): boolean;
	Vector_IsZero(): boolean;
	Vector_MirrorByPlane(InPlane: Plane): Vector;
	Vector_Normal2D(Tolerance: number): Vector;
	Vector_Normalize(Tolerance?: number): {A: Vector};
	Vector_NormalUnsafe(): Vector;
	Vector_ProjectOnToNormal(InNormal: Vector): Vector;
	Vector_Reciprocal(): Vector;
	Vector_Set(X?: any,Y?: any,Z?: any): {A: Vector};
	Vector_SnappedToGrid(InGridSize: number): Vector;
	Vector_ToDegrees(): Vector;
	Vector_ToRadians(): Vector;
	Vector_UnitCartesianToSpherical(): Vector2D;
	Vector_UnwindEuler(): {A: Vector};
	VectorSpringInterp(Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	VInterpTo(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VInterpTo_Constant(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VLerp(B: Vector,Alpha: number): Vector;
	VSize(): any;
	VSizeSquared(): any;
	VSizeXY(): any;
	VSizeXYSquared(): any;
	WeightedMovingAverage_FVector(PreviousSample: Vector,Weight: number): Vector;
	FindNearestActor(ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	IsValidAIDirection(): boolean;
	IsValidAILocation(): boolean;
	GetPositionalTrackingCameraParameters(CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	GetTrackingSensorParameters(Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	AddManualEnvironmentCaptureProbe(Extent: Vector): boolean;
	GetObjectClassificationAtLocation(OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	LineTraceTrackedObjects3D(End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	SetARWorldOriginLocationAndRotation(OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	CalculateDirection(BaseRotation: Rotator): number;
	K2_TwoBoneIK(JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static GetLevelViewportCameraInfo(CameraLocation?: Vector,CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	static SetLevelViewportCameraInfo(CameraLocation: Vector,CameraRotation: Rotator): void;
	static GetSelectionBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	static Conv_VectorToText(InVec: Vector): string;
	static Conv_VectorToString(InVec: Vector): string;
	static Add_VectorFloat(A: Vector,B: any): Vector;
	static Add_VectorInt(A: Vector,B: number): Vector;
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	static BreakVector(InVec: Vector,X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static ClampVectorSize(A: Vector,Min: any,Max: any): Vector;
	static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
	static Conv_VectorToQuaternion(InVec: Vector): Quat;
	static Conv_VectorToRotator(InVec: Vector): Rotator;
	static Conv_VectorToTransform(InLocation: Vector): Transform;
	static Conv_VectorToVector2D(InVector: Vector): Vector2D;
	static Cross_VectorVector(A: Vector,B: Vector): Vector;
	static Divide_VectorFloat(A: Vector,B: any): Vector;
	static Divide_VectorInt(A: Vector,B: number): Vector;
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	static Dot_VectorVector(A: Vector,B: Vector): any;
	static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	static EqualEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static EqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	static FTruncVector(InVector: Vector): IntVector;
	static GetAzimuthAndElevation(InDirection: Vector,ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	static GetDirectionUnitVector(From: Vector,To: Vector): Vector;
	static GetMaxElement(A: Vector): any;
	static GetMinElement(A: Vector): any;
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	static GetReflectionVector(Direction: Vector,SurfaceNormal: Vector): Vector;
	static GetSlopeDegreeAngles(MyRightYAxis: Vector,FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	static GreaterGreater_VectorRotator(A: Vector,B: Rotator): Vector;
	static IsPointInBox(Point: Vector,BoxOrigin: Vector,BoxExtent: Vector): boolean;
	static IsPointInBoxWithTransform(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	static LessLess_VectorRotator(A: Vector,B: Rotator): Vector;
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinePlaneIntersection_OriginNormal(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static MakeBox(Min: Vector,Max: Vector): Box;
	static MakeBoxSphereBounds(Origin: Vector,BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	static MakeRotFromX(X: Vector): Rotator;
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	static MakeRotFromY(Y: Vector): Rotator;
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	static MakeRotFromZ(Z: Vector): Rotator;
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	static Multiply_VectorFloat(A: Vector,B: any): Vector;
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	static NegateVector(A: Vector): Vector;
	static Normal(A: Vector,Tolerance: number): Vector;
	static NotEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static NotEqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	static Quat_MakeFromEuler(Euler: Vector): Quat;
	static RandomPointInBoundingBox(Center: Vector,HalfSize: Vector): Vector;
	static RandomPointInBoundingBoxFromStream(Center: Vector,HalfSize: Vector,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInDegrees(ConeDir: Vector,ConeHalfAngleInDegrees: number): Vector;
	static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector,ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInRadians(ConeDir: Vector,ConeHalfAngleInRadians: number): Vector;
	static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector,ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	static RotateAngleAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	static Subtract_VectorFloat(A: Vector,B: any): Vector;
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	static VEase(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	static Vector_AddBounded(A?: Vector,InAddVect?: Vector,InRadius?: number): {A: Vector};
	static Vector_Assign(A?: Vector,InVector?: Vector): {A: Vector};
	static Vector_BoundedToBox(InVect: Vector,InBoxMin: Vector,InBoxMax: Vector): Vector;
	static Vector_BoundedToCube(InVect: Vector,InRadius: number): Vector;
	static Vector_ClampSize2D(A: Vector,Min: any,Max: any): Vector;
	static Vector_ClampSizeMax(A: Vector,Max: any): Vector;
	static Vector_ClampSizeMax2D(A: Vector,Max: any): Vector;
	static Vector_ComponentMax(A: Vector,B: Vector): Vector;
	static Vector_ComponentMin(A: Vector,B: Vector): Vector;
	static Vector_CosineAngle2D(A: Vector,B: Vector): any;
	static Vector_Distance(v1: Vector,v2: Vector): any;
	static Vector_Distance2D(v1: Vector,v2: Vector): any;
	static Vector_Distance2DSquared(v1: Vector,v2: Vector): any;
	static Vector_DistanceSquared(v1: Vector,v2: Vector): any;
	static Vector_GetAbs(A: Vector): Vector;
	static Vector_GetAbsMax(A: Vector): any;
	static Vector_GetAbsMin(A: Vector): any;
	static Vector_GetProjection(A: Vector): Vector;
	static Vector_GetSignVector(A: Vector): Vector;
	static Vector_HeadingAngle(A: Vector): any;
	static Vector_IsNAN(A: Vector): boolean;
	static Vector_IsNearlyZero(A: Vector,Tolerance: number): boolean;
	static Vector_IsNormal(A: Vector): boolean;
	static Vector_IsUniform(A: Vector,Tolerance: number): boolean;
	static Vector_IsUnit(A: Vector,SquaredLenthTolerance: number): boolean;
	static Vector_IsZero(A: Vector): boolean;
	static Vector_MirrorByPlane(A: Vector,InPlane: Plane): Vector;
	static Vector_Normal2D(A: Vector,Tolerance: number): Vector;
	static Vector_Normalize(A?: Vector,Tolerance?: number): {A: Vector};
	static Vector_NormalUnsafe(A: Vector): Vector;
	static Vector_ProjectOnToNormal(V: Vector,InNormal: Vector): Vector;
	static Vector_Reciprocal(A: Vector): Vector;
	static Vector_Set(A?: Vector,X?: any,Y?: any,Z?: any): {A: Vector};
	static Vector_SnappedToGrid(InVect: Vector,InGridSize: number): Vector;
	static Vector_ToDegrees(A: Vector): Vector;
	static Vector_ToRadians(A: Vector): Vector;
	static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;
	static Vector_UnwindEuler(A?: Vector): {A: Vector};
	static VectorSpringInterp(Current: Vector,Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VLerp(A: Vector,B: Vector,Alpha: number): Vector;
	static VSize(A: Vector): any;
	static VSizeSquared(A: Vector): any;
	static VSizeXY(A: Vector): any;
	static VSizeXYSquared(A: Vector): any;
	static WeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,Weight: number): Vector;
	static FindNearestActor(Origin: Vector,ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static Conv_DoubleToVector(InDouble: any): Vector;
	static Conv_FloatToVector(InFloat: number): Vector;
	static Conv_IntToVector(inInt: number): Vector;
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	static MakeVector(X: any,Y: any,Z: any): Vector;
	static RandomUnitVector(): Vector;
	static Vector_Backward(): Vector;
	static Vector_Down(): Vector;
	static Vector_Forward(): Vector;
	static Vector_Left(): Vector;
	static Vector_One(): Vector;
	static Vector_Right(): Vector;
	static Vector_Up(): Vector;
	static Vector_Zero(): Vector;
	static NextSobolCell3D(index: number,NumCells: number,PreviousValue: Vector): Vector;
	static RandomSobolCell3D(index: number,NumCells: number,Cell: Vector,Seed: Vector): Vector;
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
	static K2_MakePerlinNoiseVectorAndRemap(X: number,Y: number,Z: number,RangeOutMinX: number,RangeOutMaxX: number,RangeOutMinY: number,RangeOutMaxY: number,RangeOutMinZ: number,RangeOutMaxZ: number): Vector;
}

declare type EVectorQuantization = 'RoundWholeNumber' | 'RoundOneDecimal' | 'RoundTwoDecimals' | 'EVectorQuantization_MAX';
declare var EVectorQuantization : { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals',EVectorQuantization_MAX:'EVectorQuantization_MAX', };
declare type ERotatorQuantization = 'ByteComponents' | 'ShortComponents' | 'ERotatorQuantization_MAX';
declare var ERotatorQuantization : { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents',ERotatorQuantization_MAX:'ERotatorQuantization_MAX', };
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	LocationQuantizationLevel: EVectorQuantization;
	VelocityQuantizationLevel: EVectorQuantization;
	RotationQuantizationLevel: ERotatorQuantization;
	clone() : RepMovement;
	static C(Other: UObject | any): RepMovement;
}

declare type EActorGridPlacement = 'Bounds' | 'Location' | 'AlwaysLoaded' | 'None' | 'EActorGridPlacement_MAX';
declare var EActorGridPlacement : { Bounds:'Bounds',Location:'Location',AlwaysLoaded:'AlwaysLoaded',None:'None',EActorGridPlacement_MAX:'EActorGridPlacement_MAX', };
declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject | any): RepAttachment;
}

declare type ENetDormancy = 'DORM_Never' | 'DORM_Awake' | 'DORM_DormantAll' | 'DORM_DormantPartial' | 'DORM_Initial' | 'DORM_MAX';
declare var ENetDormancy : { DORM_Never:'DORM_Never',DORM_Awake:'DORM_Awake',DORM_DormantAll:'DORM_DormantAll',DORM_DormantPartial:'DORM_DormantPartial',DORM_Initial:'DORM_Initial',DORM_MAX:'DORM_MAX', };
declare type EChildActorComponentTreeViewVisualizationMode = 'UseDefault' | 'ComponentOnly' | 'ComponentWithChildActor' | 'ChildActorOnly' | 'EChildActorComponentTreeViewVisualizationMode_MAX';
declare var EChildActorComponentTreeViewVisualizationMode : { UseDefault:'UseDefault',ComponentOnly:'ComponentOnly',ComponentWithChildActor:'ComponentWithChildActor',ChildActorOnly:'ChildActorOnly',EChildActorComponentTreeViewVisualizationMode_MAX:'EChildActorComponentTreeViewVisualizationMode_MAX', };
declare class ChildActorComponent extends SceneComponent { 
	ChildActorClass: UnrealEngineClass;
	ChildActor: Actor;
	ChildActorTemplate: Actor;
	EditorTreeViewVisualizationMode: EChildActorComponentTreeViewVisualizationMode;
	static Load(ResourceName: string): ChildActorComponent;
	static Find(Outer: UObject, ResourceName: string): ChildActorComponent;
	static GetDefaultObject(): ChildActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildActorComponent;
	SetChildActorClass(InClass: UnrealEngineClass): void;
	static C(Other: UObject | any): ChildActorComponent;
}

declare class ScriptTypedElementHandle { 
	clone() : ScriptTypedElementHandle;
	static C(Other: UObject | any): ScriptTypedElementHandle;
}

declare class Actor extends UObject { 
	PrimaryActorTick: ActorTickFunction;
	bNetTemporary: boolean;
	bNetStartup: boolean;
	bOnlyRelevantToOwner: boolean;
	bAlwaysRelevant: boolean;
	bReplicateMovement: boolean;
	bCallPreReplication: boolean;
	bCallPreReplicationForReplay: boolean;
	bHidden: boolean;
	bTearOff: boolean;
	bForceNetAddressable: boolean;
	bIsInEditingLevelInstance: boolean;
	bExchangedRoles: boolean;
	bNetLoadOnClient: boolean;
	bNetUseOwnerRelevancy: boolean;
	bRelevantForNetworkReplays: boolean;
	bRelevantForLevelBounds: boolean;
	bReplayRewindable: boolean;
	bAllowTickBeforeBeginPlay: boolean;
	bAutoDestroyWhenFinished: boolean;
	bCanBeDamaged: boolean;
	bBlockInput: boolean;
	bCollideWhenPlacing: boolean;
	bFindCameraComponentWhenViewTarget: boolean;
	bGenerateOverlapEventsDuringLevelStreaming: boolean;
	bIgnoresOriginShifting: boolean;
	bEnableAutoLODGeneration: boolean;
	bIsEditorOnlyActor: boolean;
	bActorSeamlessTraveled: boolean;
	bReplicates: boolean;
	bCanBeInCluster: boolean;
	bAllowReceiveTickEventOnDedicatedServer: boolean;
	bActorEnableCollision: boolean;
	bActorIsBeingDestroyed: boolean;
	UpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	DefaultUpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	RemoteRole: ENetRole;
	ReplicatedMovement: RepMovement;
	InitialLifeSpan: number;
	CustomTimeDilation: number;
	GridPlacement: EActorGridPlacement;
	RuntimeGrid: string;
	AttachmentReplication: RepAttachment;
	Owner: Actor;
	NetDriverName: string;
	Role: ENetRole;
	NetDormancy: ENetDormancy;
	SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
	AutoReceiveInput: EAutoReceiveInput;
	InputPriority: number;
	InputComponent: InputComponent;
	NetCullDistanceSquared: number;
	NetTag: number;
	NetUpdateFrequency: number;
	MinNetUpdateFrequency: number;
	NetPriority: number;
	Instigator: Pawn;
	Children: Actor[];
	RootComponent: SceneComponent;
	PivotOffset: Vector;
	HLODLayer: HLODLayer;
	RayTracingGroupId: number;
	Layers: string[];
	ParentComponentActor: any;
	ParentComponent: any;
	ActorGuid: Guid;
	DataLayers: ActorDataLayer[];
	GroupActor: Actor;
	SpriteScale: number;
	HiddenEditorViews: any;
	ActorLabel: string;
	FolderPath: string;
	FolderGuid: Guid;
	bHiddenEd: boolean;
	bIsEditorPreviewActor: boolean;
	bHiddenEdLayer: boolean;
	bHiddenEdLevel: boolean;
	bLockLocation: boolean;
	bActorLabelEditable: boolean;
	bEditable: boolean;
	bListedInSceneOutliner: boolean;
	bOptimizeBPComponentData: boolean;
	bCanPlayFromHere: boolean;
	bIsSpatiallyLoaded: boolean;
	bHiddenEdTemporary: boolean;
	bForceExternalActorLevelReferenceForPIE: boolean;
	Tags: string[];
	OnTakeAnyDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnTakePointDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnTakeRadialDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, Origin: Vector, HitInfo: HitResult, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnActorBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnActorEndOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnActorHit: UnrealEngineMulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnDestroyed: UnrealEngineMulticastDelegate<(DestroyedActor: Actor) => void>;
	OnEndPlay: UnrealEngineMulticastDelegate<(Actor: Actor, EndPlayReason: EEndPlayReason) => void>;
	InstanceComponents: ActorComponent[];
	BlueprintCreatedComponents: ActorComponent[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static GetDefaultObject(): Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Actor;
	WasRecentlyRendered(Tolerance: number): boolean;
	UserConstructionScript(): void;
	TearOff(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetReplicates(bInReplicates: boolean): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	SetRayTracingGroupId(InRaytracingGroupId: number): void;
	SetOwner(NewOwner: Actor): void;
	SetNetDormancy(NewDormancy: ENetDormancy): void;
	SetLifeSpan(InLifespan: number): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	SetFolderPath(NewFolderPath: string): void;
	SetAutoDestroyWhenFinished(bVal: boolean): void;
	SetActorTickInterval(TickInterval: number): void;
	SetActorTickEnabled(bEnabled: boolean): void;
	SetActorScale3D(NewScale3D: Vector): void;
	SetActorRelativeScale3D(NewRelativeScale: Vector): void;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorHiddenInGame(bNewHidden: boolean): void;
	SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveRadialDamage(DamageReceived: number,DamageType: DamageType,Origin: Vector,HitInfo: HitResult,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceivePointDamage(Damage: number,DamageType: DamageType,HitLocation: Vector,HitNormal: Vector,HitComponent: PrimitiveComponent,BoneName: string,ShotFromDirection: Vector,InstigatedBy: Controller,DamageCauser: Actor,HitInfo: HitResult): void;
	ReceiveHit(MyComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,bSelfMoved: boolean,HitLocation: Vector,HitNormal: Vector,NormalImpulse: Vector,Hit: HitResult): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveDestroyed(): void;
	ReceiveBeginPlay(): void;
	ReceiveAnyDamage(Damage: number,DamageType: DamageType,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceiveActorOnReleased(ButtonReleased: Key): void;
	ReceiveActorOnInputTouchLeave(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnter(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnd(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchBegin(FingerIndex: ETouchIndex): void;
	ReceiveActorOnClicked(ButtonPressed: Key): void;
	ReceiveActorEndOverlap(OtherActor: Actor): void;
	ReceiveActorEndCursorOver(): void;
	ReceiveActorBeginOverlap(OtherActor: Actor): void;
	ReceiveActorBeginCursorOver(): void;
	PrestreamTextures(Seconds: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	OnRep_ReplicateMovement(): void;
	OnRep_ReplicatedMovement(): void;
	OnRep_Owner(): void;
	OnRep_Instigator(): void;
	OnRep_AttachmentReplication(): void;
	MakeNoise(Loudness: number,NoiseInstigator: Pawn,NoiseLocation: Vector,MaxRange: number,Tag: string): void;
	K2_TeleportTo(DestLocation: Vector,DestRotation: Rotator): boolean;
	K2_SetActorTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorRotation(NewRotation: Rotator,bTeleportPhysics: boolean): boolean;
	K2_SetActorRelativeTransform(NewRelativeTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeRotation(NewRelativeRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeLocation(NewRelativeLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_OnReset(): void;
	K2_OnEndViewTarget(PC: PlayerController): void;
	K2_OnBecomeViewTarget(PC: PlayerController): void;
	K2_GetRootComponent(): SceneComponent;
	K2_GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	K2_GetActorRotation(): Rotator;
	K2_GetActorLocation(): Vector;
	K2_DetachFromActor(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule): void;
	K2_DestroyActor(): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachToActor(ParentActor: Actor,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentToActor(InParentActor: Actor,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentTo(InParent: SceneComponent,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AddActorWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsTemporarilyHiddenInEditor(bIncludeParent: boolean): boolean;
	IsSelectable(): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsHiddenEdAtStartup(): boolean;
	IsHiddenEd(): boolean;
	IsEditable(): boolean;
	IsChildActor(): boolean;
	IsActorTickEnabled(): boolean;
	IsActorBeingDestroyed(): boolean;
	HasAuthority(): boolean;
	GetVerticalDistanceTo(OtherActor: Actor): number;
	GetVelocity(): Vector;
	GetTransform(): Transform;
	GetTickableWhenPaused(): boolean;
	GetSquaredHorizontalDistanceTo(OtherActor: Actor): number;
	GetSquaredDistanceTo(OtherActor: Actor): number;
	GetRemoteRole(): ENetRole;
	GetRayTracingGroupId(): number;
	GetParentComponent(): ChildActorComponent;
	GetParentActor(): Actor;
	GetOwner(): Actor;
	GetOverlappingComponents(OverlappingComponents?: PrimitiveComponent[]): {OverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetLocalRole(): ENetRole;
	GetLifeSpan(): number;
	GetLevelTransform(): Transform;
	GetLevel(): Level;
	GetInstigatorController(): Controller;
	GetInstigator(): Pawn;
	GetInputVectorAxisValue(InputAxisKey: Key): Vector;
	GetInputAxisValue(InputAxisName: string): number;
	GetInputAxisKeyValue(InputAxisKey: Key): number;
	GetHorizontalDotProductTo(OtherActor: Actor): number;
	GetHorizontalDistanceTo(OtherActor: Actor): number;
	GetGameTimeSinceCreation(): number;
	GetFolderPath(): string;
	GetDotProductTo(OtherActor: Actor): number;
	GetDistanceTo(OtherActor: Actor): number;
	GetDefaultActorLabel(): string;
	GetComponentsByTag(ComponentClass: UnrealEngineClass,Tag: string): ActorComponent[];
	GetComponentsByInterface(Interface: UnrealEngineClass): ActorComponent[];
	GetComponentByClass(ComponentClass: UnrealEngineClass): ActorComponent;
	GetAttachParentSocketName(): string;
	GetAttachParentActor(): Actor;
	GetAttachedActors(OutActors?: Actor[],bResetArray?: boolean,bRecursivelyIncludeAttachedActors?: boolean): {OutActors: Actor[]};
	GetAllChildActors(ChildActors?: Actor[],bIncludeDescendants?: boolean): {ChildActors: Actor[]};
	GetActorUpVector(): Vector;
	GetActorTimeDilation(): number;
	GetActorTickInterval(): number;
	GetActorScale3D(): Vector;
	GetActorRightVector(): Vector;
	GetActorRelativeScale3D(): Vector;
	GetActorLabel(bCreateIfNone: boolean): string;
	GetActorForwardVector(): Vector;
	GetActorEyesViewPoint(OutLocation?: Vector,OutRotation?: Rotator): {OutLocation: Vector, OutRotation: Rotator};
	GetActorEnableCollision(): boolean;
	GetActorBounds(bOnlyCollidingComponents: boolean,Origin?: Vector,BoxExtent?: Vector,bIncludeFromChildActors?: boolean): {Origin: Vector, BoxExtent: Vector};
	ForceNetUpdate(): void;
	FlushNetDormancy(): void;
	FinishAddComponent(Component: ActorComponent,bManualAttachment: boolean,RelativeTransform: Transform): void;
	EnableInput(PlayerController: PlayerController): void;
	DisableInput(PlayerController: PlayerController): void;
	DetachRootComponentFromParent(bMaintainWorldPosition: boolean): void;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	AddComponentByClass(Class: UnrealEngineClass,bManualAttachment: boolean,RelativeTransform: Transform,bDeferredFinish: boolean): ActorComponent;
	AddComponent(TemplateName: string,bManualAttachment: boolean,RelativeTransform: Transform,ComponentTemplateContext: UObject,bDeferredFinish: boolean): ActorComponent;
	ActorHasTag(Tag: string): boolean;
	static C(Other: UObject | any): Actor;
	ClearActorLabel(): void;
	GetActorLabel(): string;
	GetActorLocation(): Vector;
	GetActorRotation(): Rotator;
	GetFolderPath(): string;
	IsActorLabelEditable(): boolean;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorLabelUnique(NewActorLabel: string,InExistingActorLabels: string[]): void;
	SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	SetFolderPath(NewFolderPath: string): void;
	SetFolderPath_Recursively(NewFolderPath: string): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	AddActorToLayer(Layer: ActorLayer): void;
	RemoveActorFromLayer(Layer: ActorLayer): void;
	DestroyActor(): boolean;
	PilotLevelActor(): void;
	SetActorSelectionState(bShouldBeSelected: boolean): void;
	Actor_GetWorld(): World;
	GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	GetLastRenderTime(): number;
	GetLevel(): Level;
	IsPendingKill(): boolean;
	ReregisterAllComponents(): void;
	SetActorFlags(Flags: number): void;
	SetRootComponent(Component: SceneComponent): void;
	ConvertActorToLightWeightInstance(): ActorInstanceHandle;
	GetActorBounds(Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ApplyDamage(BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	ApplyPointDamage(BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	FinishSpawningActor(SpawnTransform: Transform): Actor;
	K2_AcquireEditorActorElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	GetAIController(): AIController;
	GetBlackboard(): BlackboardComponent;
	AddDeviceVisualizationComponentBlocking(XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	AddNamedDeviceVisualizationComponentBlocking(SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static ClearActorLabel(Actor: Actor): void;
	static GetActorLabel(Actor: Actor): string;
	static GetActorLocation(Actor: Actor): Vector;
	static GetActorRotation(Actor: Actor): Rotator;
	static GetFolderPath(Actor: Actor): string;
	static IsActorLabelEditable(Actor: Actor): boolean;
	static SetActorLabel(Actor: Actor,NewActorLabel: string,bMarkDirty: boolean): void;
	static SetActorLabelUnique(Actor: Actor,NewActorLabel: string,InExistingActorLabels: string[]): void;
	static SetActorLocation(Actor: Actor,NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	static SetFolderPath(Actor: Actor,NewFolderPath: string): void;
	static SetFolderPath_Recursively(Actor: Actor,NewFolderPath: string): void;
	static SetIsTemporarilyHiddenInEditor(Actor: Actor,bIsHidden: boolean): void;
	static AddActorToLayer(InActor: Actor,Layer: ActorLayer): void;
	static RemoveActorFromLayer(InActor: Actor,Layer: ActorLayer): void;
	static DestroyActor(ActorToDestroy: Actor): boolean;
	static PilotLevelActor(ActorToPilot: Actor): void;
	static SetActorSelectionState(Actor: Actor,bShouldBeSelected: boolean): void;
	static Actor_GetWorld(Actor: Actor): World;
	static GetComponentsByClass(Actor: Actor,ComponentClass: UnrealEngineClass): ActorComponent[];
	static GetLastRenderTime(Actor: Actor): number;
	static GetLevel(Actor: Actor): Level;
	static IsPendingKill(InActor: Actor): boolean;
	static ReregisterAllComponents(Actor: Actor): void;
	static SetActorFlags(Actor: Actor,Flags: number): void;
	static SetRootComponent(Actor: Actor,Component: SceneComponent): void;
	static ConvertActorToLightWeightInstance(Actor: Actor): ActorInstanceHandle;
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ApplyDamage(DamagedActor: Actor,BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static ApplyPointDamage(DamagedActor: Actor,BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static FinishSpawningActor(Actor: Actor,SpawnTransform: Transform): Actor;
	static K2_AcquireEditorActorElementHandle(Actor: Actor,bAllowCreate: boolean): ScriptTypedElementHandle;
	static GetAIController(ControlledActor: Actor): AIController;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
}

declare class ActorComponent extends UObject { 
	PrimaryComponentTick: ActorComponentTickFunction;
	ComponentTags: string[];
	AssetUserData: AssetUserData[];
	UCSSerializationIndex: number;
	bNetAddressable: boolean;
	bReplicates: boolean;
	bCreatedByConstructionScript: boolean;
	bInstanceComponent: boolean;
	bAutoActivate: boolean;
	bIsActive: boolean;
	bEditableWhenInherited: boolean;
	bCanEverAffectNavigation: boolean;
	bIsEditorOnly: boolean;
	bIsVisualizationComponent: boolean;
	bNeedsUCSSerializationIndexEvaluted: boolean;
	CreationMethod: EComponentCreationMethod;
	OnComponentActivated: UnrealEngineMulticastDelegate<(Component: ActorComponent, bReset: boolean) => void>;
	OnComponentDeactivated: UnrealEngineMulticastDelegate<(Component: ActorComponent) => void>;
	UCSModifiedProperties: SimpleMemberReference[];
	static Load(ResourceName: string): ActorComponent;
	static Find(Outer: UObject, ResourceName: string): ActorComponent;
	static GetDefaultObject(): ActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	ToggleActive(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetIsReplicated(ShouldReplicate: boolean): void;
	SetComponentTickIntervalAndCooldown(TickInterval: number): void;
	SetComponentTickInterval(TickInterval: number): void;
	SetComponentTickEnabled(bEnabled: boolean): void;
	SetAutoActivate(bNewAutoActivate: boolean): void;
	SetActive(bNewActive: boolean,bReset: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveBeginPlay(): void;
	OnRep_IsActive(): void;
	K2_DestroyComponent(UObject: UObject): void;
	IsComponentTickEnabled(): boolean;
	IsBeingDestroyed(): boolean;
	IsActive(): boolean;
	GetOwner(): Actor;
	GetComponentTickInterval(): number;
	Deactivate(): void;
	ComponentHasTag(Tag: string): boolean;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Activate(bReset: boolean): void;
	static C(Other: UObject | any): ActorComponent;
	IsRegistered(): boolean;
	MarkRenderStateDirty(): void;
	RegisterComponent(): void;
	ReregisterComponent(): void;
	UnregisterComponent(): void;
	K2_AcquireEditorComponentElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	static MarkRenderStateDirty(Component: ActorComponent): void;
	static RegisterComponent(ActorComponent: ActorComponent): void;
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	static UnregisterComponent(ActorComponent: ActorComponent): void;
	static K2_AcquireEditorComponentElementHandle(Component: ActorComponent,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare class BlueprintComponentChangedPropertyInfo { 
	PropertyName: string;
	ArrayIndex: number;
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject | any): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	bHasValidCookedData: boolean;
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject | any): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject | any): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	InternalVariableName: string;
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static GetDefaultObject(): SCS_Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject | any): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	AllNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static GetDefaultObject(): SimpleConstructionScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject | any): SimpleConstructionScript;
}

declare type ETimelineLengthMode = 'TL_TimelineLength' | 'TL_LastKeyFrame' | 'TL_MAX';
declare var ETimelineLengthMode : { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame',TL_MAX:'TL_MAX', };
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
	bIsExpanded: boolean;
	bIsCurveViewSynchronized: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject | any): TTTrackBase;
}

declare class TTEventTrack extends TTTrackBase { 
	FunctionName: string;
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject | any): TTEventTrack;
}

declare class TTPropertyTrack extends TTTrackBase { 
	PropertyName: string;
	clone() : TTPropertyTrack;
	static C(Other: UObject | any): TTPropertyTrack;
}

declare class TTFloatTrack extends TTPropertyTrack { 
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject | any): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static GetDefaultObject(): CurveVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject | any): CurveVector;
}

declare class TTVectorTrack extends TTPropertyTrack { 
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject | any): TTVectorTrack;
}

declare class TTLinearColorTrack extends TTPropertyTrack { 
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject | any): TTLinearColorTrack;
}

declare class TTTrackId { 
	TrackType: number;
	TrackIndex: number;
	clone() : TTTrackId;
	static C(Other: UObject | any): TTTrackId;
}

declare class TimelineTemplate extends UObject { 
	TimeLineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	TimelineTickGroup: ETickingGroup;
	VariableName: string;
	DirectionPropertyName: string;
	UpdateFunctionName: string;
	FinishedFunctionName: string;
	TrackDisplayOrder: TTTrackId[];
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static GetDefaultObject(): TimelineTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject | any): TimelineTemplate;
}

declare class BPComponentClassOverride { 
	ComponentName: string;
	ComponentClass: UnrealEngineClass;
	clone() : BPComponentClassOverride;
	static C(Other: UObject | any): BPComponentClassOverride;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject | any): ComponentKey;
}

declare class ComponentOverrideRecord { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject | any): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	UnnecessaryComponents: ActorComponent[];
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static GetDefaultObject(): InheritableComponentHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject | any): InheritableComponentHandler;
}

declare type ELifetimeCondition = 'COND_None' | 'COND_InitialOnly' | 'COND_OwnerOnly' | 'COND_SkipOwner' | 'COND_SimulatedOnly' | 'COND_AutonomousOnly' | 'COND_SimulatedOrPhysics' | 'COND_InitialOrOwner' | 'COND_Custom' | 'COND_ReplayOrOwner' | 'COND_ReplayOnly' | 'COND_SimulatedOnlyNoReplay' | 'COND_SimulatedOrPhysicsNoReplay' | 'COND_SkipReplay' | 'COND_Never' | 'COND_Max';
declare var ELifetimeCondition : { COND_None:'COND_None',COND_InitialOnly:'COND_InitialOnly',COND_OwnerOnly:'COND_OwnerOnly',COND_SkipOwner:'COND_SkipOwner',COND_SimulatedOnly:'COND_SimulatedOnly',COND_AutonomousOnly:'COND_AutonomousOnly',COND_SimulatedOrPhysics:'COND_SimulatedOrPhysics',COND_InitialOrOwner:'COND_InitialOrOwner',COND_Custom:'COND_Custom',COND_ReplayOrOwner:'COND_ReplayOrOwner',COND_ReplayOnly:'COND_ReplayOnly',COND_SimulatedOnlyNoReplay:'COND_SimulatedOnlyNoReplay',COND_SimulatedOrPhysicsNoReplay:'COND_SimulatedOrPhysicsNoReplay',COND_SkipReplay:'COND_SkipReplay',COND_Never:'COND_Never',COND_Max:'COND_Max', };
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: any;
	RepNotifyFunc: string;
	ReplicationCondition: ELifetimeCondition;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject | any): BPVariableDescription;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject | any): BPInterfaceDescription;
}

declare class BPEditorBookmarkNode { 
	NodeGuid: Guid;
	ParentGuid: Guid;
	DisplayName: string;
	clone() : BPEditorBookmarkNode;
	static C(Other: UObject | any): BPEditorBookmarkNode;
}

declare class Breakpoint extends UObject { 
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static GetDefaultObject(): Breakpoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject | any): Breakpoint;
}

declare class EdGraphPinReference { 
	OwningNode: any;
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject | any): EdGraphPinReference;
}

declare class BlueprintExtension extends UObject { 
	static Load(ResourceName: string): BlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): BlueprintExtension;
	static GetDefaultObject(): BlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintExtension;
	static C(Other: UObject | any): BlueprintExtension;
}

declare class Blueprint extends BlueprintCore { 
	ParentClass: UnrealEngineClass;
	BlueprintType: EBlueprintType;
	bRecompileOnLoad: boolean;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bBeingCompiled: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bQueuedForCompilation: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bRunConstructionScriptInSequencer: boolean;
	bGenerateConstClass: boolean;
	bGenerateAbstractClass: boolean;
	bDisplayCompilePIEWarning: boolean;
	bDeprecate: boolean;
	bDuplicatingReadOnly: boolean;
	NativizationFlag: EBlueprintNativizationFlag;
	CompileMode: EBlueprintCompileMode;
	Status: EBlueprintStatus;
	BlueprintDisplayName: string;
	BlueprintDescription: string;
	BlueprintNamespace: string;
	BlueprintCategory: string;
	HideCategories: string[];
	BlueprintSystemVersion: number;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	PRIVATE_CachedMacroInfo: any;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	InheritableComponentHandler: InheritableComponentHandler;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImportedNamespaces: any;
	ImplementedInterfaces: BPInterfaceDescription[];
	LastEditedDocuments: EditedDocumentInfo[];
	Bookmarks: any;
	BookmarkNodes: BPEditorBookmarkNode[];
	Breakpoints: Breakpoint[];
	WatchedPins: EdGraphPinReference[];
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	ComponentTemplateNameIndex: any;
	OldToNewComponentTemplateNames: any;
	Extensions: BlueprintExtension[];
	ThumbnailInfo: ThumbnailInfo;
	CrcLastCompiledCDO: any;
	CrcLastCompiledSignature: any;
	bCachedDependenciesUpToDate: boolean;
	CachedDependencies: any;
	CachedDependents: any;
	CachedUDSDependencies: any;
	OriginalClass: UnrealEngineClass;
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static GetDefaultObject(): Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject | any): Blueprint;
	AddComponentsToBlueprint(Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	CompileBlueprint(): void;
	GetParentClassOfBlueprint(): UnrealEngineClass;
	RemoveComponentFromBlueprint(RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	AddFunctionGraph(FuncName: string): EdGraph;
	CompileBlueprint(): void;
	FindEventGraph(): EdGraph;
	FindGraph(GraphName: string): EdGraph;
	RemoveFunctionGraph(FuncName: string): void;
	RemoveGraph(Graph: EdGraph): void;
	RemoveUnusedNodes(): void;
	RemoveUnusedVariables(): number;
	ReparentBlueprint(NewParentClass: UnrealEngineClass): void;
	ReplaceVariableReferences(OldVarName: string,NewVarName: string): void;
	UpgradeOperatorNodes(): void;
	static AddComponentsToBlueprint(Blueprint: Blueprint,Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static GetParentClassOfBlueprint(Blueprint: Blueprint): UnrealEngineClass;
	static RemoveComponentFromBlueprint(Blueprint: Blueprint,RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
}

declare type ERigVMGraphNotifType = 'GraphChanged' | 'NodeAdded' | 'NodeRemoved' | 'NodeSelected' | 'NodeDeselected' | 'NodeSelectionChanged' | 'NodePositionChanged' | 'NodeSizeChanged' | 'NodeColorChanged' | 'PinAdded' | 'PinRemoved' | 'PinRenamed' | 'PinExpansionChanged' | 'PinWatchedChanged' | 'PinArraySizeChanged' | 'PinDefaultValueChanged' | 'PinDirectionChanged' | 'PinTypeChanged' | 'PinIndexChanged' | 'LinkAdded' | 'LinkRemoved' | 'CommentTextChanged' | 'RerouteCompactnessChanged' | 'VariableAdded' | 'VariableRemoved' | 'VariableRenamed' | 'ParameterAdded' | 'ParameterRemoved' | 'ParameterRenamed' | 'InteractionBracketOpened' | 'InteractionBracketClosed' | 'InteractionBracketCanceled' | 'PinBoundVariableChanged' | 'NodeRenamed' | 'NodeReferenceChanged' | 'NodeCategoryChanged' | 'NodeKeywordsChanged' | 'NodeDescriptionChanged' | 'VariableRemappingChanged' | 'Invalid' | 'ERigVMGraphNotifType_MAX';
declare var ERigVMGraphNotifType : { GraphChanged:'GraphChanged',NodeAdded:'NodeAdded',NodeRemoved:'NodeRemoved',NodeSelected:'NodeSelected',NodeDeselected:'NodeDeselected',NodeSelectionChanged:'NodeSelectionChanged',NodePositionChanged:'NodePositionChanged',NodeSizeChanged:'NodeSizeChanged',NodeColorChanged:'NodeColorChanged',PinAdded:'PinAdded',PinRemoved:'PinRemoved',PinRenamed:'PinRenamed',PinExpansionChanged:'PinExpansionChanged',PinWatchedChanged:'PinWatchedChanged',PinArraySizeChanged:'PinArraySizeChanged',PinDefaultValueChanged:'PinDefaultValueChanged',PinDirectionChanged:'PinDirectionChanged',PinTypeChanged:'PinTypeChanged',PinIndexChanged:'PinIndexChanged',LinkAdded:'LinkAdded',LinkRemoved:'LinkRemoved',CommentTextChanged:'CommentTextChanged',RerouteCompactnessChanged:'RerouteCompactnessChanged',VariableAdded:'VariableAdded',VariableRemoved:'VariableRemoved',VariableRenamed:'VariableRenamed',ParameterAdded:'ParameterAdded',ParameterRemoved:'ParameterRemoved',ParameterRenamed:'ParameterRenamed',InteractionBracketOpened:'InteractionBracketOpened',InteractionBracketClosed:'InteractionBracketClosed',InteractionBracketCanceled:'InteractionBracketCanceled',PinBoundVariableChanged:'PinBoundVariableChanged',NodeRenamed:'NodeRenamed',NodeReferenceChanged:'NodeReferenceChanged',NodeCategoryChanged:'NodeCategoryChanged',NodeKeywordsChanged:'NodeKeywordsChanged',NodeDescriptionChanged:'NodeDescriptionChanged',VariableRemappingChanged:'VariableRemappingChanged',Invalid:'Invalid',ERigVMGraphNotifType_MAX:'ERigVMGraphNotifType_MAX', };
declare type ERigVMPinDirection = 'Input' | 'Output' | 'IO' | 'Visible' | 'Hidden' | 'Invalid' | 'ERigVMPinDirection_MAX';
declare var ERigVMPinDirection : { Input:'Input',Output:'Output',IO:'IO',Visible:'Visible',Hidden:'Hidden',Invalid:'Invalid',ERigVMPinDirection_MAX:'ERigVMPinDirection_MAX', };
declare class RigVMLink extends UObject { 
	SourcePinPath: string;
	TargetPinPath: string;
	static Load(ResourceName: string): RigVMLink;
	static Find(Outer: UObject, ResourceName: string): RigVMLink;
	static GetDefaultObject(): RigVMLink;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLink;
	GetTargetPin(): RigVMPin;
	GetSourcePin(): RigVMPin;
	GetPinPathRepresentation(): string;
	GetLinkIndex(): number;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLink;
}

declare class RigVMUnitNode extends RigVMNode { 
	ScriptStruct: ScriptStruct;
	MethodName: string;
	static Load(ResourceName: string): RigVMUnitNode;
	static Find(Outer: UObject, ResourceName: string): RigVMUnitNode;
	static GetDefaultObject(): RigVMUnitNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUnitNode;
	GetStructDefaultValue(): string;
	GetScriptStruct(): ScriptStruct;
	GetMethodName(): string;
	static C(Other: UObject | any): RigVMUnitNode;
}

declare class RigVMInjectionInfo extends UObject { 
	UnitNode: RigVMUnitNode;
	UNode: RigVMNode;
	bInjectedAsInput: boolean;
	InputPin: RigVMPin;
	OutputPin: RigVMPin;
	static Load(ResourceName: string): RigVMInjectionInfo;
	static Find(Outer: UObject, ResourceName: string): RigVMInjectionInfo;
	static GetDefaultObject(): RigVMInjectionInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMInjectionInfo;
	GetPin(): RigVMPin;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMInjectionInfo;
}

declare class RigVMPin extends UObject { 
	DisplayName: string;
	Direction: ERigVMPinDirection;
	bIsExpanded: boolean;
	bIsConstant: boolean;
	bRequiresWatch: boolean;
	bIsDynamicArray: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	CPPTypeObjectPath: string;
	DefaultValue: string;
	CustomWidgetName: string;
	SubPins: RigVMPin[];
	Links: RigVMLink[];
	InjectionInfos: RigVMInjectionInfo[];
	BoundVariablePath: string;
	static Load(ResourceName: string): RigVMPin;
	static Find(Outer: UObject, ResourceName: string): RigVMPin;
	static GetDefaultObject(): RigVMPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMPin;
	RequiresWatch(bCheckExposedPinChain: boolean): boolean;
	IsUObject(): boolean;
	IsUnknownType(): boolean;
	IsStructMember(): boolean;
	IsStruct(): boolean;
	IsStringType(): boolean;
	IsRootPin(): boolean;
	IsReferenceCountedContainer(): boolean;
	IsLinkedTo(InPin: RigVMPin): boolean;
	IsExpanded(): boolean;
	IsExecuteContext(): boolean;
	IsDynamicArray(): boolean;
	IsDefinedAsConstant(): boolean;
	IsArrayElement(): boolean;
	IsArray(): boolean;
	GetToolTipText(): string;
	GetTargetLinks(bRecursive: boolean): RigVMLink[];
	GetSubPins(): RigVMPin[];
	GetSourceLinks(bRecursive: boolean): RigVMLink[];
	GetSegmentPath(bIncludeRootPin: boolean): string;
	GetScriptStruct(): ScriptStruct;
	GetRootPin(): RigVMPin;
	GetPinPath(bUseNodePath: boolean): string;
	GetPinIndex(): number;
	GetPinForLink(): RigVMPin;
	GetParentPin(): RigVMPin;
	GetOriginalPinFromInjectedNode(): RigVMPin;
	GetNode(): RigVMNode;
	GetLinks(): RigVMLink[];
	GetLinkedTargetPins(bRecursive: boolean): RigVMPin[];
	GetLinkedSourcePins(bRecursive: boolean): RigVMPin[];
	GetGraph(): RigVMGraph;
	GetEnum(): Enum;
	GetDisplayName(): string;
	GetDirection(): ERigVMPinDirection;
	GetDefaultValue(): string;
	GetCustomWidgetName(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	GetArraySize(): number;
	GetArrayElementCppType(): string;
	FindSubPin(InPinPath: string): RigVMPin;
	static C(Other: UObject | any): RigVMPin;
}

declare class RigVMNode extends UObject { 
	NodeTitle: string;
	position: Vector2D;
	Size: Vector2D;
	NodeColor: LinearColor;
	PreviousName: string;
	bHasBreakpoint: boolean;
	bHaltedAtThisNode: boolean;
	Pins: RigVMPin[];
	OrphanedPins: RigVMPin[];
	static Load(ResourceName: string): RigVMNode;
	static Find(Outer: UObject, ResourceName: string): RigVMNode;
	static GetDefaultObject(): RigVMNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMNode;
	SetHasBreakpoint(bValue: boolean): void;
	SetExecutionIsHaltedAtThisNode(bValue: boolean): void;
	IsVisibleInUI(): boolean;
	IsSelected(): boolean;
	IsPure(): boolean;
	IsMutable(): boolean;
	IsLinkedTo(InNode: RigVMNode): boolean;
	IsInjected(): boolean;
	IsEvent(): boolean;
	IsDefinedAsVarying(): boolean;
	IsDefinedAsConstant(): boolean;
	HasPinOfDirection(InDirection: ERigVMPinDirection): boolean;
	HasOutputPin(bIncludeIO: boolean): boolean;
	HasOrphanedPins(): boolean;
	HasIOPin(): boolean;
	HasInputPin(bIncludeIO: boolean): boolean;
	HasBreakpoint(): boolean;
	GetToolTipText(): string;
	GetSize(): Vector2D;
	GetRootGraph(): RigVMGraph;
	GetPreviousFName(): string;
	GetPosition(): Vector2D;
	GetPins(): RigVMPin[];
	GetOrphanedPins(): RigVMPin[];
	GetNodeTitle(): string;
	GetNodePath(bRecursive: boolean): string;
	GetNodeIndex(): number;
	GetNodeColor(): LinearColor;
	GetLinks(): RigVMLink[];
	GetLinkedTargetNodes(): RigVMNode[];
	GetLinkedSourceNodes(): RigVMNode[];
	GetInjectionInfo(): RigVMInjectionInfo;
	GetGraph(): RigVMGraph;
	GetEventName(): string;
	GetAllPinsRecursively(): RigVMPin[];
	FindPin(InPinPath: string): RigVMPin;
	ExecutionIsHaltedAtThisNode(): boolean;
	static C(Other: UObject | any): RigVMNode;
}

declare class RigVMGraphVariableDescription { 
	Name: string;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphVariableDescription;
	static C(Other: UObject | any): RigVMGraphVariableDescription;
}

declare class RigVMLibraryNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMLibraryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMLibraryNode;
	static GetDefaultObject(): RigVMLibraryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLibraryNode;
	GetLibrary(): RigVMFunctionLibrary;
	GetContainedGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLibraryNode;
}

declare class RigVMFunctionReferenceNode extends RigVMLibraryNode { 
	ReferencedNodePtr: RigVMLibraryNode;
	VariableMap: any;
	static Load(ResourceName: string): RigVMFunctionReferenceNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReferenceNode;
	static GetDefaultObject(): RigVMFunctionReferenceNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReferenceNode;
	static C(Other: UObject | any): RigVMFunctionReferenceNode;
}

declare class RigVMBuildData extends UObject { 
	FunctionReferences: any;
	static Load(ResourceName: string): RigVMBuildData;
	static Find(Outer: UObject, ResourceName: string): RigVMBuildData;
	static GetDefaultObject(): RigVMBuildData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBuildData;
	static C(Other: UObject | any): RigVMBuildData;
}

declare class RigVMFunctionLibrary extends RigVMGraph { 
	FunctionReferences: any;
	LocalizedFunctions: any;
	static Load(ResourceName: string): RigVMFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionLibrary;
	static GetDefaultObject(): RigVMFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionLibrary;
	GetReferencesForFunction(InFunctionName: string): RigVMFunctionReferenceNode[];
	GetReferencePathsForFunction(InFunctionName: string): string[];
	GetFunctions(): RigVMLibraryNode[];
	GetBuildData(): RigVMBuildData;
	FindFunctionForNode(InNode: RigVMNode): RigVMLibraryNode;
	FindFunction(InFunctionName: string): RigVMLibraryNode;
	static C(Other: UObject | any): RigVMFunctionLibrary;
}

declare class RigVMFunctionReturnNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMFunctionReturnNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReturnNode;
	static GetDefaultObject(): RigVMFunctionReturnNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReturnNode;
	static C(Other: UObject | any): RigVMFunctionReturnNode;
}

declare class RigVMGraphParameterDescription { 
	Name: string;
	bIsInput: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphParameterDescription;
	static C(Other: UObject | any): RigVMGraphParameterDescription;
}

declare class RigVMFunctionEntryNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMFunctionEntryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionEntryNode;
	static GetDefaultObject(): RigVMFunctionEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionEntryNode;
	static C(Other: UObject | any): RigVMFunctionEntryNode;
}

declare class RigVMGraph extends UObject { 
	Nodes: RigVMNode[];
	Links: RigVMLink[];
	SelectedNodes: string[];
	DefaultFunctionLibraryPtr: any;
	LocalVariables: RigVMGraphVariableDescription[];
	static Load(ResourceName: string): RigVMGraph;
	static Find(Outer: UObject, ResourceName: string): RigVMGraph;
	static GetDefaultObject(): RigVMGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMGraph;
	SetDefaultFunctionLibrary(InFunctionLibrary: RigVMFunctionLibrary): void;
	IsTopLevelGraph(): boolean;
	IsRootGraph(): boolean;
	IsNodeSelected(InNodeName: string): boolean;
	GetVariableDescriptions(): RigVMGraphVariableDescription[];
	GetSelectNodes(): string[];
	GetRootGraph(): RigVMGraph;
	GetReturnNode(): RigVMFunctionReturnNode;
	GetParentGraph(): RigVMGraph;
	GetParameterDescriptions(): RigVMGraphParameterDescription[];
	GetOutputArguments(): RigVMGraphVariableDescription[];
	GetNodes(): RigVMNode[];
	GetNodePath(): string;
	GetLocalVariables(bIncludeInputArguments: boolean): RigVMGraphVariableDescription[];
	GetLinks(): RigVMLink[];
	GetInputArguments(): RigVMGraphVariableDescription[];
	GetGraphName(): string;
	GetEntryNode(): RigVMFunctionEntryNode;
	GetDefaultFunctionLibrary(): RigVMFunctionLibrary;
	GetContainedGraphs(bRecursive: boolean): RigVMGraph[];
	FindPin(InPinPath: string): RigVMPin;
	FindNodeByName(InNodeName: string): RigVMNode;
	FindNode(InNodePath: string): RigVMNode;
	FindLink(InLinkPinPathRepresentation: string): RigVMLink;
	static C(Other: UObject | any): RigVMGraph;
}

declare class RigVMActionKey { 
	ScriptStructPath: string;
	ExportedText: string;
	clone() : RigVMActionKey;
	static C(Other: UObject | any): RigVMActionKey;
}

declare class RigVMActionStack extends UObject { 
	ActionIndex: number;
	UndoActions: RigVMActionKey[];
	RedoActions: RigVMActionKey[];
	static Load(ResourceName: string): RigVMActionStack;
	static Find(Outer: UObject, ResourceName: string): RigVMActionStack;
	static GetDefaultObject(): RigVMActionStack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMActionStack;
	Undo(InController: RigVMController): boolean;
	Redo(InController: RigVMController): boolean;
	OpenUndoBracket(InTitle: string): boolean;
	CloseUndoBracket(): boolean;
	CancelUndoBracket(): boolean;
	static C(Other: UObject | any): RigVMActionStack;
}

declare class RigVMCollapseNode extends RigVMLibraryNode { 
	ContainedGraph: RigVMGraph;
	NodeCategory: string;
	NodeKeywords: string;
	NodeDescription: string;
	static Load(ResourceName: string): RigVMCollapseNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCollapseNode;
	static GetDefaultObject(): RigVMCollapseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCollapseNode;
	static C(Other: UObject | any): RigVMCollapseNode;
}

declare class RigVMVariableNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMVariableNode;
	static Find(Outer: UObject, ResourceName: string): RigVMVariableNode;
	static GetDefaultObject(): RigVMVariableNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMVariableNode;
	IsLocalVariable(): boolean;
	IsInputArgument(): boolean;
	IsGetter(): boolean;
	GetVariableName(): string;
	GetVariableDescription(): RigVMGraphVariableDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMVariableNode;
}

declare class RigVMSelectNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMSelectNode;
	static Find(Outer: UObject, ResourceName: string): RigVMSelectNode;
	static GetDefaultObject(): RigVMSelectNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMSelectNode;
	static C(Other: UObject | any): RigVMSelectNode;
}

declare class RigVMRerouteNode extends RigVMNode { 
	bShowAsFullNode: boolean;
	static Load(ResourceName: string): RigVMRerouteNode;
	static Find(Outer: UObject, ResourceName: string): RigVMRerouteNode;
	static GetDefaultObject(): RigVMRerouteNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMRerouteNode;
	GetShowsAsFullNode(): boolean;
	static C(Other: UObject | any): RigVMRerouteNode;
}

declare class RigVMPrototypeNode extends RigVMNode { 
	PrototypeNotation: string;
	SupportedTypesCache: any;
	static Load(ResourceName: string): RigVMPrototypeNode;
	static Find(Outer: UObject, ResourceName: string): RigVMPrototypeNode;
	static GetDefaultObject(): RigVMPrototypeNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMPrototypeNode;
	GetNotation(): string;
	static C(Other: UObject | any): RigVMPrototypeNode;
}

declare class RigVMParameterNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMParameterNode;
	static Find(Outer: UObject, ResourceName: string): RigVMParameterNode;
	static GetDefaultObject(): RigVMParameterNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMParameterNode;
	IsInput(): boolean;
	GetParameterName(): string;
	GetParameterDescription(): RigVMGraphParameterDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMParameterNode;
}

declare class RigVMIfNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMIfNode;
	static Find(Outer: UObject, ResourceName: string): RigVMIfNode;
	static GetDefaultObject(): RigVMIfNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMIfNode;
	static C(Other: UObject | any): RigVMIfNode;
}

declare class RigVMEnumNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMEnumNode;
	static Find(Outer: UObject, ResourceName: string): RigVMEnumNode;
	static GetDefaultObject(): RigVMEnumNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMEnumNode;
	GetEnum(): Enum;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMEnumNode;
}

declare class RigVMCommentNode extends RigVMNode { 
	CommentText: string;
	FontSize: number;
	bBubbleVisible: boolean;
	bColorBubble: boolean;
	static Load(ResourceName: string): RigVMCommentNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCommentNode;
	static GetDefaultObject(): RigVMCommentNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCommentNode;
	GetCommentText(): string;
	GetCommentFontSize(): number;
	GetCommentColorBubble(): boolean;
	GetCommentBubbleVisible(): boolean;
	static C(Other: UObject | any): RigVMCommentNode;
}

declare class RigVMBranchNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMBranchNode;
	static Find(Outer: UObject, ResourceName: string): RigVMBranchNode;
	static GetDefaultObject(): RigVMBranchNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBranchNode;
	static C(Other: UObject | any): RigVMBranchNode;
}

declare class RigVMArrayNode extends RigVMNode { 
	OpCode: ERigVMOpCode;
	static Load(ResourceName: string): RigVMArrayNode;
	static Find(Outer: UObject, ResourceName: string): RigVMArrayNode;
	static GetDefaultObject(): RigVMArrayNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMArrayNode;
	GetOpCode(): ERigVMOpCode;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMArrayNode;
}

declare class RigVMController extends UObject { 
	ModifiedEventDynamic: UnrealEngineMulticastDelegate<(NotifType: ERigVMGraphNotifType, Graph: RigVMGraph, Subject: UObject) => void>;
	Graphs: RigVMGraph[];
	ExecuteContextStruct: Struct;
	ActionStack: RigVMActionStack;
	static Load(ResourceName: string): RigVMController;
	static Find(Outer: UObject, ResourceName: string): RigVMController;
	static GetDefaultObject(): RigVMController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMController;
	Undo(): boolean;
	UnbindPinFromVariable(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRerouteCompactnessByName(InNodeName: string,bShowAsFullNode: boolean,bSetupUndoRedo: boolean): boolean;
	SetRerouteCompactness(InNode: RigVMNode,bShowAsFullNode: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRemappedVariable(InFunctionRefNode: RigVMFunctionReferenceNode,InInnerVariableName: string,InOuterVariableName: string,bSetupUndoRedo: boolean): boolean;
	SetPinIsWatched(InPinPath: string,bIsWatched: boolean,bSetupUndoRedo: boolean): boolean;
	SetPinExpansion(InPinPath: string,bIsExpanded: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetPinDefaultValue(InPinPath: string,InDefaultValue: string,bResizeArrays: boolean,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSizeByName(InNodeName: string,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSize(InNode: RigVMNode,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSelection(InNodeNames: string[],bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePositionByName(InNodeName: string,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePosition(InNode: RigVMNode,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeKeywordsByName(InNodeName: string,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeKeywords(InNode: RigVMCollapseNode,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeDescriptionByName(InNodeName: string,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeDescription(InNode: RigVMCollapseNode,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeColorByName(InNodeName: string,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeColor(InNode: RigVMNode,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeCategoryByName(InNodeName: string,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeCategory(InNode: RigVMCollapseNode,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableTypeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableType(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableDefaultValue(InVariableName: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bNotify: boolean): boolean;
	SetIsRunningUnitTest(bIsRunning: boolean): void;
	SetGraph(InGraph: RigVMGraph): void;
	SetExposedPinIndex(InPinName: string,InNewIndex: number,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentTextByName(InNodeName: string,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentText(InNode: RigVMNode,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetArrayPinSize(InArrayPinPath: string,InSize: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SelectNodeByName(InNodeName: string,bSelect: boolean,bSetupUndoRedo: boolean): boolean;
	SelectNode(InNode: RigVMNode,bSelect: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ResetPinDefaultValue(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ReplaceParameterNodeWithVariable(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean): RigVMVariableNode;
	RenameVariable(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameParameter(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameNode(InNode: RigVMNode,InNewName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameLocalVariable(InVariableName: string,InNewVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameFunction(InOldFunctionName: string,InNewFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RenameExposedPin(InOldPinName: string,InNewPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveNodeByName(InNodeName: string,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveNode(InNode: RigVMNode,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveLocalVariable(InVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveInjectedNode(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveFunctionFromLibrary(InFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RemoveExposedPin(InPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RefreshVariableNode(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bSetupOrphanPins: boolean): void;
	Redo(): boolean;
	PushGraph(InGraph: RigVMGraph,bSetupUndoRedo: boolean): void;
	PromotePinToVariable(InPinPath: string,bCreateVariableNode: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	PromoteFunctionReferenceNodeToCollapseNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bRemoveFunctionDefinition: boolean): string;
	PromoteCollapseNodeToFunctionReferenceNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,InExistingFunctionDefinitionPath: string): string;
	PopGraph(bSetupUndoRedo: boolean): RigVMGraph;
	OpenUndoBracket(InTitle: string): boolean;
	OnExternalVariableTypeChangedFromObjectPath(InVarName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean): void;
	OnExternalVariableTypeChanged(InVarName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean): void;
	OnExternalVariableRenamed(InOldVarName: string,InNewVarName: string,bSetupUndoRedo: boolean): void;
	OnExternalVariableRemoved(InVarName: string,bSetupUndoRedo: boolean): void;
	MakeVariableNodeFromBinding(InPinPath: string,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	MakeBindingsFromVariableNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	LocalizeFunctions(InFunctionDefinitions: RigVMLibraryNode[],bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): any;
	LocalizeFunction(InFunctionDefinition: RigVMLibraryNode,bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	IsReportingEnabled(): boolean;
	InsertArrayPin(InArrayPinPath: string,InIndex: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	ImportNodesFromText(InText: string,bSetupUndoRedo: boolean,bPrintPythonCommands: boolean): string[];
	GetTopLevelGraph(): RigVMGraph;
	GetPinDefaultValue(InPinPath: string): string;
	GetGraph(): RigVMGraph;
	GeneratePythonCommands(): string[];
	ExportSelectedNodesToText(): string;
	ExportNodesToText(InNodeNames: string[]): string;
	ExpandLibraryNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode[];
	EnableReporting(bEnabled: boolean): void;
	EjectNodeFromPin(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode;
	DuplicateArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	CollapseNodes(InNodeNames: string[],InCollapseNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMCollapseNode;
	CloseUndoBracket(): boolean;
	ClearNodeSelection(bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ClearArrayPin(InArrayPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ChangeExposedPinType(InPinName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo?: boolean,bSetupOrphanPins?: boolean,bPrintPythonCommand?: boolean): {bSetupUndoRedo: boolean, $: boolean};
	CanImportNodesFromText(InText: string): boolean;
	CancelUndoBracket(): boolean;
	BreakLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BreakAllLinks(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BindPinToVariable(InPinPath: string,InNewBoundVariablePath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	AddVariableNodeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddVariableNode(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddUnitNodeFromStructPath(InScriptStructPath: string,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddUnitNode(InScriptStruct: ScriptStruct,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddSelectNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMSelectNode;
	AddSelectNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMSelectNode;
	AddRerouteNodeOnPin(InPinPath: string,bAsInput: boolean,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLinkPath(InLinkPinPathRepresentation: string,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLink(InLink: RigVMLink,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddPrototypeNode(InNotation: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMPrototypeNode;
	AddParameterNodeFromObjectPath(InParameterName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddParameterNode(InParameterName: string,InCPPType: string,InCPPTypeObject: UObject,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddLocalVariableFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean): RigVMGraphVariableDescription;
	AddLocalVariable(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMGraphVariableDescription;
	AddLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	AddInjectedNodeFromStructPath(InPinPath: string,bAsInput: boolean,InScriptStructPath: string,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean): RigVMInjectionInfo;
	AddInjectedNode(InPinPath: string,bAsInput: boolean,InScriptStruct: ScriptStruct,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMInjectionInfo;
	AddIfNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMIfNode;
	AddIfNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMIfNode;
	AddFunctionToLibrary(InFunctionName: string,bMutable: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	AddFunctionReferenceNode(InFunctionDefinition: RigVMLibraryNode,InNodePosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMFunctionReferenceNode;
	AddFreeRerouteNode(bShowAsFullNode: boolean,InCPPType: string,InCPPTypeObjectPath: string,bIsConstant: boolean,InCustomWidgetName: string,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMRerouteNode;
	AddExposedPin(InPinName: string,InDirection: ERigVMPinDirection,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddEnumNode(InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMEnumNode;
	AddCommentNode(InCommentText: string,InPosition: Vector2D,InSize: Vector2D,InColor: LinearColor,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMCommentNode;
	AddBranchNode(InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMBranchNode;
	AddArrayPin(InArrayPinPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddArrayNodeFromObjectPath(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	AddArrayNode(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObject: UObject,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	static C(Other: UObject | any): RigVMController;
}

declare class ControlRigGraph extends EdGraph { 
	ModelNodePath: string;
	bIsFunctionDefinition: boolean;
	TemplateController: RigVMController;
	static Load(ResourceName: string): ControlRigGraph;
	static Find(Outer: UObject, ResourceName: string): ControlRigGraph;
	static GetDefaultObject(): ControlRigGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigGraph;
	static C(Other: UObject | any): ControlRigGraph;
}

declare class RigGraphDisplaySettings { 
	bShowNodeRunCounts: boolean;
	NodeRunLowerBound: number;
	NodeRunLimit: number;
	MinMicroSeconds: any;
	MaxMicroSeconds: any;
	TotalMicroSeconds: any;
	bAutoDetermineRange: boolean;
	LastMinMicroSeconds: any;
	LastMaxMicroSeconds: any;
	MinDurationColor: LinearColor;
	MaxDurationColor: LinearColor;
	clone() : RigGraphDisplaySettings;
	static C(Other: UObject | any): RigGraphDisplaySettings;
}

declare class RigVMParserASTSettings { 
	bFoldAssignments: boolean;
	bFoldLiterals: boolean;
	bFoldConstantBranches: boolean;
	LinksToSkip: RigVMLink[];
	clone() : RigVMParserASTSettings;
	static C(Other: UObject | any): RigVMParserASTSettings;
}

declare class RigVMCompileSettings { 
	SurpressInfoMessages: boolean;
	SurpressWarnings: boolean;
	SurpressErrors: boolean;
	EnablePinWatches: boolean;
	IsPreprocessorPhase: boolean;
	ASTSettings: RigVMParserASTSettings;
	SetupNodeInstructionIndex: boolean;
	clone() : RigVMCompileSettings;
	static C(Other: UObject | any): RigVMCompileSettings;
}

declare class ControlRigPythonSettings { 
	clone() : ControlRigPythonSettings;
	static C(Other: UObject | any): ControlRigPythonSettings;
}

declare class ControlRigPublicFunctionArg { 
	Name: string;
	CPPType: string;
	CPPTypeObjectPath: string;
	bIsArray: boolean;
	Direction: ERigVMPinDirection;
	clone() : ControlRigPublicFunctionArg;
	static C(Other: UObject | any): ControlRigPublicFunctionArg;
}

declare class ControlRigPublicFunctionData { 
	Name: string;
	DisplayName: string;
	Category: string;
	Keywords: string;
	ReturnValue: ControlRigPublicFunctionArg;
	Arguments: ControlRigPublicFunctionArg[];
	clone() : ControlRigPublicFunctionData;
	static C(Other: UObject | any): ControlRigPublicFunctionData;
}

declare class RigVMReferenceNodeData { 
	ReferenceNodePath: string;
	ReferencedFunctionPath: string;
	clone() : RigVMReferenceNodeData;
	static C(Other: UObject | any): RigVMReferenceNodeData;
}

declare class RigElement { 
	Name: string;
	index: number;
	clone() : RigElement;
	static C(Other: UObject | any): RigElement;
}

declare class RigBone extends RigElement { 
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	GlobalTransform: Transform;
	LocalTransform: Transform;
	Dependents: number[];
	Type: ERigBoneType;
	clone() : RigBone;
	static C(Other: UObject | any): RigBone;
}

declare class RigBoneHierarchy { 
	Bones: RigBone[];
	clone() : RigBoneHierarchy;
	static C(Other: UObject | any): RigBoneHierarchy;
}

declare type ERigSpaceType = 'Global' | 'Bone' | 'Control' | 'Space' | 'ERigSpaceType_MAX';
declare var ERigSpaceType : { Global:'Global',Bone:'Bone',Control:'Control',Space:'Space',ERigSpaceType_MAX:'ERigSpaceType_MAX', };
declare class RigSpace extends RigElement { 
	SpaceType: ERigSpaceType;
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	LocalTransform: Transform;
	clone() : RigSpace;
	static C(Other: UObject | any): RigSpace;
}

declare class RigSpaceHierarchy { 
	Spaces: RigSpace[];
	clone() : RigSpaceHierarchy;
	static C(Other: UObject | any): RigSpaceHierarchy;
}

declare class RigControl extends RigElement { 
	ControlType: ERigControlType;
	DisplayName: string;
	ParentName: string;
	ParentIndex: number;
	SpaceName: string;
	SpaceIndex: number;
	OffsetTransform: Transform;
	InitialValue: RigControlValue;
	Value: RigControlValue;
	PrimaryAxis: ERigControlAxis;
	bIsCurve: boolean;
	bAnimatable: boolean;
	bLimitTranslation: boolean;
	bLimitRotation: boolean;
	bLimitScale: boolean;
	bDrawLimits: boolean;
	MinimumValue: RigControlValue;
	MaximumValue: RigControlValue;
	bGizmoEnabled: boolean;
	bGizmoVisible: boolean;
	GizmoName: string;
	GizmoTransform: Transform;
	GizmoColor: LinearColor;
	Dependents: number[];
	bIsTransientControl: boolean;
	ControlEnum: Enum;
	clone() : RigControl;
	static C(Other: UObject | any): RigControl;
}

declare class RigControlHierarchy { 
	Controls: RigControl[];
	clone() : RigControlHierarchy;
	static C(Other: UObject | any): RigControlHierarchy;
}

declare class RigCurve extends RigElement { 
	Value: number;
	clone() : RigCurve;
	static C(Other: UObject | any): RigCurve;
}

declare class RigCurveContainer { 
	Curves: RigCurve[];
	clone() : RigCurveContainer;
	static C(Other: UObject | any): RigCurveContainer;
}

declare class RigHierarchyContainer { 
	BoneHierarchy: RigBoneHierarchy;
	SpaceHierarchy: RigSpaceHierarchy;
	ControlHierarchy: RigControlHierarchy;
	CurveContainer: RigCurveContainer;
	clone() : RigHierarchyContainer;
	static C(Other: UObject | any): RigHierarchyContainer;
}

declare class ControlRigValidationPass extends UObject { 
	static Load(ResourceName: string): ControlRigValidationPass;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidationPass;
	static GetDefaultObject(): ControlRigValidationPass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidationPass;
	static C(Other: UObject | any): ControlRigValidationPass;
}

declare class ControlRigValidator extends UObject { 
	Passes: ControlRigValidationPass[];
	static Load(ResourceName: string): ControlRigValidator;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidator;
	static GetDefaultObject(): ControlRigValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidator;
	static C(Other: UObject | any): ControlRigValidator;
}

declare class ControlRigBlueprint extends Blueprint { 
	FunctionLibraryEdGraph: ControlRigGraph;
	RigGraphDisplaySettings: RigGraphDisplaySettings;
	VMRuntimeSettings: RigVMRuntimeSettings;
	VMCompileSettings: RigVMCompileSettings;
	PythonLogSettings: ControlRigPythonSettings;
	Model: RigVMGraph;
	FunctionLibrary: RigVMFunctionLibrary;
	PublicFunctions: ControlRigPublicFunctionData[];
	FunctionReferenceNodeData: RigVMReferenceNodeData[];
	Controllers: any;
	TemplateModel: RigVMGraph;
	TemplateController: RigVMController;
	PinToOperandMap: any;
	GizmoLibrary: ControlRigShapeLibrary;
	ShapeLibraries: ControlRigShapeLibrary[];
	Statistics: RigVMStatistics;
	DrawContainer: ControlRigDrawContainer;
	Influences: RigInfluenceMapPerEvent;
	HierarchyContainer: RigHierarchyContainer;
	Hierarchy: RigHierarchy;
	bSupportsInversion: boolean;
	bSupportsControls: boolean;
	PreviewSkeletalMesh: SkeletalMesh;
	SourceHierarchyImport: UObject;
	SourceCurveImport: UObject;
	SupportedEventNames: string[];
	bExposesAnimatableControls: boolean;
	bAutoRecompileVM: boolean;
	bVMRecompilationRequired: boolean;
	bIsCompiling: boolean;
	VMRecompilationBracket: number;
	Validator: ControlRigValidator;
	DebugBoneRadius: number;
	static Load(ResourceName: string): ControlRigBlueprint;
	static Find(Outer: UObject, ResourceName: string): ControlRigBlueprint;
	static GetDefaultObject(): ControlRigBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigBlueprint;
	SuspendNotifications(bSuspendNotifs: boolean): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	RequestControlRigInit(): void;
	RequestAutoVMRecompilation(): void;
	RenameMemberVariable(InOldName: string,InNewName: string): boolean;
	RemoveMemberVariable(InName: string): boolean;
	RecompileVMIfRequired(): void;
	RecompileVM(): void;
	GetPreviewMesh(): SkeletalMesh;
	GetOrCreateController(InGraph: RigVMGraph): RigVMController;
	GetModel(InEdGraph: EdGraph): RigVMGraph;
	GetLocalFunctionLibrary(): RigVMFunctionLibrary;
	GetHierarchyController(): RigHierarchyController;
	static GetCurrentlyOpenRigBlueprints(): ControlRigBlueprint[];
	GetControlRigClass(): UnrealEngineClass;
	GetControllerByName(InGraphName: string): RigVMController;
	GetController(InGraph: RigVMGraph): RigVMController;
	static GetAvailableRigUnits(): Struct[];
	GetAllModels(): RigVMGraph[];
	GeneratePythonCommands(InNewBlueprintName: string): string[];
	CreateControlRig(): ControlRig;
	ChangeMemberVariableType(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): boolean;
	AddMemberVariable(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): string;
	static C(Other: UObject | any): ControlRigBlueprint;
	GetController(): RigVMController;
	GetHierarchy(): RigHierarchy;
	GetHierarchyController(): RigHierarchyController;
	GetModel(): RigVMGraph;
	GetPreviewMesh(): SkeletalMesh;
	RecompileVM(): void;
	RecompileVMIfRequired(): void;
	RequestAutoVMRecompilation(): void;
	RequestControlRigInit(): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	static GetController(InRigBlueprint: ControlRigBlueprint): RigVMController;
	static GetHierarchy(InRigBlueprint: ControlRigBlueprint): RigHierarchy;
	static GetHierarchyController(InRigBlueprint: ControlRigBlueprint): RigHierarchyController;
	static GetModel(InRigBlueprint: ControlRigBlueprint): RigVMGraph;
	static GetPreviewMesh(InRigBlueprint: ControlRigBlueprint): SkeletalMesh;
	static RecompileVM(InRigBlueprint: ControlRigBlueprint): void;
	static RecompileVMIfRequired(InRigBlueprint: ControlRigBlueprint): void;
	static RequestAutoVMRecompilation(InRigBlueprint: ControlRigBlueprint): void;
	static RequestControlRigInit(InRigBlueprint: ControlRigBlueprint): void;
	static SetPreviewMesh(InRigBlueprint: ControlRigBlueprint,PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
}

declare class DirectoryItem { 
	Name: string;
	bIsDirectory: boolean;
	clone() : DirectoryItem;
	static C(Other: UObject | any): DirectoryItem;
}

declare type EFileRead_JS = 'FILEREAD_None' | 'FILEREAD_NoFail' | 'FILEREAD_Silent' | 'FILEREAD_NotUsedDummy' | 'FILEREAD_AllowWrite' | 'FILEREAD_MAX';
declare var EFileRead_JS : { FILEREAD_None:'FILEREAD_None',FILEREAD_NoFail:'FILEREAD_NoFail',FILEREAD_Silent:'FILEREAD_Silent',FILEREAD_NotUsedDummy:'FILEREAD_NotUsedDummy',FILEREAD_AllowWrite:'FILEREAD_AllowWrite',FILEREAD_MAX:'FILEREAD_MAX', };
declare class JavascriptStubStruct { 
	clone() : JavascriptStubStruct;
	static C(Other: UObject | any): JavascriptStubStruct;
}

declare class JavascriptFunction { 
	clone() : JavascriptFunction;
	static C(Other: UObject | any): JavascriptFunction;
	CallJS(CustomStruct: JavascriptStubStruct): void;
	static CallJS(UFunction: JavascriptFunction,CustomStruct: JavascriptStubStruct): void;
}

declare class ReadStringFromFileHandle { 
	clone() : ReadStringFromFileHandle;
	static C(Other: UObject | any): ReadStringFromFileHandle;
}

declare type EJavascriptEncodingOptions = 'AutoDetect' | 'ForceAnsi' | 'ForceUnicode' | 'ForceUTF8' | 'ForceUTF8WithoutBOM' | 'EJavascriptEncodingOptions_MAX';
declare var EJavascriptEncodingOptions : { AutoDetect:'AutoDetect',ForceAnsi:'ForceAnsi',ForceUnicode:'ForceUnicode',ForceUTF8:'ForceUTF8',ForceUTF8WithoutBOM:'ForceUTF8WithoutBOM',EJavascriptEncodingOptions_MAX:'EJavascriptEncodingOptions_MAX', };
declare class AudioEngineSubsystem extends DynamicSubsystem { 
	static Load(ResourceName: string): AudioEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioEngineSubsystem;
	static GetDefaultObject(): AudioEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEngineSubsystem;
	static C(Other: UObject | any): AudioEngineSubsystem;
}

declare class GameInstanceSubsystem extends Subsystem { 
	static Load(ResourceName: string): GameInstanceSubsystem;
	static Find(Outer: UObject, ResourceName: string): GameInstanceSubsystem;
	static GetDefaultObject(): GameInstanceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstanceSubsystem;
	static C(Other: UObject | any): GameInstanceSubsystem;
}

declare class WorldSubsystem extends Subsystem { 
	static Load(ResourceName: string): WorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): WorldSubsystem;
	static GetDefaultObject(): WorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSubsystem;
	static C(Other: UObject | any): WorldSubsystem;
}

declare class CollisionProfileName { 
	Name: string;
	clone() : CollisionProfileName;
	static C(Other: UObject | any): CollisionProfileName;
}

declare type EPropertyAccessChangeNotifyMode = 'Default' | 'Never' | 'Always' | 'EPropertyAccessChangeNotifyMode_MAX';
declare var EPropertyAccessChangeNotifyMode : { Default:'Default',Never:'Never',Always:'Always',EPropertyAccessChangeNotifyMode_MAX:'EPropertyAccessChangeNotifyMode_MAX', };
declare class GenericStruct { 
	Data: number;
	clone() : GenericStruct;
	static C(Other: UObject | any): GenericStruct;
}

declare class UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UObject;
	static Find(Outer: UObject, ResourceName: string): UObject;
	static StaticClass: any;
	static GetClassObject(): Class;
	static GetDefaultObject(): UObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UObject;
	ExecuteUbergraph(EntryPoint: number): void;
	static C(Other: UObject | any): UObject;
	AddWhitelistedObject(): void;
	BroadcastAssetCreated(): void;
	ConditionalBeginDestroybyUObject(): boolean;
	GetUniqueID(): number;
	MarkPackageDirty(): boolean;
	ModifyObject(bAlwaysMarkDirty: boolean): void;
	OpenEditorForAsset(): boolean;
	PostEditChange(): void;
	CastToControlRigBlueprint(Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	SpawnActorFromObject(Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	CheckoutLoadedAsset(): boolean;
	ConsolidateAssets(AssetsToConsolidate: UObject[]): boolean;
	DeleteLoadedAsset(): boolean;
	DuplicateLoadedAsset(DestinationAssetPath: string): UObject;
	GetMetadataTag(Tag: string): string;
	GetMetadataTagValues(): any;
	GetPathNameForLoadedAsset(): string;
	RemoveMetadataTag(Tag: string): void;
	RenameLoadedAsset(DestinationAssetPath: string): boolean;
	SaveLoadedAsset(bOnlyIfIsDirty: boolean): boolean;
	SetMetadataTag(Tag: string,Value: string): void;
	RenameAsset(NewName: string): void;
	DestroyUObject(): void;
	ConvertRelativePathToFull(RelativePath: string): string;
	CreateEnum(Name: string,DisplayNames: string[],Flags: string[]): Enum;
	CreatePackage(PackageName: string): Package;
	Duplicate(Outer: UObject,Name: string): UObject;
	FindObjectWithOuter(ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	FindPackage(PackageName: string): Package;
	GetArchetypePathName(): string;
	GetDir(WhichDir: string): string;
	GetFields(bIncludeSuper: boolean): Field[];
	GetFileSize(Filename: string): number;
	GetName(): string;
	GetObjectsWithOuter(Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetOuter(): UObject;
	GetOutermost(): UObject;
	HasAnyFlags(Flags: number): boolean;
	ReadDirectory(Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	ReadFile(Filename: string): boolean;
	ReadStringFromFile(Filename: string,ReadFlags: EFileRead_JS): string;
	ReadStringFromFileAsync(Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	SetObjectFlags(Flags: number): void;
	WriteFile(Filename: string): boolean;
	WriteStringToFile(Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	GetDatasmithUserData(): DatasmithAssetUserData;
	GetDatasmithUserDataKeysAndValuesForValue(StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	GetDatasmithUserDataValueForKey(Key: string): string;
	RedirectVislog(DestinationOwner: UObject): void;
	GetAudioEngineSubsystem(Class: UnrealEngineClass): AudioEngineSubsystem;
	GetGameInstanceSubsystem(Class: UnrealEngineClass): GameInstanceSubsystem;
	GetLocalPlayerSubsystem(Class: UnrealEngineClass): LocalPlayerSubsystem;
	GetWorldSubsystem(Class: UnrealEngineClass): WorldSubsystem;
	MarkPropertyDirty(PropertyName: string): void;
	MarkPropertyDirtyFromRepIndex(RepIndex: number,PropertyName: string): void;
	Conv_ObjectToText(): string;
	Conv_ObjectToClass(Class: UnrealEngineClass): UnrealEngineClass;
	Conv_ObjectToSoftObjectReference(): UObject;
	Conv_SoftObjectReferenceToObject(): UObject;
	Conv_SoftObjectReferenceToString(): string;
	CreateCopyForUndoBuffer(): void;
	DoesImplementInterface(Interface: UnrealEngineClass): boolean;
	EqualEqual_SoftObjectReference(B: UObject): boolean;
	GetDisplayName(): string;
	GetEditorProperty(PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	GetObjectName(): string;
	GetOuterObject(): UObject;
	GetPathName(): string;
	GetPrimaryAssetIdFromObject(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftObjectReference(): PrimaryAssetId;
	GetSystemPath(): string;
	IsValid(): boolean;
	IsValidSoftObjectReference(): boolean;
	K2_ClearTimer(FunctionName: string): void;
	K2_GetTimerElapsedTime(FunctionName: string): number;
	K2_GetTimerRemainingTime(FunctionName: string): number;
	K2_IsTimerActive(FunctionName: string): boolean;
	K2_IsTimerPaused(FunctionName: string): boolean;
	K2_PauseTimer(FunctionName: string): void;
	K2_SetTimer(FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	K2_SetTimerForNextTick(FunctionName: string): TimerHandle;
	K2_TimerExists(FunctionName: string): boolean;
	K2_UnPauseTimer(FunctionName: string): void;
	LoadAsset_Blocking(): UObject;
	NotEqual_SoftObjectReference(B: UObject): boolean;
	SetBoolPropertyByName(PropertyName: string,Value: boolean): void;
	SetBytePropertyByName(PropertyName: string,Value: number): void;
	SetClassPropertyByName(PropertyName: string,Value: UnrealEngineClass): void;
	SetCollisionProfileNameProperty(PropertyName: string,Value: CollisionProfileName): void;
	SetColorPropertyByName(PropertyName: string,Value: Color): void;
	SetDoublePropertyByName(PropertyName: string,Value: any): void;
	SetEditorProperty(PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	SetFieldPathPropertyByName(PropertyName: string,Value: any): void;
	SetInt64PropertyByName(PropertyName: string,Value: any): void;
	SetInterfacePropertyByName(PropertyName: string,Value: any): void;
	SetIntPropertyByName(PropertyName: string,Value: number): void;
	SetLinearColorPropertyByName(PropertyName: string,Value: LinearColor): void;
	SetNamePropertyByName(PropertyName: string,Value: string): void;
	SetObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetRotatorPropertyByName(PropertyName: string,Value: Rotator): void;
	SetSoftClassPropertyByName(PropertyName: string,Value: Class): void;
	SetSoftObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetStringPropertyByName(PropertyName: string,Value: string): void;
	SetStructurePropertyByName(PropertyName: string,Value: GenericStruct): void;
	SetTextPropertyByName(PropertyName: string,Value: string): void;
	SetTransformPropertyByName(PropertyName: string,Value: Transform): void;
	SetVector3fPropertyByName(PropertyName: string,Value: Vector3f): void;
	SetVectorPropertyByName(PropertyName: string,Value: Vector): void;
	SnapshotObject(): void;
	TransactObject(): void;
	Conv_ObjectToString(): string;
	EqualEqual_ObjectObject(B: UObject): boolean;
	NotEqual_ObjectObject(B: UObject): boolean;
	SelectObject(B: UObject,bSelectA: boolean): UObject;
	SetArrayPropertyByName(PropertyName: string,Value: number[]): void;
	GetObjectClass(): UnrealEngineClass;
	K2_AcquireEditorObjectElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	SetSetPropertyByName(PropertyName: string,Value: any): void;
	SetMapPropertyByName(PropertyName: string,Value: any): void;
	GetBlueprintAsset(): Blueprint;
	static AddWhitelistedObject(InObject: UObject): void;
	static BroadcastAssetCreated(NewAsset: UObject): void;
	static ConditionalBeginDestroybyUObject(TargetObject: UObject): boolean;
	static GetUniqueID(InObject: UObject): number;
	static MarkPackageDirty(InObject: UObject): boolean;
	static ModifyObject(UObject: UObject,bAlwaysMarkDirty: boolean): void;
	static OpenEditorForAsset(Asset: UObject): boolean;
	static PostEditChange(InObject: UObject): void;
	static CastToControlRigBlueprint(UObject: UObject,Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	static SpawnActorFromObject(ObjectToUse: UObject,Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	static CheckoutLoadedAsset(AssetToCheckout: UObject): boolean;
	static ConsolidateAssets(AssetToConsolidateTo: UObject,AssetsToConsolidate: UObject[]): boolean;
	static DeleteLoadedAsset(AssetToDelete: UObject): boolean;
	static DuplicateLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): UObject;
	static GetMetadataTag(UObject: UObject,Tag: string): string;
	static GetMetadataTagValues(UObject: UObject): any;
	static GetPathNameForLoadedAsset(LoadedAsset: UObject): string;
	static RemoveMetadataTag(UObject: UObject,Tag: string): void;
	static RenameLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): boolean;
	static SaveLoadedAsset(AssetToSave: UObject,bOnlyIfIsDirty: boolean): boolean;
	static SetMetadataTag(UObject: UObject,Tag: string,Value: string): void;
	static RenameAsset(Asset: UObject,NewName: string): void;
	static DestroyUObject(UObject: UObject): void;
	static ConvertRelativePathToFull(UObject: UObject,RelativePath: string): string;
	static CreateEnum(Outer: UObject,Name: string,DisplayNames: string[],Flags: string[]): Enum;
	static CreatePackage(Outer: UObject,PackageName: string): Package;
	static Duplicate(UObject: UObject,Outer: UObject,Name: string): UObject;
	static FindObjectWithOuter(Outer: UObject,ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	static FindPackage(InOuter: UObject,PackageName: string): Package;
	static GetArchetypePathName(UObject: UObject): string;
	static GetDir(UObject: UObject,WhichDir: string): string;
	static GetFields(UObject: UObject,bIncludeSuper: boolean): Field[];
	static GetFileSize(UObject: UObject,Filename: string): number;
	static GetName(UObject: UObject): string;
	static GetObjectsWithOuter(Outer: UObject,Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetOuter(UObject: UObject): UObject;
	static GetOutermost(UObject: UObject): UObject;
	static HasAnyFlags(UObject: UObject,Flags: number): boolean;
	static ReadDirectory(UObject: UObject,Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	static ReadFile(UObject: UObject,Filename: string): boolean;
	static ReadStringFromFile(UObject: UObject,Filename: string,ReadFlags: EFileRead_JS): string;
	static ReadStringFromFileAsync(UObject: UObject,Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	static SetObjectFlags(Obj: UObject,Flags: number): void;
	static WriteFile(UObject: UObject,Filename: string): boolean;
	static WriteStringToFile(UObject: UObject,Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	static GetDatasmithUserData(UObject: UObject): DatasmithAssetUserData;
	static GetDatasmithUserDataKeysAndValuesForValue(UObject: UObject,StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	static GetDatasmithUserDataValueForKey(UObject: UObject,Key: string): string;
	static RedirectVislog(SourceOwner: UObject,DestinationOwner: UObject): void;
	static GetAudioEngineSubsystem(ContextObject: UObject,Class: UnrealEngineClass): AudioEngineSubsystem;
	static GetGameInstanceSubsystem(ContextObject: UObject,Class: UnrealEngineClass): GameInstanceSubsystem;
	static GetLocalPlayerSubsystem(ContextObject: UObject,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetWorldSubsystem(ContextObject: UObject,Class: UnrealEngineClass): WorldSubsystem;
	static MarkPropertyDirty(UObject: UObject,PropertyName: string): void;
	static MarkPropertyDirtyFromRepIndex(UObject: UObject,RepIndex: number,PropertyName: string): void;
	static Conv_ObjectToText(InObj: UObject): string;
	static Conv_ObjectToClass(UObject: UObject,Class: UnrealEngineClass): UnrealEngineClass;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): UObject;
	static Conv_SoftObjectReferenceToObject(softobject: UObject): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: UObject): string;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static EqualEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static GetDisplayName(UObject: UObject): string;
	static GetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	static GetObjectName(UObject: UObject): string;
	static GetOuterObject(UObject: UObject): UObject;
	static GetPathName(UObject: UObject): string;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: UObject): PrimaryAssetId;
	static GetSystemPath(UObject: UObject): string;
	static IsValid(UObject: UObject): boolean;
	static IsValidSoftObjectReference(SoftObjectReference: UObject): boolean;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	static K2_SetTimerForNextTick(UObject: UObject,FunctionName: string): TimerHandle;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static LoadAsset_Blocking(Asset: UObject): UObject;
	static NotEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetColorPropertyByName(UObject: UObject,PropertyName: string,Value: Color): void;
	static SetDoublePropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	static SetFieldPathPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetInt64PropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetInterfacePropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: Class): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetVector3fPropertyByName(UObject: UObject,PropertyName: string,Value: Vector3f): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static SnapshotObject(UObject: UObject): void;
	static TransactObject(UObject: UObject): void;
	static Conv_ObjectToString(InObj: UObject): string;
	static EqualEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static NotEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static SelectObject(A: UObject,B: UObject,bSelectA: boolean): UObject;
	static SetArrayPropertyByName(UObject: UObject,PropertyName: string,Value: number[]): void;
	static GetObjectClass(UObject: UObject): UnrealEngineClass;
	static K2_AcquireEditorObjectElementHandle(UObject: UObject,bAllowCreate: boolean): ScriptTypedElementHandle;
	static SetSetPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetMapPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
}

declare class GCObjectReferencer extends UObject { 
	static Load(ResourceName: string): GCObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): GCObjectReferencer;
	static GetDefaultObject(): GCObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GCObjectReferencer;
	static C(Other: UObject | any): GCObjectReferencer;
}

declare class TextBuffer extends UObject { 
	static Load(ResourceName: string): TextBuffer;
	static Find(Outer: UObject, ResourceName: string): TextBuffer;
	static GetDefaultObject(): TextBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBuffer;
	static C(Other: UObject | any): TextBuffer;
}

declare class DelegateFunction extends UFunction { 
	static Load(ResourceName: string): DelegateFunction;
	static Find(Outer: UObject, ResourceName: string): DelegateFunction;
	static GetDefaultObject(): DelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateFunction;
	static C(Other: UObject | any): DelegateFunction;
}

declare class SparseDelegateFunction extends DelegateFunction { 
	static Load(ResourceName: string): SparseDelegateFunction;
	static Find(Outer: UObject, ResourceName: string): SparseDelegateFunction;
	static GetDefaultObject(): SparseDelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SparseDelegateFunction;
	static C(Other: UObject | any): SparseDelegateFunction;
}

declare class DynamicClass extends Class { 
	static Load(ResourceName: string): DynamicClass;
	static Find(Outer: UObject, ResourceName: string): DynamicClass;
	static GetDefaultObject(): DynamicClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicClass;
	static C(Other: UObject | any): DynamicClass;
}

declare class LinkerPlaceholderClass extends Class { 
	static Load(ResourceName: string): LinkerPlaceholderClass;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderClass;
	static GetDefaultObject(): LinkerPlaceholderClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderClass;
	static C(Other: UObject | any): LinkerPlaceholderClass;
}

declare class LinkerPlaceholderExportObject extends UObject { 
	static Load(ResourceName: string): LinkerPlaceholderExportObject;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderExportObject;
	static GetDefaultObject(): LinkerPlaceholderExportObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderExportObject;
	static C(Other: UObject | any): LinkerPlaceholderExportObject;
}

declare class LinkerPlaceholderFunction extends UFunction { 
	static Load(ResourceName: string): LinkerPlaceholderFunction;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderFunction;
	static GetDefaultObject(): LinkerPlaceholderFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderFunction;
	static C(Other: UObject | any): LinkerPlaceholderFunction;
}

declare class MetaData extends UObject { 
	static Load(ResourceName: string): MetaData;
	static Find(Outer: UObject, ResourceName: string): MetaData;
	static GetDefaultObject(): MetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaData;
	static C(Other: UObject | any): MetaData;
}

declare class ObjectRedirector extends UObject { 
	static Load(ResourceName: string): ObjectRedirector;
	static Find(Outer: UObject, ResourceName: string): ObjectRedirector;
	static GetDefaultObject(): ObjectRedirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectRedirector;
	static C(Other: UObject | any): ObjectRedirector;
}

declare class Property extends Field { 
	static Load(ResourceName: string): Property;
	static Find(Outer: UObject, ResourceName: string): Property;
	static GetDefaultObject(): Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject | any): Property;
}

declare class EnumProperty extends Property { 
	static Load(ResourceName: string): EnumProperty;
	static Find(Outer: UObject, ResourceName: string): EnumProperty;
	static GetDefaultObject(): EnumProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumProperty;
	static C(Other: UObject | any): EnumProperty;
}

declare class ArrayProperty extends Property { 
	static Load(ResourceName: string): ArrayProperty;
	static Find(Outer: UObject, ResourceName: string): ArrayProperty;
	static GetDefaultObject(): ArrayProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrayProperty;
	static C(Other: UObject | any): ArrayProperty;
}

declare class ObjectPropertyBase extends Property { 
	static Load(ResourceName: string): ObjectPropertyBase;
	static Find(Outer: UObject, ResourceName: string): ObjectPropertyBase;
	static GetDefaultObject(): ObjectPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectPropertyBase;
	static C(Other: UObject | any): ObjectPropertyBase;
}

declare class BoolProperty extends Property { 
	static Load(ResourceName: string): BoolProperty;
	static Find(Outer: UObject, ResourceName: string): BoolProperty;
	static GetDefaultObject(): BoolProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolProperty;
	static C(Other: UObject | any): BoolProperty;
}

declare class NumericProperty extends Property { 
	static Load(ResourceName: string): NumericProperty;
	static Find(Outer: UObject, ResourceName: string): NumericProperty;
	static GetDefaultObject(): NumericProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NumericProperty;
	static C(Other: UObject | any): NumericProperty;
}

declare class ByteProperty extends NumericProperty { 
	static Load(ResourceName: string): ByteProperty;
	static Find(Outer: UObject, ResourceName: string): ByteProperty;
	static GetDefaultObject(): ByteProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ByteProperty;
	static C(Other: UObject | any): ByteProperty;
}

declare class ObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): ObjectProperty;
	static Find(Outer: UObject, ResourceName: string): ObjectProperty;
	static GetDefaultObject(): ObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectProperty;
	static C(Other: UObject | any): ObjectProperty;
}

declare class ClassProperty extends ObjectProperty { 
	static Load(ResourceName: string): ClassProperty;
	static Find(Outer: UObject, ResourceName: string): ClassProperty;
	static GetDefaultObject(): ClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassProperty;
	static C(Other: UObject | any): ClassProperty;
}

declare class DelegateProperty extends Property { 
	static Load(ResourceName: string): DelegateProperty;
	static Find(Outer: UObject, ResourceName: string): DelegateProperty;
	static GetDefaultObject(): DelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateProperty;
	static C(Other: UObject | any): DelegateProperty;
}

declare class DoubleProperty extends NumericProperty { 
	static Load(ResourceName: string): DoubleProperty;
	static Find(Outer: UObject, ResourceName: string): DoubleProperty;
	static GetDefaultObject(): DoubleProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleProperty;
	static C(Other: UObject | any): DoubleProperty;
}

declare class FloatProperty extends NumericProperty { 
	static Load(ResourceName: string): FloatProperty;
	static Find(Outer: UObject, ResourceName: string): FloatProperty;
	static GetDefaultObject(): FloatProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatProperty;
	static C(Other: UObject | any): FloatProperty;
}

declare class IntProperty extends NumericProperty { 
	static Load(ResourceName: string): IntProperty;
	static Find(Outer: UObject, ResourceName: string): IntProperty;
	static GetDefaultObject(): IntProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntProperty;
	static C(Other: UObject | any): IntProperty;
}

declare class Int8Property extends NumericProperty { 
	static Load(ResourceName: string): Int8Property;
	static Find(Outer: UObject, ResourceName: string): Int8Property;
	static GetDefaultObject(): Int8Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int8Property;
	static C(Other: UObject | any): Int8Property;
}

declare class Int16Property extends NumericProperty { 
	static Load(ResourceName: string): Int16Property;
	static Find(Outer: UObject, ResourceName: string): Int16Property;
	static GetDefaultObject(): Int16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int16Property;
	static C(Other: UObject | any): Int16Property;
}

declare class Int64Property extends NumericProperty { 
	static Load(ResourceName: string): Int64Property;
	static Find(Outer: UObject, ResourceName: string): Int64Property;
	static GetDefaultObject(): Int64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int64Property;
	static C(Other: UObject | any): Int64Property;
}

declare class InterfaceProperty extends Property { 
	static Load(ResourceName: string): InterfaceProperty;
	static Find(Outer: UObject, ResourceName: string): InterfaceProperty;
	static GetDefaultObject(): InterfaceProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterfaceProperty;
	static C(Other: UObject | any): InterfaceProperty;
}

declare class LazyObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): LazyObjectProperty;
	static Find(Outer: UObject, ResourceName: string): LazyObjectProperty;
	static GetDefaultObject(): LazyObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LazyObjectProperty;
	static C(Other: UObject | any): LazyObjectProperty;
}

declare class MapProperty extends Property { 
	static Load(ResourceName: string): MapProperty;
	static Find(Outer: UObject, ResourceName: string): MapProperty;
	static GetDefaultObject(): MapProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapProperty;
	static C(Other: UObject | any): MapProperty;
}

declare class MulticastDelegateProperty extends Property { 
	static Load(ResourceName: string): MulticastDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegateProperty;
	static GetDefaultObject(): MulticastDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegateProperty;
	static C(Other: UObject | any): MulticastDelegateProperty;
}

declare class MulticastInlineDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastInlineDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegateProperty;
	static GetDefaultObject(): MulticastInlineDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegateProperty;
	static C(Other: UObject | any): MulticastInlineDelegateProperty;
}

declare class MulticastSparseDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastSparseDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastSparseDelegateProperty;
	static GetDefaultObject(): MulticastSparseDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastSparseDelegateProperty;
	static C(Other: UObject | any): MulticastSparseDelegateProperty;
}

declare class NameProperty extends Property { 
	static Load(ResourceName: string): NameProperty;
	static Find(Outer: UObject, ResourceName: string): NameProperty;
	static GetDefaultObject(): NameProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NameProperty;
	static C(Other: UObject | any): NameProperty;
}

declare class SetProperty extends Property { 
	static Load(ResourceName: string): SetProperty;
	static Find(Outer: UObject, ResourceName: string): SetProperty;
	static GetDefaultObject(): SetProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SetProperty;
	static C(Other: UObject | any): SetProperty;
}

declare class SoftObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): SoftObjectProperty;
	static Find(Outer: UObject, ResourceName: string): SoftObjectProperty;
	static GetDefaultObject(): SoftObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftObjectProperty;
	static C(Other: UObject | any): SoftObjectProperty;
}

declare class SoftClassProperty extends SoftObjectProperty { 
	static Load(ResourceName: string): SoftClassProperty;
	static Find(Outer: UObject, ResourceName: string): SoftClassProperty;
	static GetDefaultObject(): SoftClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftClassProperty;
	static C(Other: UObject | any): SoftClassProperty;
}

declare class StrProperty extends Property { 
	static Load(ResourceName: string): StrProperty;
	static Find(Outer: UObject, ResourceName: string): StrProperty;
	static GetDefaultObject(): StrProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StrProperty;
	static C(Other: UObject | any): StrProperty;
}

declare class StructProperty extends Property { 
	static Load(ResourceName: string): StructProperty;
	static Find(Outer: UObject, ResourceName: string): StructProperty;
	static GetDefaultObject(): StructProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructProperty;
	static C(Other: UObject | any): StructProperty;
}

declare class UInt16Property extends NumericProperty { 
	static Load(ResourceName: string): UInt16Property;
	static Find(Outer: UObject, ResourceName: string): UInt16Property;
	static GetDefaultObject(): UInt16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt16Property;
	static C(Other: UObject | any): UInt16Property;
}

declare class UInt32Property extends NumericProperty { 
	static Load(ResourceName: string): UInt32Property;
	static Find(Outer: UObject, ResourceName: string): UInt32Property;
	static GetDefaultObject(): UInt32Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt32Property;
	static C(Other: UObject | any): UInt32Property;
}

declare class UInt64Property extends NumericProperty { 
	static Load(ResourceName: string): UInt64Property;
	static Find(Outer: UObject, ResourceName: string): UInt64Property;
	static GetDefaultObject(): UInt64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt64Property;
	static C(Other: UObject | any): UInt64Property;
}

declare class WeakObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): WeakObjectProperty;
	static Find(Outer: UObject, ResourceName: string): WeakObjectProperty;
	static GetDefaultObject(): WeakObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WeakObjectProperty;
	static C(Other: UObject | any): WeakObjectProperty;
}

declare class TextProperty extends Property { 
	static Load(ResourceName: string): TextProperty;
	static Find(Outer: UObject, ResourceName: string): TextProperty;
	static GetDefaultObject(): TextProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextProperty;
	static C(Other: UObject | any): TextProperty;
}

declare class PropertyWrapper extends UObject { 
	static Load(ResourceName: string): PropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): PropertyWrapper;
	static GetDefaultObject(): PropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyWrapper;
	static C(Other: UObject | any): PropertyWrapper;
}

declare class MulticastDelegatePropertyWrapper extends PropertyWrapper { 
	static Load(ResourceName: string): MulticastDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastDelegatePropertyWrapper;
}

declare class MulticastInlineDelegatePropertyWrapper extends MulticastDelegatePropertyWrapper { 
	static Load(ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastInlineDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastInlineDelegatePropertyWrapper;
}

declare class InputCoreTypes extends UObject { 
	static Load(ResourceName: string): InputCoreTypes;
	static Find(Outer: UObject, ResourceName: string): InputCoreTypes;
	static GetDefaultObject(): InputCoreTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputCoreTypes;
	static C(Other: UObject | any): InputCoreTypes;
}

declare class FontFaceInterface extends Interface { 
	static Load(ResourceName: string): FontFaceInterface;
	static Find(Outer: UObject, ResourceName: string): FontFaceInterface;
	static GetDefaultObject(): FontFaceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFaceInterface;
	static C(Other: UObject | any): FontFaceInterface;
}

declare class FontProviderInterface extends Interface { 
	static Load(ResourceName: string): FontProviderInterface;
	static Find(Outer: UObject, ResourceName: string): FontProviderInterface;
	static GetDefaultObject(): FontProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontProviderInterface;
	static C(Other: UObject | any): FontProviderInterface;
}

declare class SlateTypes extends UObject { 
	static Load(ResourceName: string): SlateTypes;
	static Find(Outer: UObject, ResourceName: string): SlateTypes;
	static GetDefaultObject(): SlateTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTypes;
	static C(Other: UObject | any): SlateTypes;
}

declare class SlateWidgetStyleContainerBase extends UObject { 
	static Load(ResourceName: string): SlateWidgetStyleContainerBase;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerBase;
	static GetDefaultObject(): SlateWidgetStyleContainerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerBase;
	static C(Other: UObject | any): SlateWidgetStyleContainerBase;
}

declare class SlateWidgetStyleAsset extends UObject { 
	CustomStyle: SlateWidgetStyleContainerBase;
	static Load(ResourceName: string): SlateWidgetStyleAsset;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleAsset;
	static GetDefaultObject(): SlateWidgetStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAsset;
	static C(Other: UObject | any): SlateWidgetStyleAsset;
}

declare class SlateWidgetStyleContainerInterface extends Interface { 
	static Load(ResourceName: string): SlateWidgetStyleContainerInterface;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerInterface;
	static GetDefaultObject(): SlateWidgetStyleContainerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerInterface;
	static C(Other: UObject | any): SlateWidgetStyleContainerInterface;
}

declare class StyleColorList { 
	StyleColors: LinearColor;
	clone() : StyleColorList;
	static C(Other: UObject | any): StyleColorList;
}

declare class SlateThemeManager extends UObject { 
	CurrentThemeId: Guid;
	ActiveColors: StyleColorList;
	static Load(ResourceName: string): SlateThemeManager;
	static Find(Outer: UObject, ResourceName: string): SlateThemeManager;
	static GetDefaultObject(): SlateThemeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateThemeManager;
	static C(Other: UObject | any): SlateThemeManager;
}

declare class SlateWidgetStyle { 
	clone() : SlateWidgetStyle;
	static C(Other: UObject | any): SlateWidgetStyle;
}

declare class SlateSound { 
	ResourceObject: UObject;
	clone() : SlateSound;
	static C(Other: UObject | any): SlateSound;
}

declare class ButtonStyle extends SlateWidgetStyle { 
	Normal: SlateBrush;
	Hovered: SlateBrush;
	Pressed: SlateBrush;
	Disabled: SlateBrush;
	NormalForeground: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	DisabledForeground: SlateColor;
	NormalPadding: Margin;
	PressedPadding: Margin;
	PressedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	PressedSound: string;
	HoveredSound: string;
	clone() : ButtonStyle;
	static C(Other: UObject | any): ButtonStyle;
}

declare class ButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ButtonStyle: ButtonStyle;
	static Load(ResourceName: string): ButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ButtonWidgetStyle;
	static GetDefaultObject(): ButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonWidgetStyle;
	static C(Other: UObject | any): ButtonWidgetStyle;
}

declare type ESlateCheckBoxType = 'CheckBox' | 'ToggleButton' | 'ESlateCheckBoxType_MAX';
declare var ESlateCheckBoxType : { CheckBox:'CheckBox',ToggleButton:'ToggleButton',ESlateCheckBoxType_MAX:'ESlateCheckBoxType_MAX', };
declare class CheckBoxStyle extends SlateWidgetStyle { 
	CheckBoxType: ESlateCheckBoxType;
	UncheckedImage: SlateBrush;
	UncheckedHoveredImage: SlateBrush;
	UncheckedPressedImage: SlateBrush;
	CheckedImage: SlateBrush;
	CheckedHoveredImage: SlateBrush;
	CheckedPressedImage: SlateBrush;
	UndeterminedImage: SlateBrush;
	UndeterminedHoveredImage: SlateBrush;
	UndeterminedPressedImage: SlateBrush;
	Padding: Margin;
	BackgroundImage: SlateBrush;
	BackgroundHoveredImage: SlateBrush;
	BackgroundPressedImage: SlateBrush;
	ForegroundColor: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	CheckedForeground: SlateColor;
	CheckedHoveredForeground: SlateColor;
	CheckedPressedForeground: SlateColor;
	UndeterminedForeground: SlateColor;
	BorderBackgroundColor: SlateColor;
	CheckedSlateSound: SlateSound;
	UncheckedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	CheckedSound: string;
	UncheckedSound: string;
	HoveredSound: string;
	clone() : CheckBoxStyle;
	static C(Other: UObject | any): CheckBoxStyle;
}

declare class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	CheckBoxStyle: CheckBoxStyle;
	static Load(ResourceName: string): CheckBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): CheckBoxWidgetStyle;
	static GetDefaultObject(): CheckBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxWidgetStyle;
	static C(Other: UObject | any): CheckBoxWidgetStyle;
}

declare class ComboButtonStyle extends SlateWidgetStyle { 
	ButtonStyle: ButtonStyle;
	DownArrowImage: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	MenuBorderBrush: SlateBrush;
	MenuBorderPadding: Margin;
	ContentPadding: Margin;
	DownArrowPadding: Margin;
	DownArrowAlign: EVerticalAlignment;
	clone() : ComboButtonStyle;
	static C(Other: UObject | any): ComboButtonStyle;
}

declare class ComboBoxStyle extends SlateWidgetStyle { 
	ComboButtonStyle: ComboButtonStyle;
	PressedSlateSound: SlateSound;
	SelectionChangeSlateSound: SlateSound;
	ContentPadding: Margin;
	MenuRowPadding: Margin;
	PressedSound: string;
	SelectionChangeSound: string;
	clone() : ComboBoxStyle;
	static C(Other: UObject | any): ComboBoxStyle;
}

declare class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboBoxStyle: ComboBoxStyle;
	static Load(ResourceName: string): ComboBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboBoxWidgetStyle;
	static GetDefaultObject(): ComboBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxWidgetStyle;
	static C(Other: UObject | any): ComboBoxWidgetStyle;
}

declare class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboButtonStyle: ComboButtonStyle;
	static Load(ResourceName: string): ComboButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboButtonWidgetStyle;
	static GetDefaultObject(): ComboButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboButtonWidgetStyle;
	static C(Other: UObject | any): ComboButtonWidgetStyle;
}

declare class FontOutlineSettings { 
	OutlineSize: number;
	bSeparateFillAlpha: boolean;
	bApplyOutlineToDropShadows: boolean;
	OutlineMaterial: UObject;
	OutlineColor: LinearColor;
	clone() : FontOutlineSettings;
	static C(Other: UObject | any): FontOutlineSettings;
}

declare class SlateFontInfo { 
	FontObject: UObject;
	FontMaterial: UObject;
	OutlineSettings: FontOutlineSettings;
	TypefaceFontName: string;
	Size: number;
	LetterSpacing: number;
	FontName: string;
	Hinting: EFontHinting;
	clone() : SlateFontInfo;
	static C(Other: UObject | any): SlateFontInfo;
}

declare class ScrollBarStyle extends SlateWidgetStyle { 
	HorizontalBackgroundImage: SlateBrush;
	VerticalBackgroundImage: SlateBrush;
	VerticalTopSlotImage: SlateBrush;
	HorizontalTopSlotImage: SlateBrush;
	VerticalBottomSlotImage: SlateBrush;
	HorizontalBottomSlotImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DraggedThumbImage: SlateBrush;
	Thickness: number;
	clone() : ScrollBarStyle;
	static C(Other: UObject | any): ScrollBarStyle;
}

declare class EditableTextBoxStyle extends SlateWidgetStyle { 
	BackgroundImageNormal: SlateBrush;
	BackgroundImageHovered: SlateBrush;
	BackgroundImageFocused: SlateBrush;
	BackgroundImageReadOnly: SlateBrush;
	Padding: Margin;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	BackgroundColor: SlateColor;
	ReadOnlyForegroundColor: SlateColor;
	FocusedForegroundColor: SlateColor;
	HScrollBarPadding: Margin;
	VScrollBarPadding: Margin;
	ScrollBarStyle: ScrollBarStyle;
	clone() : EditableTextBoxStyle;
	static C(Other: UObject | any): EditableTextBoxStyle;
}

declare class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextBoxStyle: EditableTextBoxStyle;
	static Load(ResourceName: string): EditableTextBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextBoxWidgetStyle;
	static GetDefaultObject(): EditableTextBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBoxWidgetStyle;
	static C(Other: UObject | any): EditableTextBoxWidgetStyle;
}

declare class EditableTextStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	BackgroundImageSelected: SlateBrush;
	BackgroundImageComposing: SlateBrush;
	CaretImage: SlateBrush;
	clone() : EditableTextStyle;
	static C(Other: UObject | any): EditableTextStyle;
}

declare class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextStyle: EditableTextStyle;
	static Load(ResourceName: string): EditableTextWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextWidgetStyle;
	static GetDefaultObject(): EditableTextWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextWidgetStyle;
	static C(Other: UObject | any): EditableTextWidgetStyle;
}

declare class ProgressBarStyle extends SlateWidgetStyle { 
	BackgroundImage: SlateBrush;
	FillImage: SlateBrush;
	MarqueeImage: SlateBrush;
	EnableFillAnimation: boolean;
	clone() : ProgressBarStyle;
	static C(Other: UObject | any): ProgressBarStyle;
}

declare class ProgressWidgetStyle extends SlateWidgetStyleContainerBase { 
	ProgressBarStyle: ProgressBarStyle;
	static Load(ResourceName: string): ProgressWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ProgressWidgetStyle;
	static GetDefaultObject(): ProgressWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressWidgetStyle;
	static C(Other: UObject | any): ProgressWidgetStyle;
}

declare class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBarStyle: ScrollBarStyle;
	static Load(ResourceName: string): ScrollBarWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBarWidgetStyle;
	static GetDefaultObject(): ScrollBarWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBarWidgetStyle;
	static C(Other: UObject | any): ScrollBarWidgetStyle;
}

declare class ScrollBoxStyle extends SlateWidgetStyle { 
	BarThickness: number;
	TopShadowBrush: SlateBrush;
	BottomShadowBrush: SlateBrush;
	LeftShadowBrush: SlateBrush;
	RightShadowBrush: SlateBrush;
	clone() : ScrollBoxStyle;
	static C(Other: UObject | any): ScrollBoxStyle;
}

declare class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBoxStyle: ScrollBoxStyle;
	static Load(ResourceName: string): ScrollBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBoxWidgetStyle;
	static GetDefaultObject(): ScrollBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxWidgetStyle;
	static C(Other: UObject | any): ScrollBoxWidgetStyle;
}

declare class SlateSettings extends UObject { 
	bExplicitCanvasChildZOrder: boolean;
	static Load(ResourceName: string): SlateSettings;
	static Find(Outer: UObject, ResourceName: string): SlateSettings;
	static GetDefaultObject(): SlateSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateSettings;
	static C(Other: UObject | any): SlateSettings;
}

declare class SpinBoxStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	ActiveBackgroundBrush: SlateBrush;
	HoveredBackgroundBrush: SlateBrush;
	ActiveFillBrush: SlateBrush;
	HoveredFillBrush: SlateBrush;
	InactiveFillBrush: SlateBrush;
	ArrowsImage: SlateBrush;
	ForegroundColor: SlateColor;
	TextPadding: Margin;
	InsetPadding: Margin;
	clone() : SpinBoxStyle;
	static C(Other: UObject | any): SpinBoxStyle;
}

declare class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	SpinBoxStyle: SpinBoxStyle;
	static Load(ResourceName: string): SpinBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): SpinBoxWidgetStyle;
	static GetDefaultObject(): SpinBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBoxWidgetStyle;
	static C(Other: UObject | any): SpinBoxWidgetStyle;
}

declare type ETextTransformPolicy = 'None' | 'ToLower' | 'ToUpper' | 'ETextTransformPolicy_MAX';
declare var ETextTransformPolicy : { None:'None',ToLower:'ToLower',ToUpper:'ToUpper',ETextTransformPolicy_MAX:'ETextTransformPolicy_MAX', };
declare type ETextOverflowPolicy = 'Clip' | 'Ellipsis' | 'ETextOverflowPolicy_MAX';
declare var ETextOverflowPolicy : { Clip:'Clip',Ellipsis:'Ellipsis',ETextOverflowPolicy_MAX:'ETextOverflowPolicy_MAX', };
declare class TextBlockStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	SelectedBackgroundColor: SlateColor;
	HighlightColor: SlateColor;
	HighlightShape: SlateBrush;
	StrikeBrush: SlateBrush;
	UnderlineBrush: SlateBrush;
	TransformPolicy: ETextTransformPolicy;
	OverflowPolicy: ETextOverflowPolicy;
	clone() : TextBlockStyle;
	static C(Other: UObject | any): TextBlockStyle;
}

declare class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase { 
	TextBlockStyle: TextBlockStyle;
	static Load(ResourceName: string): TextBlockWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): TextBlockWidgetStyle;
	static GetDefaultObject(): TextBlockWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlockWidgetStyle;
	static C(Other: UObject | any): TextBlockWidgetStyle;
}

declare class ToolMenuBase extends UObject { 
	static Load(ResourceName: string): ToolMenuBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuBase;
	static GetDefaultObject(): ToolMenuBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuBase;
	static C(Other: UObject | any): ToolMenuBase;
}

declare type EColorVisionDeficiency = 'NormalVision' | 'Deuteranope' | 'Protanope' | 'Tritanope' | 'EColorVisionDeficiency_MAX';
declare var EColorVisionDeficiency : { NormalVision:'NormalVision',Deuteranope:'Deuteranope',Protanope:'Protanope',Tritanope:'Tritanope',EColorVisionDeficiency_MAX:'EColorVisionDeficiency_MAX', };
declare type ELogTimes = 'None' | 'UTC' | 'SinceGStartTime' | 'Local' | 'ELogTimes_MAX';
declare var ELogTimes : { None:'None',UTC:'UTC',SinceGStartTime:'SinceGStartTime',Local:'Local',ELogTimes_MAX:'ELogTimes_MAX', };
declare type ELogCategoryColorizationMode = 'None' | 'ColorizeWholeLine' | 'ColorizeCategoryOnly' | 'ColorizeCategoryAsBadge' | 'ELogCategoryColorizationMode_MAX';
declare var ELogCategoryColorizationMode : { None:'None',ColorizeWholeLine:'ColorizeWholeLine',ColorizeCategoryOnly:'ColorizeCategoryOnly',ColorizeCategoryAsBadge:'ColorizeCategoryAsBadge',ELogCategoryColorizationMode_MAX:'ELogCategoryColorizationMode_MAX', };
declare type EAssetEditorOpenLocation = 'Default' | 'NewWindow' | 'MainWindow' | 'ContentBrowser' | 'LastDockedWindowOrNewWindow' | 'LastDockedWindowOrMainWindow' | 'LastDockedWindowOrContentBrowser' | 'EAssetEditorOpenLocation_MAX';
declare var EAssetEditorOpenLocation : { Default:'Default',NewWindow:'NewWindow',MainWindow:'MainWindow',ContentBrowser:'ContentBrowser',LastDockedWindowOrNewWindow:'LastDockedWindowOrNewWindow',LastDockedWindowOrMainWindow:'LastDockedWindowOrMainWindow',LastDockedWindowOrContentBrowser:'LastDockedWindowOrContentBrowser',EAssetEditorOpenLocation_MAX:'EAssetEditorOpenLocation_MAX', };
declare class EditorStyleSettings extends UObject { 
	bEnableHighDPIAwareness: boolean;
	bEnableUserEditorLayoutManagement: boolean;
	ColorVisionDeficiencyPreviewType: EColorVisionDeficiency;
	ColorVisionDeficiencySeverity: number;
	bColorVisionDeficiencyCorrection: boolean;
	bColorVisionDeficiencyCorrectionPreviewWithDeficiency: boolean;
	SelectionColor: LinearColor;
	bEnableEditorWindowBackgroundColor: boolean;
	EditorWindowBackgroundColor: LinearColor;
	bUseSmallToolBarIcons: boolean;
	bUseGrid: boolean;
	RegularColor: LinearColor;
	RuleColor: LinearColor;
	CenterColor: LinearColor;
	GridSnapSize: any;
	GraphBackgroundBrush: SlateBrush;
	bShowFriendlyNames: boolean;
	bShowNativeComponentNames: boolean;
	bExpandConfigurationMenus: boolean;
	bShowProjectMenus: boolean;
	bShowLaunchMenus: boolean;
	bShowAllAdvancedDetails: boolean;
	bShowHiddenPropertiesWhilePlaying: boolean;
	LogFontSize: number;
	LogTimestampMode: ELogTimes;
	bPromoteOutputLogWarningsDuringPIE: boolean;
	CategoryColorizationMode: ELogCategoryColorizationMode;
	bCycleToOutputLogDrawer: boolean;
	AssetEditorOpenLocation: EAssetEditorOpenLocation;
	bEnableColorizedEditorTabs: boolean;
	static Load(ResourceName: string): EditorStyleSettings;
	static Find(Outer: UObject, ResourceName: string): EditorStyleSettings;
	static GetDefaultObject(): EditorStyleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorStyleSettings;
	static C(Other: UObject | any): EditorStyleSettings;
}

declare class DeveloperSettings extends UObject { 
	static Load(ResourceName: string): DeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettings;
	static GetDefaultObject(): DeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettings;
	static C(Other: UObject | any): DeveloperSettings;
}

declare class DeveloperSettingsBackedByCVars extends DeveloperSettings { 
	static Load(ResourceName: string): DeveloperSettingsBackedByCVars;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettingsBackedByCVars;
	static GetDefaultObject(): DeveloperSettingsBackedByCVars;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettingsBackedByCVars;
	static C(Other: UObject | any): DeveloperSettingsBackedByCVars;
}

declare class PlatformSettings extends UObject { 
	static Load(ResourceName: string): PlatformSettings;
	static Find(Outer: UObject, ResourceName: string): PlatformSettings;
	static GetDefaultObject(): PlatformSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettings;
	static C(Other: UObject | any): PlatformSettings;
}

declare class PlatformSettingsManager extends UObject { 
	SettingsMap: any;
	static Load(ResourceName: string): PlatformSettingsManager;
	static Find(Outer: UObject, ResourceName: string): PlatformSettingsManager;
	static GetDefaultObject(): PlatformSettingsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettingsManager;
	static C(Other: UObject | any): PlatformSettingsManager;
}

declare class BlueprintFunctionLibrary extends UObject { 
	static Load(ResourceName: string): BlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionLibrary;
	static GetDefaultObject(): BlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibrary;
	static C(Other: UObject | any): BlueprintFunctionLibrary;
}

declare class ImageWriteBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ImageWriteBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ImageWriteBlueprintLibrary;
	static GetDefaultObject(): ImageWriteBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageWriteBlueprintLibrary;
	static ExportToDisk(Texture: Texture,Filename: string,Options: ImageWriteOptions): void;
	static C(Other: UObject | any): ImageWriteBlueprintLibrary;
}

declare class InputBehavior extends UObject { 
	static Load(ResourceName: string): InputBehavior;
	static Find(Outer: UObject, ResourceName: string): InputBehavior;
	static GetDefaultObject(): InputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehavior;
	static C(Other: UObject | any): InputBehavior;
}

declare class AnyButtonInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): AnyButtonInputBehavior;
	static Find(Outer: UObject, ResourceName: string): AnyButtonInputBehavior;
	static GetDefaultObject(): AnyButtonInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnyButtonInputBehavior;
	static C(Other: UObject | any): AnyButtonInputBehavior;
}

declare class AssetBackedTarget extends Interface { 
	static Load(ResourceName: string): AssetBackedTarget;
	static Find(Outer: UObject, ResourceName: string): AssetBackedTarget;
	static GetDefaultObject(): AssetBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBackedTarget;
	static C(Other: UObject | any): AssetBackedTarget;
}

declare class InteractiveGizmoBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoBuilder;
	static GetDefaultObject(): InteractiveGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoBuilder;
	static C(Other: UObject | any): InteractiveGizmoBuilder;
}

declare class AxisAngleGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): AxisAngleGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): AxisAngleGizmoBuilder;
	static GetDefaultObject(): AxisAngleGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisAngleGizmoBuilder;
	static C(Other: UObject | any): AxisAngleGizmoBuilder;
}

declare class BehaviorInfo { 
	Behavior: InputBehavior;
	clone() : BehaviorInfo;
	static C(Other: UObject | any): BehaviorInfo;
}

declare class InputBehaviorSet extends UObject { 
	Behaviors: BehaviorInfo[];
	static Load(ResourceName: string): InputBehaviorSet;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSet;
	static GetDefaultObject(): InputBehaviorSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSet;
	static C(Other: UObject | any): InputBehaviorSet;
}

declare class InteractiveGizmo extends UObject { 
	InputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InteractiveGizmo;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmo;
	static GetDefaultObject(): InteractiveGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmo;
	static C(Other: UObject | any): InteractiveGizmo;
}

declare class ClickDragInputBehavior extends AnyButtonInputBehavior { 
	bUpdateModifiersDuringDrag: boolean;
	static Load(ResourceName: string): ClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ClickDragInputBehavior;
	static GetDefaultObject(): ClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragInputBehavior;
	static C(Other: UObject | any): ClickDragInputBehavior;
}

declare class AxisAngleGizmo extends InteractiveGizmo { 
	AxisSource: any;
	AngleSource: any;
	HitTarget: any;
	StateTarget: any;
	MouseBehavior: ClickDragInputBehavior;
	bInInteraction: boolean;
	RotationOrigin: Vector;
	RotationAxis: Vector;
	RotationPlaneX: Vector;
	RotationPlaneY: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartAngle: number;
	InteractionCurAngle: number;
	static Load(ResourceName: string): AxisAngleGizmo;
	static Find(Outer: UObject, ResourceName: string): AxisAngleGizmo;
	static GetDefaultObject(): AxisAngleGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisAngleGizmo;
	static C(Other: UObject | any): AxisAngleGizmo;
}

declare class AxisPositionGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): AxisPositionGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): AxisPositionGizmoBuilder;
	static GetDefaultObject(): AxisPositionGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisPositionGizmoBuilder;
	static C(Other: UObject | any): AxisPositionGizmoBuilder;
}

declare class GizmoViewContext extends UObject { 
	static Load(ResourceName: string): GizmoViewContext;
	static Find(Outer: UObject, ResourceName: string): GizmoViewContext;
	static GetDefaultObject(): GizmoViewContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoViewContext;
	static C(Other: UObject | any): GizmoViewContext;
}

declare class AxisPositionGizmo extends InteractiveGizmo { 
	AxisSource: any;
	ParameterSource: any;
	GizmoViewContext: GizmoViewContext;
	HitTarget: any;
	StateTarget: any;
	MouseBehavior: ClickDragInputBehavior;
	bEnableSignedAxis: boolean;
	bInInteraction: boolean;
	InteractionOrigin: Vector;
	InteractionAxis: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartParameter: number;
	InteractionCurParameter: number;
	ParameterSign: number;
	static Load(ResourceName: string): AxisPositionGizmo;
	static Find(Outer: UObject, ResourceName: string): AxisPositionGizmo;
	static GetDefaultObject(): AxisPositionGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisPositionGizmo;
	static C(Other: UObject | any): AxisPositionGizmo;
}

declare class GizmoConstantAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	static Load(ResourceName: string): GizmoConstantAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantAxisSource;
	static GetDefaultObject(): GizmoConstantAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantAxisSource;
	static C(Other: UObject | any): GizmoConstantAxisSource;
}

declare class GizmoConstantFrameAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	TangentX: Vector;
	TangentY: Vector;
	static Load(ResourceName: string): GizmoConstantFrameAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantFrameAxisSource;
	static GetDefaultObject(): GizmoConstantFrameAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantFrameAxisSource;
	static C(Other: UObject | any): GizmoConstantFrameAxisSource;
}

declare class GizmoWorldAxisSource extends UObject { 
	Origin: Vector;
	AxisIndex: number;
	static Load(ResourceName: string): GizmoWorldAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoWorldAxisSource;
	static GetDefaultObject(): GizmoWorldAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoWorldAxisSource;
	static C(Other: UObject | any): GizmoWorldAxisSource;
}

declare class GizmoComponentAxisSource extends UObject { 
	Component: SceneComponent;
	AxisIndex: number;
	bLocalAxes: boolean;
	static Load(ResourceName: string): GizmoComponentAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentAxisSource;
	static GetDefaultObject(): GizmoComponentAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentAxisSource;
	static C(Other: UObject | any): GizmoComponentAxisSource;
}

declare class InteractiveToolPropertySet extends UObject { 
	CachedPropertiesMap: any;
	bIsPropertySetEnabled: boolean;
	static Load(ResourceName: string): InteractiveToolPropertySet;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolPropertySet;
	static GetDefaultObject(): InteractiveToolPropertySet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolPropertySet;
	static C(Other: UObject | any): InteractiveToolPropertySet;
}

declare class BrushBaseProperties extends InteractiveToolPropertySet { 
	BrushSize: number;
	bSpecifyRadius: boolean;
	BrushRadius: number;
	BrushStrength: number;
	BrushFalloffAmount: number;
	bShowStrength: boolean;
	bShowFalloff: boolean;
	static Load(ResourceName: string): BrushBaseProperties;
	static Find(Outer: UObject, ResourceName: string): BrushBaseProperties;
	static GetDefaultObject(): BrushBaseProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBaseProperties;
	static C(Other: UObject | any): BrushBaseProperties;
}

declare class InteractiveTool extends UObject { 
	InputBehaviors: InputBehaviorSet;
	ToolPropertyObjects: UObject[];
	static Load(ResourceName: string): InteractiveTool;
	static Find(Outer: UObject, ResourceName: string): InteractiveTool;
	static GetDefaultObject(): InteractiveTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveTool;
	static C(Other: UObject | any): InteractiveTool;
}

declare class ToolTarget extends UObject { 
	static Load(ResourceName: string): ToolTarget;
	static Find(Outer: UObject, ResourceName: string): ToolTarget;
	static GetDefaultObject(): ToolTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTarget;
	static C(Other: UObject | any): ToolTarget;
}

declare class SingleSelectionTool extends InteractiveTool { 
	Target: ToolTarget;
	static Load(ResourceName: string): SingleSelectionTool;
	static Find(Outer: UObject, ResourceName: string): SingleSelectionTool;
	static GetDefaultObject(): SingleSelectionTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleSelectionTool;
	static C(Other: UObject | any): SingleSelectionTool;
}

declare class MeshSurfacePointTool extends SingleSelectionTool { 
	static Load(ResourceName: string): MeshSurfacePointTool;
	static Find(Outer: UObject, ResourceName: string): MeshSurfacePointTool;
	static GetDefaultObject(): MeshSurfacePointTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSurfacePointTool;
	static C(Other: UObject | any): MeshSurfacePointTool;
}

declare class BrushStampData { 
	clone() : BrushStampData;
	static C(Other: UObject | any): BrushStampData;
}

declare class BrushStampIndicator extends InteractiveGizmo { 
	bVisible: boolean;
	BrushRadius: number;
	BrushFalloff: number;
	BrushPosition: Vector;
	BrushNormal: Vector;
	bDrawIndicatorLines: boolean;
	bDrawRadiusCircle: boolean;
	SampleStepCount: number;
	LineColor: LinearColor;
	LineThickness: number;
	bDepthTested: boolean;
	bDrawSecondaryLines: boolean;
	SecondaryLineThickness: number;
	SecondaryLineColor: LinearColor;
	AttachedComponent: PrimitiveComponent;
	static Load(ResourceName: string): BrushStampIndicator;
	static Find(Outer: UObject, ResourceName: string): BrushStampIndicator;
	static GetDefaultObject(): BrushStampIndicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushStampIndicator;
	static C(Other: UObject | any): BrushStampIndicator;
}

declare class BaseBrushTool extends MeshSurfacePointTool { 
	BrushProperties: BrushBaseProperties;
	bInBrushStroke: boolean;
	WorldToLocalScale: number;
	LastBrushStamp: BrushStampData;
	PropertyClass: Class;
	BrushStampIndicator: BrushStampIndicator;
	static Load(ResourceName: string): BaseBrushTool;
	static Find(Outer: UObject, ResourceName: string): BaseBrushTool;
	static GetDefaultObject(): BaseBrushTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseBrushTool;
	static C(Other: UObject | any): BaseBrushTool;
}

declare class BrushStampIndicatorBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): BrushStampIndicatorBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushStampIndicatorBuilder;
	static GetDefaultObject(): BrushStampIndicatorBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushStampIndicatorBuilder;
	static C(Other: UObject | any): BrushStampIndicatorBuilder;
}

declare class LocalClickDragInputBehavior extends ClickDragInputBehavior { 
	static Load(ResourceName: string): LocalClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalClickDragInputBehavior;
	static GetDefaultObject(): LocalClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalClickDragInputBehavior;
	static C(Other: UObject | any): LocalClickDragInputBehavior;
}

declare class InteractiveToolBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveToolBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolBuilder;
	static GetDefaultObject(): InteractiveToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolBuilder;
	static C(Other: UObject | any): InteractiveToolBuilder;
}

declare class ClickDragToolBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): ClickDragToolBuilder;
	static Find(Outer: UObject, ResourceName: string): ClickDragToolBuilder;
	static GetDefaultObject(): ClickDragToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragToolBuilder;
	static C(Other: UObject | any): ClickDragToolBuilder;
}

declare class ClickDragTool extends InteractiveTool { 
	static Load(ResourceName: string): ClickDragTool;
	static Find(Outer: UObject, ResourceName: string): ClickDragTool;
	static GetDefaultObject(): ClickDragTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragTool;
	static C(Other: UObject | any): ClickDragTool;
}

declare class InternalToolFrameworkActor extends Actor { 
	bIsSelectableInEditor: boolean;
	static GetDefaultObject(): InternalToolFrameworkActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternalToolFrameworkActor;
	static C(Other: UObject | any): InternalToolFrameworkActor;
}

declare class GizmoActor extends InternalToolFrameworkActor { 
	static GetDefaultObject(): GizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoActor;
	static C(Other: UObject | any): GizmoActor;
}

declare class CombinedTransformGizmoActor extends GizmoActor { 
	TranslateX: PrimitiveComponent;
	TranslateY: PrimitiveComponent;
	TranslateZ: PrimitiveComponent;
	TranslateYZ: PrimitiveComponent;
	TranslateXZ: PrimitiveComponent;
	TranslateXY: PrimitiveComponent;
	RotateX: PrimitiveComponent;
	RotateY: PrimitiveComponent;
	RotateZ: PrimitiveComponent;
	UniformScale: PrimitiveComponent;
	AxisScaleX: PrimitiveComponent;
	AxisScaleY: PrimitiveComponent;
	AxisScaleZ: PrimitiveComponent;
	PlaneScaleYZ: PrimitiveComponent;
	PlaneScaleXZ: PrimitiveComponent;
	PlaneScaleXY: PrimitiveComponent;
	static GetDefaultObject(): CombinedTransformGizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoActor;
	static C(Other: UObject | any): CombinedTransformGizmoActor;
}

declare class CombinedTransformGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): CombinedTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmoBuilder;
	static GetDefaultObject(): CombinedTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoBuilder;
	static C(Other: UObject | any): CombinedTransformGizmoBuilder;
}

declare class TransformProxy extends UObject { 
	bRotatePerObject: boolean;
	bSetPivotMode: boolean;
	SharedTransform: Transform;
	InitialSharedTransform: Transform;
	static Load(ResourceName: string): TransformProxy;
	static Find(Outer: UObject, ResourceName: string): TransformProxy;
	static GetDefaultObject(): TransformProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformProxy;
	static C(Other: UObject | any): TransformProxy;
}

declare type EToolContextCoordinateSystem = 'World' | 'Local' | 'EToolContextCoordinateSystem_MAX';
declare var EToolContextCoordinateSystem : { World:'World',Local:'Local',EToolContextCoordinateSystem_MAX:'EToolContextCoordinateSystem_MAX', };
declare class GizmoTransformChangeStateTarget extends UObject { 
	TransactionManager: any;
	static Load(ResourceName: string): GizmoTransformChangeStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformChangeStateTarget;
	static GetDefaultObject(): GizmoTransformChangeStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformChangeStateTarget;
	static C(Other: UObject | any): GizmoTransformChangeStateTarget;
}

declare class CombinedTransformGizmo extends InteractiveGizmo { 
	ActiveTarget: TransformProxy;
	bSnapToWorldGrid: boolean;
	bGridSizeIsExplicit: boolean;
	ExplicitGridSize: Vector;
	bRotationGridSizeIsExplicit: boolean;
	ExplicitRotationGridSize: Rotator;
	bSnapToWorldRotGrid: boolean;
	bUseContextCoordinateSystem: boolean;
	CurrentCoordinateSystem: EToolContextCoordinateSystem;
	ActiveComponents: PrimitiveComponent[];
	NonuniformScaleComponents: PrimitiveComponent[];
	ActiveGizmos: InteractiveGizmo[];
	CameraAxisSource: GizmoConstantFrameAxisSource;
	AxisXSource: GizmoComponentAxisSource;
	AxisYSource: GizmoComponentAxisSource;
	AxisZSource: GizmoComponentAxisSource;
	UnitAxisXSource: GizmoComponentAxisSource;
	UnitAxisYSource: GizmoComponentAxisSource;
	UnitAxisZSource: GizmoComponentAxisSource;
	StateTarget: GizmoTransformChangeStateTarget;
	static Load(ResourceName: string): CombinedTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmo;
	static GetDefaultObject(): CombinedTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmo;
	static C(Other: UObject | any): CombinedTransformGizmo;
}

declare class ContextObjectStore extends UObject { 
	ContextObjects: UObject[];
	static Load(ResourceName: string): ContextObjectStore;
	static Find(Outer: UObject, ResourceName: string): ContextObjectStore;
	static GetDefaultObject(): ContextObjectStore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContextObjectStore;
	static C(Other: UObject | any): ContextObjectStore;
}

declare class GizmoBaseComponent extends PrimitiveComponent { 
	Color: LinearColor;
	HoverSizeMultiplier: number;
	PixelHitDistanceThreshold: number;
	GizmoViewContext: GizmoViewContext;
	static Load(ResourceName: string): GizmoBaseComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseComponent;
	static GetDefaultObject(): GizmoBaseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseComponent;
	UpdateWorldLocalState(bWorldIn: boolean): void;
	UpdateHoverState(bHoveringIn: boolean): void;
	static C(Other: UObject | any): GizmoBaseComponent;
}

declare class GizmoArrowComponent extends GizmoBaseComponent { 
	Direction: Vector;
	Gap: number;
	Length: number;
	Thickness: number;
	static Load(ResourceName: string): GizmoArrowComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoArrowComponent;
	static GetDefaultObject(): GizmoArrowComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoArrowComponent;
	static C(Other: UObject | any): GizmoArrowComponent;
}

declare class GizmoBoxComponent extends GizmoBaseComponent { 
	Origin: Vector;
	Rotation: Quat;
	Dimensions: Vector;
	LineThickness: number;
	bRemoveHiddenLines: boolean;
	bEnableAxisFlip: boolean;
	static Load(ResourceName: string): GizmoBoxComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoBoxComponent;
	static GetDefaultObject(): GizmoBoxComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBoxComponent;
	static C(Other: UObject | any): GizmoBoxComponent;
}

declare class GizmoCircleComponent extends GizmoBaseComponent { 
	Normal: Vector;
	Radius: number;
	Thickness: number;
	NumSides: number;
	bViewAligned: boolean;
	bDrawFullCircle: boolean;
	bOnlyAllowFrontFacingHits: boolean;
	static Load(ResourceName: string): GizmoCircleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoCircleComponent;
	static GetDefaultObject(): GizmoCircleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoCircleComponent;
	static C(Other: UObject | any): GizmoCircleComponent;
}

declare class GizmoTransformSource extends Interface { 
	static Load(ResourceName: string): GizmoTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformSource;
	static GetDefaultObject(): GizmoTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformSource;
	SetTransform(NewTransform: Transform): void;
	GetTransform(): Transform;
	static C(Other: UObject | any): GizmoTransformSource;
}

declare class GizmoAxisSource extends Interface { 
	static Load(ResourceName: string): GizmoAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisSource;
	static GetDefaultObject(): GizmoAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisSource;
	HasTangentVectors(): boolean;
	GetTangentVectors(TangentXOut?: Vector,TangentYOut?: Vector): {TangentXOut: Vector, TangentYOut: Vector};
	GetOrigin(): Vector;
	GetDirection(): Vector;
	static C(Other: UObject | any): GizmoAxisSource;
}

declare class GizmoClickTarget extends Interface { 
	static Load(ResourceName: string): GizmoClickTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoClickTarget;
	static GetDefaultObject(): GizmoClickTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoClickTarget;
	UpdateInteractingState(bInteracting: boolean): void;
	UpdateHoverState(bHovering: boolean): void;
	static C(Other: UObject | any): GizmoClickTarget;
}

declare class GizmoStateTarget extends Interface { 
	static Load(ResourceName: string): GizmoStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoStateTarget;
	static GetDefaultObject(): GizmoStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoStateTarget;
	EndUpdate(): void;
	BeginUpdate(): void;
	static C(Other: UObject | any): GizmoStateTarget;
}

declare class GizmoFloatParameterSource extends Interface { 
	static Load(ResourceName: string): GizmoFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoFloatParameterSource;
	static GetDefaultObject(): GizmoFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoFloatParameterSource;
	SetParameter(NewValue: number): void;
	GetParameter(): number;
	EndModify(): void;
	BeginModify(): void;
	static C(Other: UObject | any): GizmoFloatParameterSource;
}

declare class GizmoVec2ParameterSource extends Interface { 
	static Load(ResourceName: string): GizmoVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoVec2ParameterSource;
	static GetDefaultObject(): GizmoVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoVec2ParameterSource;
	SetParameter(NewValue: Vector2D): void;
	GetParameter(): Vector2D;
	EndModify(): void;
	BeginModify(): void;
	static C(Other: UObject | any): GizmoVec2ParameterSource;
}

declare class GizmoLineHandleComponent extends GizmoBaseComponent { 
	Normal: Vector;
	HandleSize: number;
	Thickness: number;
	Direction: Vector;
	Length: number;
	bImageScale: boolean;
	static Load(ResourceName: string): GizmoLineHandleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoLineHandleComponent;
	static GetDefaultObject(): GizmoLineHandleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLineHandleComponent;
	static C(Other: UObject | any): GizmoLineHandleComponent;
}

declare class GizmoRectangleComponent extends GizmoBaseComponent { 
	DirectionX: Vector;
	DirectionY: Vector;
	bOrientYAccordingToCamera: boolean;
	OffsetX: number;
	OffsetY: number;
	LengthX: number;
	LengthY: number;
	Thickness: number;
	SegmentFlags: number;
	static Load(ResourceName: string): GizmoRectangleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoRectangleComponent;
	static GetDefaultObject(): GizmoRectangleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoRectangleComponent;
	static C(Other: UObject | any): GizmoRectangleComponent;
}

declare class GizmoLambdaHitTarget extends UObject { 
	static Load(ResourceName: string): GizmoLambdaHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoLambdaHitTarget;
	static GetDefaultObject(): GizmoLambdaHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLambdaHitTarget;
	static C(Other: UObject | any): GizmoLambdaHitTarget;
}

declare class GizmoComponentHitTarget extends UObject { 
	Component: PrimitiveComponent;
	static Load(ResourceName: string): GizmoComponentHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentHitTarget;
	static GetDefaultObject(): GizmoComponentHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentHitTarget;
	static C(Other: UObject | any): GizmoComponentHitTarget;
}

declare class InputBehaviorSource extends Interface { 
	static Load(ResourceName: string): InputBehaviorSource;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSource;
	static GetDefaultObject(): InputBehaviorSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSource;
	static C(Other: UObject | any): InputBehaviorSource;
}

declare class LocalInputBehaviorSource extends UObject { 
	static Load(ResourceName: string): LocalInputBehaviorSource;
	static Find(Outer: UObject, ResourceName: string): LocalInputBehaviorSource;
	static GetDefaultObject(): LocalInputBehaviorSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalInputBehaviorSource;
	static C(Other: UObject | any): LocalInputBehaviorSource;
}

declare class InputRouter extends UObject { 
	bAutoInvalidateOnHover: boolean;
	bAutoInvalidateOnCapture: boolean;
	ActiveInputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InputRouter;
	static Find(Outer: UObject, ResourceName: string): InputRouter;
	static GetDefaultObject(): InputRouter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputRouter;
	static C(Other: UObject | any): InputRouter;
}

declare class InteractionMechanic extends UObject { 
	static Load(ResourceName: string): InteractionMechanic;
	static Find(Outer: UObject, ResourceName: string): InteractionMechanic;
	static GetDefaultObject(): InteractionMechanic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractionMechanic;
	static C(Other: UObject | any): InteractionMechanic;
}

declare class ActiveGizmo { 
	Gizmo: InteractiveGizmo;
	clone() : ActiveGizmo;
	static C(Other: UObject | any): ActiveGizmo;
}

declare class InteractiveGizmoManager extends UObject { 
	ActiveGizmos: ActiveGizmo[];
	GizmoBuilders: any;
	static Load(ResourceName: string): InteractiveGizmoManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoManager;
	static GetDefaultObject(): InteractiveGizmoManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoManager;
	static C(Other: UObject | any): InteractiveGizmoManager;
}

declare class InteractiveToolWithToolTargetsBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): InteractiveToolWithToolTargetsBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolWithToolTargetsBuilder;
	static GetDefaultObject(): InteractiveToolWithToolTargetsBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolWithToolTargetsBuilder;
	static C(Other: UObject | any): InteractiveToolWithToolTargetsBuilder;
}

declare class ToolContextTransactionProvider extends Interface { 
	static Load(ResourceName: string): ToolContextTransactionProvider;
	static Find(Outer: UObject, ResourceName: string): ToolContextTransactionProvider;
	static GetDefaultObject(): ToolContextTransactionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolContextTransactionProvider;
	static C(Other: UObject | any): ToolContextTransactionProvider;
}

declare class InteractiveToolManager extends UObject { 
	ActiveLeftTool: InteractiveTool;
	ActiveRightTool: InteractiveTool;
	ToolBuilders: any;
	static Load(ResourceName: string): InteractiveToolManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolManager;
	static GetDefaultObject(): InteractiveToolManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolManager;
	static C(Other: UObject | any): InteractiveToolManager;
}

declare class ToolFrameworkComponent extends Interface { 
	static Load(ResourceName: string): ToolFrameworkComponent;
	static Find(Outer: UObject, ResourceName: string): ToolFrameworkComponent;
	static GetDefaultObject(): ToolFrameworkComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolFrameworkComponent;
	static C(Other: UObject | any): ToolFrameworkComponent;
}

declare class InteractiveToolCameraFocusAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolCameraFocusAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolCameraFocusAPI;
	static GetDefaultObject(): InteractiveToolCameraFocusAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolCameraFocusAPI;
	static C(Other: UObject | any): InteractiveToolCameraFocusAPI;
}

declare class InteractiveToolNestedAcceptCancelAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolNestedAcceptCancelAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolNestedAcceptCancelAPI;
	static GetDefaultObject(): InteractiveToolNestedAcceptCancelAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolNestedAcceptCancelAPI;
	static C(Other: UObject | any): InteractiveToolNestedAcceptCancelAPI;
}

declare class InteractiveToolExclusiveToolAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolExclusiveToolAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolExclusiveToolAPI;
	static GetDefaultObject(): InteractiveToolExclusiveToolAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolExclusiveToolAPI;
	static C(Other: UObject | any): InteractiveToolExclusiveToolAPI;
}

declare class ToolTargetFactory extends UObject { 
	static Load(ResourceName: string): ToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): ToolTargetFactory;
	static GetDefaultObject(): ToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetFactory;
	static C(Other: UObject | any): ToolTargetFactory;
}

declare class ToolTargetManager extends UObject { 
	Factories: ToolTargetFactory[];
	static Load(ResourceName: string): ToolTargetManager;
	static Find(Outer: UObject, ResourceName: string): ToolTargetManager;
	static GetDefaultObject(): ToolTargetManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetManager;
	static C(Other: UObject | any): ToolTargetManager;
}

declare class InteractiveToolsContext extends UObject { 
	InputRouter: InputRouter;
	TargetManager: ToolTargetManager;
	ToolManager: InteractiveToolManager;
	GizmoManager: InteractiveGizmoManager;
	ContextObjectStore: ContextObjectStore;
	ToolManagerClass: Class;
	static Load(ResourceName: string): InteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolsContext;
	static GetDefaultObject(): InteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolsContext;
	static C(Other: UObject | any): InteractiveToolsContext;
}

declare class IntervalGizmoActor extends GizmoActor { 
	UpIntervalComponent: GizmoLineHandleComponent;
	DownIntervalComponent: GizmoLineHandleComponent;
	ForwardIntervalComponent: GizmoLineHandleComponent;
	static GetDefaultObject(): IntervalGizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmoActor;
	static C(Other: UObject | any): IntervalGizmoActor;
}

declare class IntervalGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): IntervalGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): IntervalGizmoBuilder;
	static GetDefaultObject(): IntervalGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmoBuilder;
	static C(Other: UObject | any): IntervalGizmoBuilder;
}

declare class IntervalGizmo extends InteractiveGizmo { 
	StateTarget: GizmoTransformChangeStateTarget;
	TransformProxy: TransformProxy;
	ActiveComponents: PrimitiveComponent[];
	ActiveGizmos: InteractiveGizmo[];
	AxisYSource: GizmoComponentAxisSource;
	AxisZSource: GizmoComponentAxisSource;
	static Load(ResourceName: string): IntervalGizmo;
	static Find(Outer: UObject, ResourceName: string): IntervalGizmo;
	static GetDefaultObject(): IntervalGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmo;
	static C(Other: UObject | any): IntervalGizmo;
}

declare class GizmoBaseFloatParameterSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseFloatParameterSource;
	static GetDefaultObject(): GizmoBaseFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseFloatParameterSource;
	static C(Other: UObject | any): GizmoBaseFloatParameterSource;
}

declare class GizmoAxisIntervalParameterSource extends GizmoBaseFloatParameterSource { 
	FloatParameterSource: any;
	MinParameter: number;
	MaxParameter: number;
	static Load(ResourceName: string): GizmoAxisIntervalParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisIntervalParameterSource;
	static GetDefaultObject(): GizmoAxisIntervalParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisIntervalParameterSource;
	static C(Other: UObject | any): GizmoAxisIntervalParameterSource;
}

declare class KeyAsModifierInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): KeyAsModifierInputBehavior;
	static Find(Outer: UObject, ResourceName: string): KeyAsModifierInputBehavior;
	static GetDefaultObject(): KeyAsModifierInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KeyAsModifierInputBehavior;
	static C(Other: UObject | any): KeyAsModifierInputBehavior;
}

declare class MaterialProvider extends Interface { 
	static Load(ResourceName: string): MaterialProvider;
	static Find(Outer: UObject, ResourceName: string): MaterialProvider;
	static GetDefaultObject(): MaterialProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialProvider;
	static C(Other: UObject | any): MaterialProvider;
}

declare class MeshDescriptionCommitter extends Interface { 
	static Load(ResourceName: string): MeshDescriptionCommitter;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionCommitter;
	static GetDefaultObject(): MeshDescriptionCommitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionCommitter;
	static C(Other: UObject | any): MeshDescriptionCommitter;
}

declare class MeshDescriptionProvider extends Interface { 
	static Load(ResourceName: string): MeshDescriptionProvider;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionProvider;
	static GetDefaultObject(): MeshDescriptionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionProvider;
	static C(Other: UObject | any): MeshDescriptionProvider;
}

declare class MeshSurfacePointToolBuilder extends InteractiveToolWithToolTargetsBuilder { 
	static Load(ResourceName: string): MeshSurfacePointToolBuilder;
	static Find(Outer: UObject, ResourceName: string): MeshSurfacePointToolBuilder;
	static GetDefaultObject(): MeshSurfacePointToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSurfacePointToolBuilder;
	static C(Other: UObject | any): MeshSurfacePointToolBuilder;
}

declare class MouseHoverBehavior extends InputBehavior { 
	static Load(ResourceName: string): MouseHoverBehavior;
	static Find(Outer: UObject, ResourceName: string): MouseHoverBehavior;
	static GetDefaultObject(): MouseHoverBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseHoverBehavior;
	static C(Other: UObject | any): MouseHoverBehavior;
}

declare class LocalMouseHoverBehavior extends MouseHoverBehavior { 
	static Load(ResourceName: string): LocalMouseHoverBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalMouseHoverBehavior;
	static GetDefaultObject(): LocalMouseHoverBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMouseHoverBehavior;
	static C(Other: UObject | any): LocalMouseHoverBehavior;
}

declare class MouseWheelInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): MouseWheelInputBehavior;
	static Find(Outer: UObject, ResourceName: string): MouseWheelInputBehavior;
	static GetDefaultObject(): MouseWheelInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseWheelInputBehavior;
	static C(Other: UObject | any): MouseWheelInputBehavior;
}

declare class MultiClickSequenceInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): MultiClickSequenceInputBehavior;
	static Find(Outer: UObject, ResourceName: string): MultiClickSequenceInputBehavior;
	static GetDefaultObject(): MultiClickSequenceInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiClickSequenceInputBehavior;
	static C(Other: UObject | any): MultiClickSequenceInputBehavior;
}

declare class MultiSelectionTool extends InteractiveTool { 
	Targets: ToolTarget[];
	static Load(ResourceName: string): MultiSelectionTool;
	static Find(Outer: UObject, ResourceName: string): MultiSelectionTool;
	static GetDefaultObject(): MultiSelectionTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiSelectionTool;
	static C(Other: UObject | any): MultiSelectionTool;
}

declare class GizmoFloatParameterChange { 
	InitialValue: number;
	CurrentValue: number;
	clone() : GizmoFloatParameterChange;
	static C(Other: UObject | any): GizmoFloatParameterChange;
}

declare class GizmoLocalFloatParameterSource extends GizmoBaseFloatParameterSource { 
	Value: number;
	LastChange: GizmoFloatParameterChange;
	static Load(ResourceName: string): GizmoLocalFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoLocalFloatParameterSource;
	static GetDefaultObject(): GizmoLocalFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLocalFloatParameterSource;
	static C(Other: UObject | any): GizmoLocalFloatParameterSource;
}

declare class GizmoBaseVec2ParameterSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseVec2ParameterSource;
	static GetDefaultObject(): GizmoBaseVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseVec2ParameterSource;
	static C(Other: UObject | any): GizmoBaseVec2ParameterSource;
}

declare class GizmoVec2ParameterChange { 
	InitialValue: Vector2D;
	CurrentValue: Vector2D;
	clone() : GizmoVec2ParameterChange;
	static C(Other: UObject | any): GizmoVec2ParameterChange;
}

declare class GizmoLocalVec2ParameterSource extends GizmoBaseVec2ParameterSource { 
	Value: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	static Load(ResourceName: string): GizmoLocalVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoLocalVec2ParameterSource;
	static GetDefaultObject(): GizmoLocalVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLocalVec2ParameterSource;
	static C(Other: UObject | any): GizmoLocalVec2ParameterSource;
}

declare class GizmoAxisTranslationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	TransformSource: any;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurTranslationAxis: Vector;
	CurTranslationOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisTranslationParameterSource;
	static GetDefaultObject(): GizmoAxisTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisTranslationParameterSource;
	static C(Other: UObject | any): GizmoAxisTranslationParameterSource;
}

declare class GizmoPlaneTranslationParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: any;
	TransformSource: any;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurTranslationOrigin: Vector;
	CurTranslationNormal: Vector;
	CurTranslationAxisX: Vector;
	CurTranslationAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoPlaneTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoPlaneTranslationParameterSource;
	static GetDefaultObject(): GizmoPlaneTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoPlaneTranslationParameterSource;
	static C(Other: UObject | any): GizmoPlaneTranslationParameterSource;
}

declare class GizmoAxisRotationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	TransformSource: any;
	Angle: number;
	LastChange: GizmoFloatParameterChange;
	CurRotationAxis: Vector;
	CurRotationOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisRotationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisRotationParameterSource;
	static GetDefaultObject(): GizmoAxisRotationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisRotationParameterSource;
	static C(Other: UObject | any): GizmoAxisRotationParameterSource;
}

declare class GizmoUniformScaleParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: any;
	TransformSource: any;
	ScaleMultiplier: number;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurScaleOrigin: Vector;
	CurScaleNormal: Vector;
	CurScaleAxisX: Vector;
	CurScaleAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoUniformScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoUniformScaleParameterSource;
	static GetDefaultObject(): GizmoUniformScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoUniformScaleParameterSource;
	static C(Other: UObject | any): GizmoUniformScaleParameterSource;
}

declare class GizmoAxisScaleParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	TransformSource: any;
	ScaleMultiplier: number;
	bClampToZero: boolean;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurScaleAxis: Vector;
	CurScaleOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisScaleParameterSource;
	static GetDefaultObject(): GizmoAxisScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisScaleParameterSource;
	static C(Other: UObject | any): GizmoAxisScaleParameterSource;
}

declare class GizmoPlaneScaleParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: any;
	TransformSource: any;
	ScaleMultiplier: number;
	bUseEqualScaling: boolean;
	bClampToZero: boolean;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurScaleOrigin: Vector;
	CurScaleNormal: Vector;
	CurScaleAxisX: Vector;
	CurScaleAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoPlaneScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoPlaneScaleParameterSource;
	static GetDefaultObject(): GizmoPlaneScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoPlaneScaleParameterSource;
	static C(Other: UObject | any): GizmoPlaneScaleParameterSource;
}

declare class PhysicsDataSource extends Interface { 
	static Load(ResourceName: string): PhysicsDataSource;
	static Find(Outer: UObject, ResourceName: string): PhysicsDataSource;
	static GetDefaultObject(): PhysicsDataSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsDataSource;
	static C(Other: UObject | any): PhysicsDataSource;
}

declare class PlanePositionGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): PlanePositionGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): PlanePositionGizmoBuilder;
	static GetDefaultObject(): PlanePositionGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanePositionGizmoBuilder;
	static C(Other: UObject | any): PlanePositionGizmoBuilder;
}

declare class PlanePositionGizmo extends InteractiveGizmo { 
	AxisSource: any;
	ParameterSource: any;
	HitTarget: any;
	StateTarget: any;
	MouseBehavior: ClickDragInputBehavior;
	bEnableSignedAxis: boolean;
	bFlipX: boolean;
	bFlipY: boolean;
	bInInteraction: boolean;
	InteractionOrigin: Vector;
	InteractionNormal: Vector;
	InteractionAxisX: Vector;
	InteractionAxisY: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartParameter: Vector2D;
	InteractionCurParameter: Vector2D;
	ParameterSigns: Vector2D;
	static Load(ResourceName: string): PlanePositionGizmo;
	static Find(Outer: UObject, ResourceName: string): PlanePositionGizmo;
	static GetDefaultObject(): PlanePositionGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanePositionGizmo;
	static C(Other: UObject | any): PlanePositionGizmo;
}

declare class PrimitiveComponentBackedTarget extends Interface { 
	static Load(ResourceName: string): PrimitiveComponentBackedTarget;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentBackedTarget;
	static GetDefaultObject(): PrimitiveComponentBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentBackedTarget;
	static C(Other: UObject | any): PrimitiveComponentBackedTarget;
}

declare class PrimitiveComponentToolTarget extends ToolTarget { 
	static Load(ResourceName: string): PrimitiveComponentToolTarget;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentToolTarget;
	static GetDefaultObject(): PrimitiveComponentToolTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentToolTarget;
	static C(Other: UObject | any): PrimitiveComponentToolTarget;
}

declare class PrimitiveComponentToolTargetFactory extends ToolTargetFactory { 
	static Load(ResourceName: string): PrimitiveComponentToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentToolTargetFactory;
	static GetDefaultObject(): PrimitiveComponentToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentToolTargetFactory;
	static C(Other: UObject | any): PrimitiveComponentToolTargetFactory;
}

declare class RepositionableTransformGizmoBuilder extends CombinedTransformGizmoBuilder { 
	static Load(ResourceName: string): RepositionableTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): RepositionableTransformGizmoBuilder;
	static GetDefaultObject(): RepositionableTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepositionableTransformGizmoBuilder;
	static C(Other: UObject | any): RepositionableTransformGizmoBuilder;
}

declare class RepositionableTransformGizmo extends CombinedTransformGizmo { 
	RepositionStateTarget: GizmoTransformChangeStateTarget;
	static Load(ResourceName: string): RepositionableTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): RepositionableTransformGizmo;
	static GetDefaultObject(): RepositionableTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepositionableTransformGizmo;
	static C(Other: UObject | any): RepositionableTransformGizmo;
}

declare class ScalableSphereGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): ScalableSphereGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmoBuilder;
	static GetDefaultObject(): ScalableSphereGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmoBuilder;
	static C(Other: UObject | any): ScalableSphereGizmoBuilder;
}

declare class ScalableSphereGizmo extends InteractiveGizmo { 
	HitErrorThreshold: number;
	TransactionDescription: string;
	Radius: number;
	bIsHovering: boolean;
	bIsDragging: boolean;
	ActiveTarget: TransformProxy;
	ActiveAxis: Vector;
	DragStartWorldPosition: Vector;
	DragCurrentPositionProjected: Vector;
	InteractionStartParameter: number;
	static Load(ResourceName: string): ScalableSphereGizmo;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmo;
	static GetDefaultObject(): ScalableSphereGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmo;
	static C(Other: UObject | any): ScalableSphereGizmo;
}

declare class ScalableSphereGizmoInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): ScalableSphereGizmoInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmoInputBehavior;
	static GetDefaultObject(): ScalableSphereGizmoInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmoInputBehavior;
	static C(Other: UObject | any): ScalableSphereGizmoInputBehavior;
}

declare class SceneSnappingManager extends UObject { 
	static Load(ResourceName: string): SceneSnappingManager;
	static Find(Outer: UObject, ResourceName: string): SceneSnappingManager;
	static GetDefaultObject(): SceneSnappingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneSnappingManager;
	static C(Other: UObject | any): SceneSnappingManager;
}

declare class SelectionSet extends UObject { 
	static Load(ResourceName: string): SelectionSet;
	static Find(Outer: UObject, ResourceName: string): SelectionSet;
	static GetDefaultObject(): SelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SelectionSet;
	static C(Other: UObject | any): SelectionSet;
}

declare class MeshSelectionSet extends SelectionSet { 
	Vertices: number[];
	Edges: number[];
	Faces: number[];
	Groups: number[];
	static Load(ResourceName: string): MeshSelectionSet;
	static Find(Outer: UObject, ResourceName: string): MeshSelectionSet;
	static GetDefaultObject(): MeshSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSelectionSet;
	static C(Other: UObject | any): MeshSelectionSet;
}

declare class SingleClickInputBehavior extends AnyButtonInputBehavior { 
	HitTestOnRelease: boolean;
	static Load(ResourceName: string): SingleClickInputBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleClickInputBehavior;
	static GetDefaultObject(): SingleClickInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickInputBehavior;
	static C(Other: UObject | any): SingleClickInputBehavior;
}

declare class LocalSingleClickInputBehavior extends SingleClickInputBehavior { 
	static Load(ResourceName: string): LocalSingleClickInputBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalSingleClickInputBehavior;
	static GetDefaultObject(): LocalSingleClickInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalSingleClickInputBehavior;
	static C(Other: UObject | any): LocalSingleClickInputBehavior;
}

declare class SingleClickOrDragInputBehavior extends AnyButtonInputBehavior { 
	bBeginDragIfClickTargetNotHit: boolean;
	ClickDistanceThreshold: number;
	static Load(ResourceName: string): SingleClickOrDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleClickOrDragInputBehavior;
	static GetDefaultObject(): SingleClickOrDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickOrDragInputBehavior;
	static C(Other: UObject | any): SingleClickOrDragInputBehavior;
}

declare class SingleClickToolBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): SingleClickToolBuilder;
	static Find(Outer: UObject, ResourceName: string): SingleClickToolBuilder;
	static GetDefaultObject(): SingleClickToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickToolBuilder;
	static C(Other: UObject | any): SingleClickToolBuilder;
}

declare class SingleClickTool extends InteractiveTool { 
	static Load(ResourceName: string): SingleClickTool;
	static Find(Outer: UObject, ResourceName: string): SingleClickTool;
	static GetDefaultObject(): SingleClickTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickTool;
	static C(Other: UObject | any): SingleClickTool;
}

declare class SingleKeyCaptureBehavior extends InputBehavior { 
	static Load(ResourceName: string): SingleKeyCaptureBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleKeyCaptureBehavior;
	static GetDefaultObject(): SingleKeyCaptureBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleKeyCaptureBehavior;
	static C(Other: UObject | any): SingleKeyCaptureBehavior;
}

declare class SkeletalMeshBackedTarget extends AssetBackedTarget { 
	static Load(ResourceName: string): SkeletalMeshBackedTarget;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshBackedTarget;
	static GetDefaultObject(): SkeletalMeshBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshBackedTarget;
	static C(Other: UObject | any): SkeletalMeshBackedTarget;
}

declare class GizmoNilStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoNilStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoNilStateTarget;
	static GetDefaultObject(): GizmoNilStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoNilStateTarget;
	static C(Other: UObject | any): GizmoNilStateTarget;
}

declare class GizmoLambdaStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoLambdaStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoLambdaStateTarget;
	static GetDefaultObject(): GizmoLambdaStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLambdaStateTarget;
	static C(Other: UObject | any): GizmoLambdaStateTarget;
}

declare class GizmoObjectModifyStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoObjectModifyStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectModifyStateTarget;
	static GetDefaultObject(): GizmoObjectModifyStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectModifyStateTarget;
	static C(Other: UObject | any): GizmoObjectModifyStateTarget;
}

declare class StaticMeshBackedTarget extends AssetBackedTarget { 
	static Load(ResourceName: string): StaticMeshBackedTarget;
	static Find(Outer: UObject, ResourceName: string): StaticMeshBackedTarget;
	static GetDefaultObject(): StaticMeshBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshBackedTarget;
	static C(Other: UObject | any): StaticMeshBackedTarget;
}

declare class CombinedTransformGizmoContextObject extends UObject { 
	static Load(ResourceName: string): CombinedTransformGizmoContextObject;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmoContextObject;
	static GetDefaultObject(): CombinedTransformGizmoContextObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoContextObject;
	static C(Other: UObject | any): CombinedTransformGizmoContextObject;
}

declare class GizmoBaseTransformSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseTransformSource;
	static GetDefaultObject(): GizmoBaseTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseTransformSource;
	static C(Other: UObject | any): GizmoBaseTransformSource;
}

declare class GizmoComponentWorldTransformSource extends GizmoBaseTransformSource { 
	Component: SceneComponent;
	bModifyComponentOnTransform: boolean;
	static Load(ResourceName: string): GizmoComponentWorldTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentWorldTransformSource;
	static GetDefaultObject(): GizmoComponentWorldTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentWorldTransformSource;
	static C(Other: UObject | any): GizmoComponentWorldTransformSource;
}

declare class GizmoScaledTransformSource extends GizmoBaseTransformSource { 
	ChildTransformSource: any;
	static Load(ResourceName: string): GizmoScaledTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoScaledTransformSource;
	static GetDefaultObject(): GizmoScaledTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoScaledTransformSource;
	static C(Other: UObject | any): GizmoScaledTransformSource;
}

declare class GizmoTransformProxyTransformSource extends GizmoBaseTransformSource { 
	Proxy: TransformProxy;
	static Load(ResourceName: string): GizmoTransformProxyTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformProxyTransformSource;
	static GetDefaultObject(): GizmoTransformProxyTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformProxyTransformSource;
	static C(Other: UObject | any): GizmoTransformProxyTransformSource;
}

declare class GizmoScaledAndUnscaledTransformSources extends GizmoBaseTransformSource { 
	ScaledTransformSource: any;
	UnscaledTransformSource: any;
	static Load(ResourceName: string): GizmoScaledAndUnscaledTransformSources;
	static Find(Outer: UObject, ResourceName: string): GizmoScaledAndUnscaledTransformSources;
	static GetDefaultObject(): GizmoScaledAndUnscaledTransformSources;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoScaledAndUnscaledTransformSources;
	static C(Other: UObject | any): GizmoScaledAndUnscaledTransformSources;
}

declare class TypedElementCounterInterface extends Interface { 
	static Load(ResourceName: string): TypedElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementCounterInterface;
	static GetDefaultObject(): TypedElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementCounterInterface;
	static C(Other: UObject | any): TypedElementCounterInterface;
}

declare class TestTypedElementInterfaceA extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceA;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA;
	static GetDefaultObject(): TestTypedElementInterfaceA;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA;
	SetDisplayName(InElementHandle: ScriptTypedElementHandle,InNewName: string,bNotify: boolean): boolean;
	GetDisplayName(InElementHandle: ScriptTypedElementHandle): string;
	static C(Other: UObject | any): TestTypedElementInterfaceA;
}

declare class TestTypedElementInterfaceB extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceB;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceB;
	static GetDefaultObject(): TestTypedElementInterfaceB;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceB;
	MarkAsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceB;
}

declare class TestTypedElementInterfaceC extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceC;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceC;
	static GetDefaultObject(): TestTypedElementInterfaceC;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceC;
	GetIsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceC;
}

declare class TestTypedElementInterfaceA_ImplTyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplTyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplTyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplTyped;
}

declare class TestTypedElementInterfaceA_ImplUntyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplUntyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplUntyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplUntyped;
}

declare class TestTypedElementInterfaceBAndC_Typed extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static GetDefaultObject(): TestTypedElementInterfaceBAndC_Typed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceBAndC_Typed;
	static C(Other: UObject | any): TestTypedElementInterfaceBAndC_Typed;
}

declare class TypedElementHandleLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementHandleLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementHandleLibrary;
	static GetDefaultObject(): TypedElementHandleLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHandleLibrary;
	static Release(ElementHandle?: ScriptTypedElementHandle): {ElementHandle: ScriptTypedElementHandle};
	static NotEqual(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static IsSet(ElementHandle: ScriptTypedElementHandle): boolean;
	static Equal(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementHandleLibrary;
}

declare class ScriptTypedElementListProxy { 
	clone() : ScriptTypedElementListProxy;
	static C(Other: UObject | any): ScriptTypedElementListProxy;
}

declare class TypedElementRegistry extends UObject { 
	static Load(ResourceName: string): TypedElementRegistry;
	static Find(Outer: UObject, ResourceName: string): TypedElementRegistry;
	static GetDefaultObject(): TypedElementRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementRegistry;
	static GetInstance(): TypedElementRegistry;
	GetElementInterface(InElementHandle: ScriptTypedElementHandle,InBaseInterfaceType: UnrealEngineClass): UObject;
	static C(Other: UObject | any): TypedElementRegistry;
}

declare class TypedElementListLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementListLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementListLibrary;
	static GetDefaultObject(): TypedElementListLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementListLibrary;
	static Shrink(ElementList: ScriptTypedElementListProxy): void;
	static Reset(ElementList: ScriptTypedElementListProxy): void;
	static Reserve(ElementList: ScriptTypedElementListProxy,Size: number): void;
	static Remove(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Num(ElementList: ScriptTypedElementListProxy): number;
	static IsValidIndex(ElementList: ScriptTypedElementListProxy,index: number): boolean;
	static HasElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): boolean;
	static HasElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): boolean;
	static GetElementInterface(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle,BaseInterfaceType: UnrealEngineClass): UObject;
	static GetElementHandles(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	static GetElementHandleAt(ElementList: ScriptTypedElementListProxy,index: number): ScriptTypedElementHandle;
	static Empty(ElementList: ScriptTypedElementListProxy,Slack: number): void;
	static CreateScriptElementList(Registry: TypedElementRegistry): ScriptTypedElementListProxy;
	static CountElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): number;
	static CountElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): number;
	static Contains(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Clone(ElementList: ScriptTypedElementListProxy): ScriptTypedElementListProxy;
	static AppendList(ElementList: ScriptTypedElementListProxy,OtherElementList: ScriptTypedElementListProxy): void;
	static Append(ElementList: ScriptTypedElementListProxy,ElementHandles: ScriptTypedElementHandle[]): void;
	static Add(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementListLibrary;
}

declare class TypedElementAssetDataInterface extends Interface { 
	static Load(ResourceName: string): TypedElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementAssetDataInterface;
	static GetDefaultObject(): TypedElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementAssetDataInterface;
	GetAssetData(InElementHandle: ScriptTypedElementHandle): AssetData;
	GetAllReferencedAssetDatas(InElementHandle: ScriptTypedElementHandle): AssetData[];
	static C(Other: UObject | any): TypedElementAssetDataInterface;
}

declare class TypedElementHierarchyInterface extends Interface { 
	static Load(ResourceName: string): TypedElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementHierarchyInterface;
	static GetDefaultObject(): TypedElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHierarchyInterface;
	GetParentElement(InElementHandle: ScriptTypedElementHandle,bAllowCreate: boolean): ScriptTypedElementHandle;
	GetChildElements(InElementHandle: ScriptTypedElementHandle,OutElementHandles?: ScriptTypedElementHandle[],bAllowCreate?: boolean): {OutElementHandles: ScriptTypedElementHandle[]};
	static C(Other: UObject | any): TypedElementHierarchyInterface;
}

declare class TypedElementObjectInterface extends Interface { 
	static Load(ResourceName: string): TypedElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementObjectInterface;
	static GetDefaultObject(): TypedElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementObjectInterface;
	GetObjectClass(InElementHandle: ScriptTypedElementHandle): UnrealEngineClass;
	GetObject(InElementHandle: ScriptTypedElementHandle): UObject;
	static C(Other: UObject | any): TypedElementObjectInterface;
}

declare type ETypedElementChildInclusionMethod = 'None' | 'Immediate' | 'Recursive' | 'ETypedElementChildInclusionMethod_MAX';
declare var ETypedElementChildInclusionMethod : { None:'None',Immediate:'Immediate',Recursive:'Recursive',ETypedElementChildInclusionMethod_MAX:'ETypedElementChildInclusionMethod_MAX', };
declare class TypedElementSelectionOptions { 
	bAllowHidden: boolean;
	bAllowGroups: boolean;
	bAllowLegacyNotifications: boolean;
	bWarnIfLocked: boolean;
	ChildElementInclusionMethod: ETypedElementChildInclusionMethod;
	clone() : TypedElementSelectionOptions;
	static C(Other: UObject | any): TypedElementSelectionOptions;
}

declare class TypedElementIsSelectedOptions { 
	bAllowIndirect: boolean;
	clone() : TypedElementIsSelectedOptions;
	static C(Other: UObject | any): TypedElementIsSelectedOptions;
}

declare type ETypedElementSelectionMethod = 'Primary' | 'Secondary' | 'ETypedElementSelectionMethod_MAX';
declare var ETypedElementSelectionMethod : { Primary:'Primary',Secondary:'Secondary',ETypedElementSelectionMethod_MAX:'ETypedElementSelectionMethod_MAX', };
declare class TypedElementSelectionInterface extends Interface { 
	static Load(ResourceName: string): TypedElementSelectionInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionInterface;
	static GetDefaultObject(): TypedElementSelectionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionInterface;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InCurrentSelection: ScriptTypedElementListProxy,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy): boolean;
	static C(Other: UObject | any): TypedElementSelectionInterface;
}

declare class TypedElementSelectionSetState { 
	CreatedFromSelectionSet: any;
	clone() : TypedElementSelectionSetState;
	static C(Other: UObject | any): TypedElementSelectionSetState;
}

declare class TypedElementSelectionSet extends UObject { 
	OnPreSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	OnSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	static Load(ResourceName: string): TypedElementSelectionSet;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSet;
	static GetDefaultObject(): TypedElementSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSet;
	SetSelection(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	RestoreSelectionState(InSelectionState: TypedElementSelectionSetState): void;
	K2_GetSelectedElementHandles(InBaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	HasSelectedObjects(InRequiredClass: UnrealEngineClass): boolean;
	HasSelectedElements(InBaseInterfaceType: UnrealEngineClass): boolean;
	GetTopSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	GetSelectedObjects(InRequiredClass: UnrealEngineClass): UObject[];
	GetNumSelectedElements(): number;
	GetCurrentSelectionState(): TypedElementSelectionSetState;
	GetBottomSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	DeselectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CountSelectedObjects(InRequiredClass: UnrealEngineClass): number;
	CountSelectedElements(InBaseInterfaceType: UnrealEngineClass): number;
	ClearSelection(InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementSelectionSet;
}

declare class TypedElementSelectionNormalizationOptions { 
	bExpandGroups: boolean;
	bFollowAttachment: boolean;
	clone() : TypedElementSelectionNormalizationOptions;
	static C(Other: UObject | any): TypedElementSelectionNormalizationOptions;
}

declare class TypedElementSelectionSetLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementSelectionSetLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSetLibrary;
	static GetDefaultObject(): TypedElementSelectionSetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSetLibrary;
	static SetSelectionFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static SelectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static GetNormalizedSelection(SelectionSet: TypedElementSelectionSet,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static GetNormalizedElementList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static DeselectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static C(Other: UObject | any): TypedElementSelectionSetLibrary;
}

declare class AssetEditorContextInterface extends Interface { 
	static Load(ResourceName: string): AssetEditorContextInterface;
	static Find(Outer: UObject, ResourceName: string): AssetEditorContextInterface;
	static GetDefaultObject(): AssetEditorContextInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorContextInterface;
	static C(Other: UObject | any): AssetEditorContextInterface;
}

declare class AssetEditorUISubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): AssetEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): AssetEditorUISubsystem;
	static GetDefaultObject(): AssetEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorUISubsystem;
	static C(Other: UObject | any): AssetEditorUISubsystem;
}

declare class AssetFactoryInterface extends Interface { 
	static Load(ResourceName: string): AssetFactoryInterface;
	static Find(Outer: UObject, ResourceName: string): AssetFactoryInterface;
	static GetDefaultObject(): AssetFactoryInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetFactoryInterface;
	static C(Other: UObject | any): AssetFactoryInterface;
}

declare class EditorElementSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): EditorElementSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorElementSubsystem;
	static GetDefaultObject(): EditorElementSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorElementSubsystem;
	static C(Other: UObject | any): EditorElementSubsystem;
}

declare class PlacementSubsystem extends EditorSubsystem { 
	AssetFactories: any[];
	static Load(ResourceName: string): PlacementSubsystem;
	static Find(Outer: UObject, ResourceName: string): PlacementSubsystem;
	static GetDefaultObject(): PlacementSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlacementSubsystem;
	static C(Other: UObject | any): PlacementSubsystem;
}

declare class TypedElementDetailsInterface extends Interface { 
	static Load(ResourceName: string): TypedElementDetailsInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementDetailsInterface;
	static GetDefaultObject(): TypedElementDetailsInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementDetailsInterface;
	static C(Other: UObject | any): TypedElementDetailsInterface;
}

declare class TypedElementViewportInteraction extends UObject { 
	static Load(ResourceName: string): TypedElementViewportInteraction;
	static Find(Outer: UObject, ResourceName: string): TypedElementViewportInteraction;
	static GetDefaultObject(): TypedElementViewportInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementViewportInteraction;
	static C(Other: UObject | any): TypedElementViewportInteraction;
}

declare class AssetRegistryImpl extends UObject { 
	static Load(ResourceName: string): AssetRegistryImpl;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryImpl;
	static GetDefaultObject(): AssetRegistryImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryImpl;
	static C(Other: UObject | any): AssetRegistryImpl;
}

declare class ARFilter { 
	PackageNames: string[];
	PackagePaths: string[];
	ObjectPaths: string[];
	ClassNames: string[];
	RecursiveClassesExclusionSet: any;
	bRecursivePaths: boolean;
	bRecursiveClasses: boolean;
	bIncludeOnlyOnDiskAssets: boolean;
	clone() : ARFilter;
	static C(Other: UObject | any): ARFilter;
}

declare class TagAndValue { 
	Tag: string;
	Value: string;
	clone() : TagAndValue;
	static C(Other: UObject | any): TagAndValue;
}

declare class AssetRegistryHelpers extends UObject { 
	static Load(ResourceName: string): AssetRegistryHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryHelpers;
	static GetDefaultObject(): AssetRegistryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryHelpers;
	static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;
	static SetFilterTagsAndValues(InFilter: ARFilter,InTagsAndValues: TagAndValue[]): ARFilter;
	static IsValid(InAssetData: AssetData): boolean;
	static IsUAsset(InAssetData: AssetData): boolean;
	static IsRedirector(InAssetData: AssetData): boolean;
	static IsAssetLoaded(InAssetData: AssetData): boolean;
	static GetTagValue(InAssetData: AssetData,InTagName: string,OutTagValue?: string): {OutTagValue: string, $: boolean};
	static GetFullName(InAssetData: AssetData): string;
	static GetExportTextName(InAssetData: AssetData): string;
	static GetClass(InAssetData: AssetData): UnrealEngineClass;
	static GetAsset(InAssetData: AssetData): UObject;
	static CreateAssetData(InAsset: UObject,bAllowBlueprintClass: boolean): AssetData;
	static C(Other: UObject | any): AssetRegistryHelpers;
}

declare class AssetRegistryDependencyOptions { 
	bIncludeSoftPackageReferences: boolean;
	bIncludeHardPackageReferences: boolean;
	bIncludeSearchableNames: boolean;
	bIncludeSoftManagementReferences: boolean;
	bIncludeHardManagementReferences: boolean;
	clone() : AssetRegistryDependencyOptions;
	static C(Other: UObject | any): AssetRegistryDependencyOptions;
}

declare class AssetRegistry extends Interface { 
	static Load(ResourceName: string): AssetRegistry;
	static Find(Outer: UObject, ResourceName: string): AssetRegistry;
	static GetDefaultObject(): AssetRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistry;
	WaitForPackage(PackageName: string): void;
	WaitForCompletion(): void;
	UseFilterToExcludeAssets(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	SearchAllAssets(bSynchronousSearch: boolean): void;
	ScanPathsSynchronous(InPaths: string[],bForceRescan: boolean,bIgnoreDenyListScanFilters: boolean): void;
	ScanModifiedAssetFiles(InFilePaths: string[]): void;
	ScanFilesSynchronous(InFilePaths: string[],bForceRescan: boolean): void;
	RunAssetsThroughFilter(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	PrioritizeSearchPath(PathToPrioritize: string): void;
	K2_GetReferencers(PackageName: string,ReferenceOptions: AssetRegistryDependencyOptions,OutReferencers?: string[]): {OutReferencers: string[], $: boolean};
	K2_GetDependencies(PackageName: string,DependencyOptions: AssetRegistryDependencyOptions,OutDependencies?: string[]): {OutDependencies: string[], $: boolean};
	IsSearchAsync(): boolean;
	IsSearchAllAssets(): boolean;
	IsLoadingAssets(): boolean;
	HasAssets(PackagePath: string,bRecursive: boolean): boolean;
	GetSubPaths(InBasePath: string,OutPathList?: string[],bInRecurse?: boolean): {OutPathList: string[]};
	GetAssetsByPaths(PackagePaths: string[],OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPath(PackagePath: string,OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPackageName(PackageName: string,OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByClass(ClassName: string,OutAssetData?: AssetData[],bSearchSubClasses?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssets(Filter: ARFilter,OutAssetData?: AssetData[]): {OutAssetData: AssetData[], $: boolean};
	GetAssetByObjectPath(ObjectPath: string,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	GetAllCachedPaths(OutPathList?: string[]): {OutPathList: string[]};
	GetAllAssets(OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	static C(Other: UObject | any): AssetRegistry;
}

declare class AudioParameterControllerInterface extends Interface { 
	static Load(ResourceName: string): AudioParameterControllerInterface;
	static Find(Outer: UObject, ResourceName: string): AudioParameterControllerInterface;
	static GetDefaultObject(): AudioParameterControllerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioParameterControllerInterface;
	SetTriggerParameter(InName: string): void;
	SetStringParameter(InName: string,InValue: string): void;
	SetStringArrayParameter(InName: string,InValue: string[]): void;
	SetParameters_Blueprint(InParameters: AudioParameter[]): void;
	SetObjectParameter(InName: string,InValue: UObject): void;
	SetObjectArrayParameter(InName: string,InValue: UObject[]): void;
	SetIntParameter(InName: string,inInt: number): void;
	SetIntArrayParameter(InName: string,InValue: number[]): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetFloatArrayParameter(InName: string,InValue: number[]): void;
	SetBoolParameter(InName: string,InBool: boolean): void;
	SetBoolArrayParameter(InName: string,InValue: boolean[]): void;
	ResetParameters(): void;
	static C(Other: UObject | any): AudioParameterControllerInterface;
}

declare class AudioCodecEncoderSettings extends UObject { 
	Version: number;
	static Load(ResourceName: string): AudioCodecEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioCodecEncoderSettings;
	static GetDefaultObject(): AudioCodecEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioCodecEncoderSettings;
	static C(Other: UObject | any): AudioCodecEncoderSettings;
}

declare class AudioEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): AudioEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): AudioEndpointSettingsBase;
	static GetDefaultObject(): AudioEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEndpointSettingsBase;
	static C(Other: UObject | any): AudioEndpointSettingsBase;
}

declare class DummyEndpointSettings extends AudioEndpointSettingsBase { 
	static Load(ResourceName: string): DummyEndpointSettings;
	static Find(Outer: UObject, ResourceName: string): DummyEndpointSettings;
	static GetDefaultObject(): DummyEndpointSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DummyEndpointSettings;
	static C(Other: UObject | any): DummyEndpointSettings;
}

declare class SoundfieldEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSettingsBase;
	static GetDefaultObject(): SoundfieldEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSettingsBase;
	static C(Other: UObject | any): SoundfieldEndpointSettingsBase;
}

declare class SoundfieldEffectSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEffectSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectSettingsBase;
	static GetDefaultObject(): SoundfieldEffectSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectSettingsBase;
	static C(Other: UObject | any): SoundfieldEffectSettingsBase;
}

declare class SoundfieldEffectBase extends UObject { 
	Settings: SoundfieldEffectSettingsBase;
	static Load(ResourceName: string): SoundfieldEffectBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectBase;
	static GetDefaultObject(): SoundfieldEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectBase;
	static C(Other: UObject | any): SoundfieldEffectBase;
}

declare type EPcmBitDepthConversion = 'SameAsSource' | 'Int16' | 'Float32' | 'EPcmBitDepthConversion_MAX';
declare var EPcmBitDepthConversion : { SameAsSource:'SameAsSource',Int16:'Int16',Float32:'Float32',EPcmBitDepthConversion_MAX:'EPcmBitDepthConversion_MAX', };
declare class AudioPcmEncoderSettings extends AudioCodecEncoderSettings { 
	BitDepthConversion: EPcmBitDepthConversion;
	static Load(ResourceName: string): AudioPcmEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioPcmEncoderSettings;
	static GetDefaultObject(): AudioPcmEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioPcmEncoderSettings;
	static C(Other: UObject | any): AudioPcmEncoderSettings;
}

declare class AudioLinkBlueprintInterface extends Interface { 
	static Load(ResourceName: string): AudioLinkBlueprintInterface;
	static Find(Outer: UObject, ResourceName: string): AudioLinkBlueprintInterface;
	static GetDefaultObject(): AudioLinkBlueprintInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioLinkBlueprintInterface;
	StopLink(): void;
	SetLinkSound(NewSound: SoundBase): void;
	PlayLink(StartTime: number): void;
	IsLinkPlaying(): boolean;
	static C(Other: UObject | any): AudioLinkBlueprintInterface;
}

declare type EAudioDeviceChangedRole = 'Invalid' | 'Console' | 'Multimedia' | 'Communications' | 'Count' | 'EAudioDeviceChangedRole_MAX';
declare var EAudioDeviceChangedRole : { Invalid:'Invalid',Console:'Console',Multimedia:'Multimedia',Communications:'Communications',Count:'Count',EAudioDeviceChangedRole_MAX:'EAudioDeviceChangedRole_MAX', };
declare type EAudioDeviceChangedState = 'Invalid' | 'Active' | 'Disabled' | 'NotPresent' | 'Unplugged' | 'Count' | 'EAudioDeviceChangedState_MAX';
declare var EAudioDeviceChangedState : { Invalid:'Invalid',Active:'Active',Disabled:'Disabled',NotPresent:'NotPresent',Unplugged:'Unplugged',Count:'Count',EAudioDeviceChangedState_MAX:'EAudioDeviceChangedState_MAX', };
declare class AudioDeviceNotificationSubsystem extends EngineSubsystem { 
	DefaultCaptureDeviceChanged: UnrealEngineMulticastDelegate<(AudioDeviceRole: EAudioDeviceChangedRole, DeviceID: string) => void>;
	DefaultRenderDeviceChanged: UnrealEngineMulticastDelegate<(AudioDeviceRole: EAudioDeviceChangedRole, DeviceID: string) => void>;
	DeviceAdded: UnrealEngineMulticastDelegate<(DeviceID: string) => void>;
	DeviceRemoved: UnrealEngineMulticastDelegate<(DeviceID: string) => void>;
	DeviceStateChanged: UnrealEngineMulticastDelegate<(DeviceID: string, NewState: EAudioDeviceChangedState) => void>;
	DeviceSwitched: UnrealEngineMulticastDelegate<(DeviceID: string) => void>;
	static Load(ResourceName: string): AudioDeviceNotificationSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioDeviceNotificationSubsystem;
	static GetDefaultObject(): AudioDeviceNotificationSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioDeviceNotificationSubsystem;
	static C(Other: UObject | any): AudioDeviceNotificationSubsystem;
}

declare class AudioGenerator extends UObject { 
	static Load(ResourceName: string): AudioGenerator;
	static Find(Outer: UObject, ResourceName: string): AudioGenerator;
	static GetDefaultObject(): AudioGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioGenerator;
	static C(Other: UObject | any): AudioGenerator;
}

declare class SoundNode extends UObject { 
	ChildNodes: SoundNode[];
	GraphNode: EdGraphNode;
	static Load(ResourceName: string): SoundNode;
	static Find(Outer: UObject, ResourceName: string): SoundNode;
	static GetDefaultObject(): SoundNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNode;
	static C(Other: UObject | any): SoundNode;
}

declare class SoundCue extends SoundBase { 
	bPrimeOnLoad: boolean;
	FirstNode: SoundNode;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	AttenuationOverrides: SoundAttenuationSettings;
	AllNodes: SoundNode[];
	SoundCueGraph: EdGraph;
	SubtitlePriority: number;
	bOverrideAttenuation: boolean;
	bExcludeFromRandomNodeBranchCulling: boolean;
	CookedQualityIndex: number;
	bHasPlayWhenSilent: boolean;
	static Load(ResourceName: string): SoundCue;
	static Find(Outer: UObject, ResourceName: string): SoundCue;
	static GetDefaultObject(): SoundCue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCue;
	static C(Other: UObject | any): SoundCue;
	PrimeSoundCueForPlayback(): void;
	static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
}

declare type EAudioSpectrumBandPresetType = 'KickDrum' | 'SnareDrum' | 'Voice' | 'Cymbals' | 'EAudioSpectrumBandPresetType_MAX';
declare var EAudioSpectrumBandPresetType : { KickDrum:'KickDrum',SnareDrum:'SnareDrum',Voice:'Voice',Cymbals:'Cymbals',EAudioSpectrumBandPresetType_MAX:'EAudioSpectrumBandPresetType_MAX', };
declare class SoundSubmixSpectralAnalysisBandSettings { 
	BandFrequency: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	QFactor: number;
	clone() : SoundSubmixSpectralAnalysisBandSettings;
	static C(Other: UObject | any): SoundSubmixSpectralAnalysisBandSettings;
}

declare type EMusicalNoteName = 'C' | 'Db' | 'D' | 'Eb' | 'E' | 'F' | 'Gb' | 'G' | 'Ab' | 'A' | 'Bb' | 'B' | 'EMusicalNoteName_MAX';
declare var EMusicalNoteName : { C:'C',Db:'Db',D:'D',Eb:'Eb',E:'E',F:'F',Gb:'Gb',G:'G',Ab:'Ab',A:'A',Bb:'Bb',B:'B',EMusicalNoteName_MAX:'EMusicalNoteName_MAX', };
declare class AudioMixerBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AudioMixerBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AudioMixerBlueprintLibrary;
	static GetDefaultObject(): AudioMixerBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioMixerBlueprintLibrary;
	static TrimAudioCache(InMegabytesToFree: number): number;
	static StopRecordingOutput(WorldContextObject: UObject,ExportType: EAudioRecordingExportType,Name: string,Path: string,SubmixToRecord: SoundSubmix,ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
	static StopAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StopAnalyzingOutput(WorldContextObject: UObject,SubmixToStopAnalyzing: SoundSubmix): void;
	static StartRecordingOutput(WorldContextObject: UObject,ExpectedDuration: number,SubmixToRecord: SoundSubmix): void;
	static StartAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StartAnalyzingOutput(WorldContextObject: UObject,SubmixToAnalyze: SoundSubmix,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	static SetSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPresetChain: SoundEffectSubmixPreset[],FadeTimeSec: number): void;
	static SetBypassSourceEffectChainEntry(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	static ResumeRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static ReplaceSubmixEffect(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static ReplaceSoundEffectSubmix(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectPresetAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static RemoveSubmixEffectPreset(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static RemoveSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSourceEffectFromPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	static RemoveMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
	static PauseRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static MakePresetSpectralAnalysisBandSettings(InBandPresetType: EAudioSpectrumBandPresetType,InNumBands: number,InAttackTimeMsec: number,InReleaseTimeMsec: number): SoundSubmixSpectralAnalysisBandSettings[];
	static MakeMusicalSpectralAnalysisBandSettings(InNumSemitones: number,InStartingMusicalNote: EMusicalNoteName,InStartingOctave: number,InAttackTimeMsec: number,InReleaseTimeMsec: number): SoundSubmixSpectralAnalysisBandSettings[];
	static MakeFullSpectrumSpectralAnalysisBandSettings(InNumBands: number,InMinimumFrequency: number,InMaximumFrequency: number,InAttackTimeMsec: number,InReleaseTimeMsec: number): SoundSubmixSpectralAnalysisBandSettings[];
	static IsAudioBusActive(WorldContextObject: UObject,AudioBus: AudioBus): boolean;
	static GetPhaseForFrequencies(WorldContextObject: UObject,Frequencies: number[],Phases?: number[],SubmixToAnalyze?: SoundSubmix): {Phases: number[]};
	static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain): number;
	static GetMagnitudeForFrequencies(WorldContextObject: UObject,Frequencies: number[],Magnitudes?: number[],SubmixToAnalyze?: SoundSubmix): {Magnitudes: number[]};
	static Conv_AudioOutputDeviceInfoToString(Info: AudioOutputDeviceInfo): string;
	static ClearSubmixEffects(WorldContextObject: UObject,SoundSubmix: SoundSubmix): void;
	static ClearSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,FadeTimeSec: number): void;
	static ClearMasterSubmixEffects(WorldContextObject: UObject): void;
	static AddSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): number;
	static AddSourceEffectToPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	static AddMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static C(Other: UObject | any): AudioMixerBlueprintLibrary;
}

declare type EQuartzCommandQuantization = 'Bar' | 'Beat' | 'ThirtySecondNote' | 'SixteenthNote' | 'EighthNote' | 'QuarterNote' | 'HalfNote' | 'WholeNote' | 'DottedSixteenthNote' | 'DottedEighthNote' | 'DottedQuarterNote' | 'DottedHalfNote' | 'DottedWholeNote' | 'SixteenthNoteTriplet' | 'EighthNoteTriplet' | 'QuarterNoteTriplet' | 'HalfNoteTriplet' | 'Tick' | 'Count' | 'None' | 'EQuartzCommandQuantization_MAX';
declare var EQuartzCommandQuantization : { Bar:'Bar',Beat:'Beat',ThirtySecondNote:'ThirtySecondNote',SixteenthNote:'SixteenthNote',EighthNote:'EighthNote',QuarterNote:'QuarterNote',HalfNote:'HalfNote',WholeNote:'WholeNote',DottedSixteenthNote:'DottedSixteenthNote',DottedEighthNote:'DottedEighthNote',DottedQuarterNote:'DottedQuarterNote',DottedHalfNote:'DottedHalfNote',DottedWholeNote:'DottedWholeNote',SixteenthNoteTriplet:'SixteenthNoteTriplet',EighthNoteTriplet:'EighthNoteTriplet',QuarterNoteTriplet:'QuarterNoteTriplet',HalfNoteTriplet:'HalfNoteTriplet',Tick:'Tick',Count:'Count',None:'None',EQuartzCommandQuantization_MAX:'EQuartzCommandQuantization_MAX', };
declare class QuartzTransportTimeStamp { 
	Bars: number;
	Beat: number;
	BeatFraction: number;
	Seconds: number;
	clone() : QuartzTransportTimeStamp;
	static C(Other: UObject | any): QuartzTransportTimeStamp;
}

declare class QuartzClockHandle extends UObject { 
	static Load(ResourceName: string): QuartzClockHandle;
	static Find(Outer: UObject, ResourceName: string): QuartzClockHandle;
	static GetDefaultObject(): QuartzClockHandle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuartzClockHandle;
	UnsubscribeFromTimeDivision(WorldContextObject: UObject,InQuantizationBoundary: EQuartzCommandQuantization,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	UnsubscribeFromAllTimeDivisions(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	StopClock(WorldContextObject: UObject,CancelPendingEvents: boolean,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	StartClock(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	ResumeClock(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	PauseClock(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	IsClockRunning(WorldContextObject: UObject): boolean;
	GetTicksPerSecond(WorldContextObject: UObject): number;
	GetThirtySecondNotesPerMinute(WorldContextObject: UObject): number;
	GetSecondsPerTick(WorldContextObject: UObject): number;
	GetMillisecondsPerTick(WorldContextObject: UObject): number;
	GetEstimatedRunTime(WorldContextObject: UObject): number;
	GetDurationOfQuantizationTypeInSeconds(WorldContextObject: UObject,QuantizationType: EQuartzCommandQuantization,Multiplier: number): number;
	GetCurrentTimestamp(WorldContextObject: UObject): QuartzTransportTimeStamp;
	GetBeatsPerMinute(WorldContextObject: UObject): number;
	static C(Other: UObject | any): QuartzClockHandle;
}

declare type ESubmixEffectDynamicsProcessorType = 'Compressor' | 'Limiter' | 'Expander' | 'Gate' | 'UpwardsCompressor' | 'Count' | 'ESubmixEffectDynamicsProcessorType_MAX';
declare var ESubmixEffectDynamicsProcessorType : { Compressor:'Compressor',Limiter:'Limiter',Expander:'Expander',Gate:'Gate',UpwardsCompressor:'UpwardsCompressor',Count:'Count',ESubmixEffectDynamicsProcessorType_MAX:'ESubmixEffectDynamicsProcessorType_MAX', };
declare type ESubmixEffectDynamicsPeakMode = 'MeanSquared' | 'RootMeanSquared' | 'Peak' | 'Count' | 'ESubmixEffectDynamicsPeakMode_MAX';
declare var ESubmixEffectDynamicsPeakMode : { MeanSquared:'MeanSquared',RootMeanSquared:'RootMeanSquared',Peak:'Peak',Count:'Count',ESubmixEffectDynamicsPeakMode_MAX:'ESubmixEffectDynamicsPeakMode_MAX', };
declare type ESubmixEffectDynamicsChannelLinkMode = 'Disabled' | 'Average' | 'Peak' | 'Count' | 'ESubmixEffectDynamicsChannelLinkMode_MAX';
declare var ESubmixEffectDynamicsChannelLinkMode : { Disabled:'Disabled',Average:'Average',Peak:'Peak',Count:'Count',ESubmixEffectDynamicsChannelLinkMode_MAX:'ESubmixEffectDynamicsChannelLinkMode_MAX', };
declare type ESubmixEffectDynamicsKeySource = 'Default' | 'AudioBus' | 'Submix' | 'Count' | 'ESubmixEffectDynamicsKeySource_MAX';
declare var ESubmixEffectDynamicsKeySource : { Default:'Default',AudioBus:'AudioBus',Submix:'Submix',Count:'Count',ESubmixEffectDynamicsKeySource_MAX:'ESubmixEffectDynamicsKeySource_MAX', };
declare class SubmixEffectDynamicProcessorFilterSettings { 
	bEnabled: boolean;
	Cutoff: number;
	GainDb: number;
	clone() : SubmixEffectDynamicProcessorFilterSettings;
	static C(Other: UObject | any): SubmixEffectDynamicProcessorFilterSettings;
}

declare class SubmixEffectDynamicsProcessorSettings { 
	DynamicsProcessorType: ESubmixEffectDynamicsProcessorType;
	PeakMode: ESubmixEffectDynamicsPeakMode;
	LinkMode: ESubmixEffectDynamicsChannelLinkMode;
	InputGainDb: number;
	ThresholdDb: number;
	Ratio: number;
	KneeBandwidthDb: number;
	LookAheadMsec: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	KeySource: ESubmixEffectDynamicsKeySource;
	ExternalAudioBus: AudioBus;
	ExternalSubmix: SoundSubmix;
	bChannelLinked: boolean;
	bAnalogMode: boolean;
	bBypass: boolean;
	bKeyAudition: boolean;
	KeyGainDb: number;
	OutputGainDb: number;
	KeyHighshelf: SubmixEffectDynamicProcessorFilterSettings;
	KeyLowshelf: SubmixEffectDynamicProcessorFilterSettings;
	clone() : SubmixEffectDynamicsProcessorSettings;
	static C(Other: UObject | any): SubmixEffectDynamicsProcessorSettings;
}

declare class SubmixEffectDynamicsProcessorPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectDynamicsProcessorSettings;
	static Load(ResourceName: string): SubmixEffectDynamicsProcessorPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectDynamicsProcessorPreset;
	static GetDefaultObject(): SubmixEffectDynamicsProcessorPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectDynamicsProcessorPreset;
	SetSettings(Settings: SubmixEffectDynamicsProcessorSettings): void;
	SetExternalSubmix(Submix: SoundSubmix): void;
	SetAudioBus(AudioBus: AudioBus): void;
	ResetKey(): void;
	static C(Other: UObject | any): SubmixEffectDynamicsProcessorPreset;
}

declare class SubmixEffectEQBand { 
	Frequency: number;
	Bandwidth: number;
	GainDb: number;
	bEnabled: boolean;
	clone() : SubmixEffectEQBand;
	static C(Other: UObject | any): SubmixEffectEQBand;
}

declare class SubmixEffectSubmixEQSettings { 
	EQBands: SubmixEffectEQBand[];
	clone() : SubmixEffectSubmixEQSettings;
	static C(Other: UObject | any): SubmixEffectSubmixEQSettings;
}

declare class SubmixEffectSubmixEQPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectSubmixEQSettings;
	static Load(ResourceName: string): SubmixEffectSubmixEQPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectSubmixEQPreset;
	static GetDefaultObject(): SubmixEffectSubmixEQPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectSubmixEQPreset;
	SetSettings(InSettings: SubmixEffectSubmixEQSettings): void;
	static C(Other: UObject | any): SubmixEffectSubmixEQPreset;
}

declare class SubmixEffectReverbSettings { 
	bBypassEarlyReflections: boolean;
	ReflectionsDelay: number;
	GainHF: number;
	ReflectionsGain: number;
	bBypassLateReflections: boolean;
	LateDelay: number;
	DecayTime: number;
	Density: number;
	Diffusion: number;
	AirAbsorptionGainHF: number;
	DecayHFRatio: number;
	LateGain: number;
	Gain: number;
	WetLevel: number;
	DryLevel: number;
	bBypass: boolean;
	clone() : SubmixEffectReverbSettings;
	static C(Other: UObject | any): SubmixEffectReverbSettings;
}

declare class SubmixEffectReverbPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectReverbSettings;
	static Load(ResourceName: string): SubmixEffectReverbPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectReverbPreset;
	static GetDefaultObject(): SubmixEffectReverbPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectReverbPreset;
	SetSettingsWithReverbEffect(InReverbEffect: ReverbEffect,WetLevel: number,DryLevel: number): void;
	SetSettings(InSettings: SubmixEffectReverbSettings): void;
	static C(Other: UObject | any): SubmixEffectReverbPreset;
}

declare class TickableWorldSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): TickableWorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): TickableWorldSubsystem;
	static GetDefaultObject(): TickableWorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableWorldSubsystem;
	static C(Other: UObject | any): TickableWorldSubsystem;
}

declare type EQuartzTimeSignatureQuantization = 'HalfNote' | 'QuarterNote' | 'EighthNote' | 'SixteenthNote' | 'ThirtySecondNote' | 'Count' | 'EQuartzTimeSignatureQuantization_MAX';
declare var EQuartzTimeSignatureQuantization : { HalfNote:'HalfNote',QuarterNote:'QuarterNote',EighthNote:'EighthNote',SixteenthNote:'SixteenthNote',ThirtySecondNote:'ThirtySecondNote',Count:'Count',EQuartzTimeSignatureQuantization_MAX:'EQuartzTimeSignatureQuantization_MAX', };
declare class QuartzPulseOverrideStep { 
	NumberOfPulses: number;
	PulseDuration: EQuartzCommandQuantization;
	clone() : QuartzPulseOverrideStep;
	static C(Other: UObject | any): QuartzPulseOverrideStep;
}

declare class QuartzTimeSignature { 
	NumBeats: number;
	BeatType: EQuartzTimeSignatureQuantization;
	OptionalPulseOverride: QuartzPulseOverrideStep[];
	clone() : QuartzTimeSignature;
	static C(Other: UObject | any): QuartzTimeSignature;
}

declare class QuartzClockSettings { 
	TimeSignature: QuartzTimeSignature;
	bIgnoreLevelChange: boolean;
	clone() : QuartzClockSettings;
	static C(Other: UObject | any): QuartzClockSettings;
}

declare class QuartzSubsystem extends TickableWorldSubsystem { 
	static Load(ResourceName: string): QuartzSubsystem;
	static Find(Outer: UObject, ResourceName: string): QuartzSubsystem;
	static GetDefaultObject(): QuartzSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuartzSubsystem;
	IsQuartzEnabled(): boolean;
	IsClockRunning(WorldContextObject: UObject,ClockName: string): boolean;
	GetRoundTripMinLatency(WorldContextObject: UObject): number;
	GetRoundTripMaxLatency(WorldContextObject: UObject): number;
	GetRoundTripAverageLatency(WorldContextObject: UObject): number;
	GetHandleForClock(WorldContextObject: UObject,ClockName: string): QuartzClockHandle;
	GetGameThreadToAudioRenderThreadMinLatency(WorldContextObject: UObject): number;
	GetGameThreadToAudioRenderThreadMaxLatency(WorldContextObject: UObject): number;
	GetGameThreadToAudioRenderThreadAverageLatency(WorldContextObject: UObject): number;
	GetEstimatedClockRunTime(WorldContextObject: UObject,InClockName: string): number;
	GetDurationOfQuantizationTypeInSeconds(WorldContextObject: UObject,ClockName: string,QuantizationType: EQuartzCommandQuantization,Multiplier: number): number;
	GetCurrentClockTimestamp(WorldContextObject: UObject,InClockName: string): QuartzTransportTimeStamp;
	GetAudioRenderThreadToGameThreadMinLatency(): number;
	GetAudioRenderThreadToGameThreadMaxLatency(): number;
	GetAudioRenderThreadToGameThreadAverageLatency(): number;
	DoesClockExist(WorldContextObject: UObject,ClockName: string): boolean;
	DeleteClockByName(WorldContextObject: UObject,ClockName: string): void;
	DeleteClockByHandle(WorldContextObject: UObject,InClockHandle?: QuartzClockHandle): {InClockHandle: QuartzClockHandle};
	CreateNewClock(WorldContextObject: UObject,ClockName: string,InSettings: QuartzClockSettings,bOverrideSettingsIfClockExists: boolean,bUseAudioEngineClockManager: boolean): QuartzClockHandle;
	static C(Other: UObject | any): QuartzSubsystem;
}

declare class SoundWaveProcedural extends SoundWave { 
	static Load(ResourceName: string): SoundWaveProcedural;
	static Find(Outer: UObject, ResourceName: string): SoundWaveProcedural;
	static GetDefaultObject(): SoundWaveProcedural;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWaveProcedural;
	static C(Other: UObject | any): SoundWaveProcedural;
}

declare class SynthComponent extends SceneComponent { 
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bAllowSpatialization: boolean;
	bOverrideAttenuation: boolean;
	bOutputToBusOnly: boolean;
	bEnableBusSends: boolean;
	bEnableBaseSubmix: boolean;
	bEnableSubmixSends: boolean;
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	ConcurrencySettings: SoundConcurrency;
	ConcurrencySet: any;
	SoundClass: SoundClass;
	SourceEffectChain: SoundEffectSourcePresetChain;
	SoundSubmix: SoundSubmixBase;
	SoundSubmixSends: SoundSubmixSendInfo[];
	BusSends: SoundSourceBusSendInfo[];
	PreEffectBusSends: SoundSourceBusSendInfo[];
	bIsUISound: boolean;
	bIsPreviewSound: boolean;
	EnvelopeFollowerAttackTime: number;
	EnvelopeFollowerReleaseTime: number;
	OnAudioEnvelopeValue: UnrealEngineMulticastDelegate<(EnvelopeValue: number) => void>;
	Synth: SynthSound;
	AudioComponent: AudioComponent;
	static Load(ResourceName: string): SynthComponent;
	static Find(Outer: UObject, ResourceName: string): SynthComponent;
	static GetDefaultObject(): SynthComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthComponent;
	Stop(): void;
	Start(): void;
	SetVolumeMultiplier(VolumeMultiplier: number): void;
	SetSubmixSend(Submix: SoundSubmixBase,SendLevel: number): void;
	SetOutputToBusOnly(bInOutputToBusOnly: boolean): void;
	SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;
	SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;
	IsPlaying(): boolean;
	static C(Other: UObject | any): SynthComponent;
}

declare class SynthSound extends SoundWaveProcedural { 
	OwningSynthComponent: SynthComponent;
	static Load(ResourceName: string): SynthSound;
	static Find(Outer: UObject, ResourceName: string): SynthSound;
	static GetDefaultObject(): SynthSound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthSound;
	static C(Other: UObject | any): SynthSound;
}

declare class MediaSource extends UObject { 
	static Load(ResourceName: string): MediaSource;
	static Find(Outer: UObject, ResourceName: string): MediaSource;
	static GetDefaultObject(): MediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSource;
	Validate(): boolean;
	SetMediaOptionString(Key: string,Value: string): void;
	SetMediaOptionInt64(Key: string,Value: any): void;
	SetMediaOptionFloat(Key: string,Value: number): void;
	SetMediaOptionBool(Key: string,Value: boolean): void;
	GetUrl(): string;
	static C(Other: UObject | any): MediaSource;
}

declare class BaseMediaSource extends MediaSource { 
	PlatformPlayerNames: any;
	PlayerName: string;
	static Load(ResourceName: string): BaseMediaSource;
	static Find(Outer: UObject, ResourceName: string): BaseMediaSource;
	static GetDefaultObject(): BaseMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseMediaSource;
	static C(Other: UObject | any): BaseMediaSource;
}

declare class FileMediaSource extends BaseMediaSource { 
	FilePath: string;
	PrecacheFile: boolean;
	static Load(ResourceName: string): FileMediaSource;
	static Find(Outer: UObject, ResourceName: string): FileMediaSource;
	static GetDefaultObject(): FileMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FileMediaSource;
	SetFilePath(Path: string): void;
	static C(Other: UObject | any): FileMediaSource;
}

declare class MediaCaptureDevice { 
	DisplayName: string;
	URL: string;
	clone() : MediaCaptureDevice;
	static C(Other: UObject | any): MediaCaptureDevice;
}

declare class MediaBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MediaBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MediaBlueprintFunctionLibrary;
	static GetDefaultObject(): MediaBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaBlueprintFunctionLibrary;
	static EnumerateWebcamCaptureDevices(OutDevices?: MediaCaptureDevice[],Filter?: number): {OutDevices: MediaCaptureDevice[]};
	static EnumerateVideoCaptureDevices(OutDevices?: MediaCaptureDevice[],Filter?: number): {OutDevices: MediaCaptureDevice[]};
	static EnumerateAudioCaptureDevices(OutDevices?: MediaCaptureDevice[],Filter?: number): {OutDevices: MediaCaptureDevice[]};
	static C(Other: UObject | any): MediaBlueprintFunctionLibrary;
}

declare type MediaTextureOutputFormat = 'MTOF_Default' | 'MTOF_SRGB_LINOUT' | 'MTOF_MAX';
declare var MediaTextureOutputFormat : { MTOF_Default:'MTOF_Default',MTOF_SRGB_LINOUT:'MTOF_SRGB_LINOUT',MTOF_MAX:'MTOF_MAX', };
declare type MediaTextureOrientation = 'MTORI_Original' | 'MTORI_CW90' | 'MTORI_CW180' | 'MTORI_CW270' | 'MTORI_MAX';
declare var MediaTextureOrientation : { MTORI_Original:'MTORI_Original',MTORI_CW90:'MTORI_CW90',MTORI_CW180:'MTORI_CW180',MTORI_CW270:'MTORI_CW270',MTORI_MAX:'MTORI_MAX', };
declare class MediaPlaylist extends UObject { 
	Items: MediaSource[];
	static Load(ResourceName: string): MediaPlaylist;
	static Find(Outer: UObject, ResourceName: string): MediaPlaylist;
	static GetDefaultObject(): MediaPlaylist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlaylist;
	Replace(index: number,Replacement: MediaSource): boolean;
	RemoveAt(index: number): boolean;
	Remove(MediaSource: MediaSource): boolean;
	Num(): number;
	Insert(MediaSource: MediaSource,index: number): void;
	GetRandom(OutIndex?: number): {OutIndex: number, $: MediaSource};
	GetPrevious(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	GetNext(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	Get(index: number): MediaSource;
	AddUrl(URL: string): boolean;
	AddFile(FilePath: string): boolean;
	Add(MediaSource: MediaSource): boolean;
	static C(Other: UObject | any): MediaPlaylist;
}

declare type EMediaPlayerTrack = 'Audio' | 'Caption' | 'Metadata' | 'Script' | 'Subtitle' | 'Text' | 'Video' | 'EMediaPlayerTrack_MAX';
declare var EMediaPlayerTrack : { Audio:'Audio',Caption:'Caption',Metadata:'Metadata',Script:'Script',Subtitle:'Subtitle',Text:'Text',Video:'Video',EMediaPlayerTrack_MAX:'EMediaPlayerTrack_MAX', };
declare class MediaPlayerTrackOptions { 
	Audio: number;
	Caption: number;
	MetaData: number;
	Script: number;
	Subtitle: number;
	text: number;
	Video: number;
	clone() : MediaPlayerTrackOptions;
	static C(Other: UObject | any): MediaPlayerTrackOptions;
}

declare type EMediaPlayerOptionBooleanOverride = 'UseMediaPlayerSetting' | 'Enabled' | 'Disabled' | 'EMediaPlayerOptionBooleanOverride_MAX';
declare var EMediaPlayerOptionBooleanOverride : { UseMediaPlayerSetting:'UseMediaPlayerSetting',Enabled:'Enabled',Disabled:'Disabled',EMediaPlayerOptionBooleanOverride_MAX:'EMediaPlayerOptionBooleanOverride_MAX', };
declare class MediaPlayerOptions { 
	Tracks: MediaPlayerTrackOptions;
	SeekTime: Timespan;
	PlayOnOpen: EMediaPlayerOptionBooleanOverride;
	loop: EMediaPlayerOptionBooleanOverride;
	clone() : MediaPlayerOptions;
	static C(Other: UObject | any): MediaPlayerOptions;
}

declare class MediaTimeStampInfo extends UObject { 
	Time: Timespan;
	SequenceIndex: any;
	static Load(ResourceName: string): MediaTimeStampInfo;
	static Find(Outer: UObject, ResourceName: string): MediaTimeStampInfo;
	static GetDefaultObject(): MediaTimeStampInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaTimeStampInfo;
	static C(Other: UObject | any): MediaTimeStampInfo;
}

declare class MediaPlayer extends UObject { 
	OnEndReached: UnrealEngineMulticastDelegate<() => void>;
	OnMediaClosed: UnrealEngineMulticastDelegate<() => void>;
	OnMediaOpened: UnrealEngineMulticastDelegate<(OpenedUrl: string) => void>;
	OnMediaOpenFailed: UnrealEngineMulticastDelegate<(FailedUrl: string) => void>;
	OnPlaybackResumed: UnrealEngineMulticastDelegate<() => void>;
	OnPlaybackSuspended: UnrealEngineMulticastDelegate<() => void>;
	OnSeekCompleted: UnrealEngineMulticastDelegate<() => void>;
	OnTracksChanged: UnrealEngineMulticastDelegate<() => void>;
	CacheAhead: Timespan;
	CacheBehind: Timespan;
	CacheBehindGame: Timespan;
	NativeAudioOut: boolean;
	PlayOnOpen: boolean;
	Shuffle: boolean;
	loop: boolean;
	Playlist: MediaPlaylist;
	PlaylistIndex: number;
	TimeDelay: Timespan;
	HorizontalFieldOfView: number;
	VerticalFieldOfView: number;
	ViewRotation: Rotator;
	PlayerGuid: Guid;
	AffectedByPIEHandling: boolean;
	static Load(ResourceName: string): MediaPlayer;
	static Find(Outer: UObject, ResourceName: string): MediaPlayer;
	static GetDefaultObject(): MediaPlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlayer;
	SupportsSeeking(): boolean;
	SupportsScrubbing(): boolean;
	SupportsRate(Rate: number,Unthinned: boolean): boolean;
	SetViewRotation(Rotation: Rotator,Absolute: boolean): boolean;
	SetViewField(Horizontal: number,Vertical: number,Absolute: boolean): boolean;
	SetVideoTrackFrameRate(TrackIndex: number,FormatIndex: number,FrameRate: number): boolean;
	SetTrackFormat(TrackType: EMediaPlayerTrack,TrackIndex: number,FormatIndex: number): boolean;
	SetTimeDelay(TimeDelay: Timespan): void;
	SetRate(Rate: number): boolean;
	SetNativeVolume(Volume: number): boolean;
	SetMediaOptions(Options: MediaSource): void;
	SetLooping(Looping: boolean): boolean;
	SetDesiredPlayerName(PlayerName: string): void;
	SetBlockOnTime(Time: Timespan): void;
	SelectTrack(TrackType: EMediaPlayerTrack,TrackIndex: number): boolean;
	Seek(Time: Timespan): boolean;
	Rewind(): boolean;
	Reopen(): boolean;
	Previous(): boolean;
	PlayAndSeek(): void;
	Play(): boolean;
	Pause(): boolean;
	OpenUrl(URL: string): boolean;
	OpenSourceWithOptions(MediaSource: MediaSource,Options: MediaPlayerOptions): boolean;
	OpenSourceLatent(WorldContextObject: UObject,LatentInfo: LatentActionInfo,MediaSource: MediaSource,Options: MediaPlayerOptions,bSuccess?: boolean): {bSuccess: boolean};
	OpenSource(MediaSource: MediaSource): boolean;
	OpenPlaylistIndex(InPlaylist: MediaPlaylist,index: number): boolean;
	OpenPlaylist(InPlaylist: MediaPlaylist): boolean;
	OpenFile(FilePath: string): boolean;
	Next(): boolean;
	IsReady(): boolean;
	IsPreparing(): boolean;
	IsPlaying(): boolean;
	IsPaused(): boolean;
	IsLooping(): boolean;
	IsConnecting(): boolean;
	IsClosed(): boolean;
	IsBuffering(): boolean;
	HasError(): boolean;
	GetViewRotation(): Rotator;
	GetVideoTrackType(TrackIndex: number,FormatIndex: number): string;
	GetVideoTrackFrameRates(TrackIndex: number,FormatIndex: number): FloatRange;
	GetVideoTrackFrameRate(TrackIndex: number,FormatIndex: number): number;
	GetVideoTrackDimensions(TrackIndex: number,FormatIndex: number): IntPoint;
	GetVideoTrackAspectRatio(TrackIndex: number,FormatIndex: number): number;
	GetVerticalFieldOfView(): number;
	GetUrl(): string;
	GetTrackLanguage(TrackType: EMediaPlayerTrack,TrackIndex: number): string;
	GetTrackFormat(TrackType: EMediaPlayerTrack,TrackIndex: number): number;
	GetTrackDisplayName(TrackType: EMediaPlayerTrack,TrackIndex: number): string;
	GetTimeStamp(): MediaTimeStampInfo;
	GetTimeDelay(): Timespan;
	GetTime(): Timespan;
	GetSupportedRates(OutRates?: FloatRange[],Unthinned?: boolean): {OutRates: FloatRange[]};
	GetSelectedTrack(TrackType: EMediaPlayerTrack): number;
	GetRate(): number;
	GetPlaylistIndex(): number;
	GetPlaylist(): MediaPlaylist;
	GetPlayerName(): string;
	GetNumTracks(TrackType: EMediaPlayerTrack): number;
	GetNumTrackFormats(TrackType: EMediaPlayerTrack,TrackIndex: number): number;
	GetMediaName(): string;
	GetHorizontalFieldOfView(): number;
	GetDuration(): Timespan;
	GetDesiredPlayerName(): string;
	GetAudioTrackType(TrackIndex: number,FormatIndex: number): string;
	GetAudioTrackSampleRate(TrackIndex: number,FormatIndex: number): number;
	GetAudioTrackChannels(TrackIndex: number,FormatIndex: number): number;
	Close(): void;
	CanPlayUrl(URL: string): boolean;
	CanPlaySource(MediaSource: MediaSource): boolean;
	CanPause(): boolean;
	static C(Other: UObject | any): MediaPlayer;
}

declare class MediaTexture extends Texture { 
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	AutoClear: boolean;
	ClearColor: LinearColor;
	EnableGenMips: boolean;
	NumMips: number;
	NewStyleOutput: boolean;
	OutputFormat: MediaTextureOutputFormat;
	CurrentAspectRatio: number;
	CurrentOrientation: MediaTextureOrientation;
	MediaPlayer: MediaPlayer;
	static Load(ResourceName: string): MediaTexture;
	static Find(Outer: UObject, ResourceName: string): MediaTexture;
	static GetDefaultObject(): MediaTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaTexture;
	UpdateResource(): void;
	SetMediaPlayer(NewMediaPlayer: MediaPlayer): void;
	GetWidth(): number;
	GetTextureNumMips(): number;
	GetMediaPlayer(): MediaPlayer;
	GetHeight(): number;
	GetAspectRatio(): number;
	static C(Other: UObject | any): MediaTexture;
}

declare class MediaComponent extends ActorComponent { 
	MediaTexture: MediaTexture;
	MediaPlayer: MediaPlayer;
	static Load(ResourceName: string): MediaComponent;
	static Find(Outer: UObject, ResourceName: string): MediaComponent;
	static GetDefaultObject(): MediaComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaComponent;
	GetMediaTexture(): MediaTexture;
	GetMediaPlayer(): MediaPlayer;
	static C(Other: UObject | any): MediaComponent;
}

declare type EMediaSoundChannels = 'Mono' | 'Stereo' | 'Surround' | 'EMediaSoundChannels_MAX';
declare var EMediaSoundChannels : { Mono:'Mono',Stereo:'Stereo',Surround:'Surround',EMediaSoundChannels_MAX:'EMediaSoundChannels_MAX', };
declare type EMediaSoundComponentFFTSize = 'Min_64' | 'Small_256' | 'Medium_512' | 'Large_1024' | 'EMediaSoundComponentFFTSize_MAX';
declare var EMediaSoundComponentFFTSize : { Min_64:'Min_64',Small_256:'Small_256',Medium_512:'Medium_512',Large_1024:'Large_1024',EMediaSoundComponentFFTSize_MAX:'EMediaSoundComponentFFTSize_MAX', };
declare class MediaSoundComponentSpectralData { 
	FrequencyHz: number;
	Magnitude: number;
	clone() : MediaSoundComponentSpectralData;
	static C(Other: UObject | any): MediaSoundComponentSpectralData;
}

declare class MediaSoundComponent extends SynthComponent { 
	Channels: EMediaSoundChannels;
	DynamicRateAdjustment: boolean;
	RateAdjustmentFactor: number;
	RateAdjustmentRange: FloatRange;
	MediaPlayer: MediaPlayer;
	static Load(ResourceName: string): MediaSoundComponent;
	static Find(Outer: UObject, ResourceName: string): MediaSoundComponent;
	static GetDefaultObject(): MediaSoundComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSoundComponent;
	SetSpectralAnalysisSettings(InFrequenciesToAnalyze: number[],InFFTSize: EMediaSoundComponentFFTSize): void;
	SetMediaPlayer(NewMediaPlayer: MediaPlayer): void;
	SetEnvelopeFollowingsettings(AttackTimeMsec: number,ReleaseTimeMsec: number): void;
	SetEnableSpectralAnalysis(bInSpectralAnalysisEnabled: boolean): void;
	SetEnableEnvelopeFollowing(bInEnvelopeFollowing: boolean): void;
	GetSpectralData(): MediaSoundComponentSpectralData[];
	GetNormalizedSpectralData(): MediaSoundComponentSpectralData[];
	GetMediaPlayer(): MediaPlayer;
	GetEnvelopeValue(): number;
	BP_GetAttenuationSettingsToApply(OutAttenuationSettings?: SoundAttenuationSettings): {OutAttenuationSettings: SoundAttenuationSettings, $: boolean};
	static C(Other: UObject | any): MediaSoundComponent;
}

declare class PlatformMediaSource extends MediaSource { 
	PlatformMediaSources: any;
	MediaSource: MediaSource;
	static Load(ResourceName: string): PlatformMediaSource;
	static Find(Outer: UObject, ResourceName: string): PlatformMediaSource;
	static GetDefaultObject(): PlatformMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformMediaSource;
	static C(Other: UObject | any): PlatformMediaSource;
}

declare class StreamMediaSource extends BaseMediaSource { 
	StreamUrl: string;
	static Load(ResourceName: string): StreamMediaSource;
	static Find(Outer: UObject, ResourceName: string): StreamMediaSource;
	static GetDefaultObject(): StreamMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamMediaSource;
	static C(Other: UObject | any): StreamMediaSource;
}

declare class TimeSynchronizableMediaSource extends BaseMediaSource { 
	bUseTimeSynchronization: boolean;
	FrameDelay: number;
	TimeDelay: any;
	static Load(ResourceName: string): TimeSynchronizableMediaSource;
	static Find(Outer: UObject, ResourceName: string): TimeSynchronizableMediaSource;
	static GetDefaultObject(): TimeSynchronizableMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimeSynchronizableMediaSource;
	static C(Other: UObject | any): TimeSynchronizableMediaSource;
}

declare class EngineCustomTimeStep extends UObject { 
	static Load(ResourceName: string): EngineCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): EngineCustomTimeStep;
	static GetDefaultObject(): EngineCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineCustomTimeStep;
	static C(Other: UObject | any): EngineCustomTimeStep;
}

declare class FixedFrameRateCustomTimeStep extends EngineCustomTimeStep { 
	static Load(ResourceName: string): FixedFrameRateCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): FixedFrameRateCustomTimeStep;
	static GetDefaultObject(): FixedFrameRateCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FixedFrameRateCustomTimeStep;
	static C(Other: UObject | any): FixedFrameRateCustomTimeStep;
}

declare class GenlockedCustomTimeStep extends FixedFrameRateCustomTimeStep { 
	static Load(ResourceName: string): GenlockedCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): GenlockedCustomTimeStep;
	static GetDefaultObject(): GenlockedCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenlockedCustomTimeStep;
	static C(Other: UObject | any): GenlockedCustomTimeStep;
}

declare class GenlockedFixedRateCustomTimeStep extends GenlockedCustomTimeStep { 
	FrameRate: FrameRate;
	static Load(ResourceName: string): GenlockedFixedRateCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): GenlockedFixedRateCustomTimeStep;
	static GetDefaultObject(): GenlockedFixedRateCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenlockedFixedRateCustomTimeStep;
	static C(Other: UObject | any): GenlockedFixedRateCustomTimeStep;
}

declare type ETimecodeProviderSynchronizationState = 'Closed' | 'Error' | 'Synchronized' | 'Synchronizing' | 'ETimecodeProviderSynchronizationState_MAX';
declare var ETimecodeProviderSynchronizationState : { Closed:'Closed',Error:'Error',Synchronized:'Synchronized',Synchronizing:'Synchronizing',ETimecodeProviderSynchronizationState_MAX:'ETimecodeProviderSynchronizationState_MAX', };
declare class TimecodeProvider extends UObject { 
	FrameDelay: number;
	static Load(ResourceName: string): TimecodeProvider;
	static Find(Outer: UObject, ResourceName: string): TimecodeProvider;
	static GetDefaultObject(): TimecodeProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimecodeProvider;
	GetTimecode(): Timecode;
	GetSynchronizationState(): ETimecodeProviderSynchronizationState;
	GetQualifiedFrameTime(): QualifiedFrameTime;
	GetFrameRate(): FrameRate;
	GetDelayedTimecode(): Timecode;
	GetDelayedQualifiedFrameTime(): QualifiedFrameTime;
	FetchTimecode(OutFrameTime?: QualifiedFrameTime): {OutFrameTime: QualifiedFrameTime, $: boolean};
	FetchAndUpdate(): void;
	static C(Other: UObject | any): TimecodeProvider;
}

declare class GenlockedTimecodeProvider extends TimecodeProvider { 
	bUseGenlockToCount: boolean;
	static Load(ResourceName: string): GenlockedTimecodeProvider;
	static Find(Outer: UObject, ResourceName: string): GenlockedTimecodeProvider;
	static GetDefaultObject(): GenlockedTimecodeProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenlockedTimecodeProvider;
	static C(Other: UObject | any): GenlockedTimecodeProvider;
}

declare class TimeManagementBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): TimeManagementBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TimeManagementBlueprintLibrary;
	static GetDefaultObject(): TimeManagementBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimeManagementBlueprintLibrary;
	static TransformTime(SourceTime: FrameTime,SourceRate: FrameRate,DestinationRate: FrameRate): FrameTime;
	static Subtract_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Subtract_FrameNumberFrameNumber(A: FrameNumber,B: FrameNumber): FrameNumber;
	static SnapFrameTimeToRate(SourceTime: FrameTime,SourceRate: FrameRate,SnapToRate: FrameRate): FrameTime;
	static Multiply_SecondsFrameRate(TimeInSeconds: number,FrameRate: FrameRate): FrameTime;
	static Multiply_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static IsValid_MultipleOf(InFrameRate: FrameRate,OtherFramerate: FrameRate): boolean;
	static IsValid_Framerate(InFrameRate: FrameRate): boolean;
	static GetTimecodeFrameRate(): FrameRate;
	static GetTimecode(): Timecode;
	static Divide_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Conv_TimecodeToString(InTimecode: Timecode,bForceSignDisplay: boolean): string;
	static Conv_QualifiedFrameTimeToSeconds(InFrameTime: QualifiedFrameTime): number;
	static Conv_FrameRateToSeconds(InFrameRate: FrameRate): number;
	static Conv_FrameNumberToInteger(InFrameNumber: FrameNumber): number;
	static Add_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Add_FrameNumberFrameNumber(A: FrameNumber,B: FrameNumber): FrameNumber;
	static C(Other: UObject | any): TimeManagementBlueprintLibrary;
}

declare class TimeSynchronizationSource extends UObject { 
	bUseForSynchronization: boolean;
	FrameOffset: number;
	static Load(ResourceName: string): TimeSynchronizationSource;
	static Find(Outer: UObject, ResourceName: string): TimeSynchronizationSource;
	static GetDefaultObject(): TimeSynchronizationSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimeSynchronizationSource;
	static C(Other: UObject | any): TimeSynchronizationSource;
}

declare class MovieSceneCustomClockSource extends Interface { 
	static Load(ResourceName: string): MovieSceneCustomClockSource;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCustomClockSource;
	static GetDefaultObject(): MovieSceneCustomClockSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCustomClockSource;
	OnTick(DeltaSeconds: number,InPlayRate: number): void;
	OnStopPlaying(InStopTime: QualifiedFrameTime): void;
	OnStartPlaying(InStartTime: QualifiedFrameTime): void;
	OnRequestCurrentTime(InCurrentTime: QualifiedFrameTime,InPlayRate: number): FrameTime;
	static C(Other: UObject | any): MovieSceneCustomClockSource;
}

declare class MovieSceneDeterminismSource extends Interface { 
	static Load(ResourceName: string): MovieSceneDeterminismSource;
	static Find(Outer: UObject, ResourceName: string): MovieSceneDeterminismSource;
	static GetDefaultObject(): MovieSceneDeterminismSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneDeterminismSource;
	static C(Other: UObject | any): MovieSceneDeterminismSource;
}

declare class MovieSceneEntityProvider extends Interface { 
	static Load(ResourceName: string): MovieSceneEntityProvider;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntityProvider;
	static GetDefaultObject(): MovieSceneEntityProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntityProvider;
	static C(Other: UObject | any): MovieSceneEntityProvider;
}

declare class MovieSceneEvaluationHook extends Interface { 
	static Load(ResourceName: string): MovieSceneEvaluationHook;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEvaluationHook;
	static GetDefaultObject(): MovieSceneEvaluationHook;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEvaluationHook;
	static C(Other: UObject | any): MovieSceneEvaluationHook;
}

declare class MovieScenePlaybackClient extends Interface { 
	static Load(ResourceName: string): MovieScenePlaybackClient;
	static Find(Outer: UObject, ResourceName: string): MovieScenePlaybackClient;
	static GetDefaultObject(): MovieScenePlaybackClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePlaybackClient;
	static C(Other: UObject | any): MovieScenePlaybackClient;
}

declare class MovieSceneTrackTemplateProducer extends Interface { 
	static Load(ResourceName: string): MovieSceneTrackTemplateProducer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackTemplateProducer;
	static GetDefaultObject(): MovieSceneTrackTemplateProducer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackTemplateProducer;
	static C(Other: UObject | any): MovieSceneTrackTemplateProducer;
}

declare class NodeAndChannelMappings extends Interface { 
	static Load(ResourceName: string): NodeAndChannelMappings;
	static Find(Outer: UObject, ResourceName: string): NodeAndChannelMappings;
	static GetDefaultObject(): NodeAndChannelMappings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeAndChannelMappings;
	static C(Other: UObject | any): NodeAndChannelMappings;
}

declare class MovieSceneBindingOverrideData { 
	ObjectBindingId: MovieSceneObjectBindingID;
	UObject: UObject;
	bOverridesDefault: boolean;
	clone() : MovieSceneBindingOverrideData;
	static C(Other: UObject | any): MovieSceneBindingOverrideData;
}

declare class MovieSceneBindingOverrides extends UObject { 
	BindingData: MovieSceneBindingOverrideData[];
	static Load(ResourceName: string): MovieSceneBindingOverrides;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBindingOverrides;
	static GetDefaultObject(): MovieSceneBindingOverrides;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBindingOverrides;
	static C(Other: UObject | any): MovieSceneBindingOverrides;
}

declare class MovieSceneBindingOwnerInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneBindingOwnerInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBindingOwnerInterface;
	static GetDefaultObject(): MovieSceneBindingOwnerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBindingOwnerInterface;
	static C(Other: UObject | any): MovieSceneBindingOwnerInterface;
}

declare class MovieSceneEntitySystem extends UObject { 
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): MovieSceneEntitySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntitySystem;
	static GetDefaultObject(): MovieSceneEntitySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntitySystem;
	static C(Other: UObject | any): MovieSceneEntitySystem;
}

declare class MovieSceneBlenderSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneBlenderSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBlenderSystem;
	static GetDefaultObject(): MovieSceneBlenderSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBlenderSystem;
	static C(Other: UObject | any): MovieSceneBlenderSystem;
}

declare class MovieSceneBoolSection extends MovieSceneSection { 
	DefaultValue: boolean;
	BoolCurve: MovieSceneBoolChannel;
	bIsExternallyInverted: boolean;
	static Load(ResourceName: string): MovieSceneBoolSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBoolSection;
	static GetDefaultObject(): MovieSceneBoolSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBoolSection;
	static C(Other: UObject | any): MovieSceneBoolSection;
}

declare class MovieSceneEntityInstantiatorSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static GetDefaultObject(): MovieSceneEntityInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntityInstantiatorSystem;
	static C(Other: UObject | any): MovieSceneEntityInstantiatorSystem;
}

declare class MovieSceneGenericBoundObjectInstantiator extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneGenericBoundObjectInstantiator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGenericBoundObjectInstantiator;
	static GetDefaultObject(): MovieSceneGenericBoundObjectInstantiator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGenericBoundObjectInstantiator;
	static C(Other: UObject | any): MovieSceneGenericBoundObjectInstantiator;
}

declare class MovieSceneBoundSceneComponentInstantiator extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneBoundSceneComponentInstantiator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBoundSceneComponentInstantiator;
	static GetDefaultObject(): MovieSceneBoundSceneComponentInstantiator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBoundSceneComponentInstantiator;
	static C(Other: UObject | any): MovieSceneBoundSceneComponentInstantiator;
}

declare class MovieSceneSceneComponentImpersonator extends Interface { 
	static Load(ResourceName: string): MovieSceneSceneComponentImpersonator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSceneComponentImpersonator;
	static GetDefaultObject(): MovieSceneSceneComponentImpersonator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSceneComponentImpersonator;
	static C(Other: UObject | any): MovieSceneSceneComponentImpersonator;
}

declare class MovieSceneValueDecomposer extends Interface { 
	static Load(ResourceName: string): MovieSceneValueDecomposer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneValueDecomposer;
	static GetDefaultObject(): MovieSceneValueDecomposer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneValueDecomposer;
	static C(Other: UObject | any): MovieSceneValueDecomposer;
}

declare type EMovieSceneBuiltInEasing = 'Linear' | 'SinIn' | 'SinOut' | 'SinInOut' | 'QuadIn' | 'QuadOut' | 'QuadInOut' | 'CubicIn' | 'CubicOut' | 'CubicInOut' | 'QuartIn' | 'QuartOut' | 'QuartInOut' | 'QuintIn' | 'QuintOut' | 'QuintInOut' | 'ExpoIn' | 'ExpoOut' | 'ExpoInOut' | 'CircIn' | 'CircOut' | 'CircInOut' | 'EMovieSceneBuiltInEasing_MAX';
declare var EMovieSceneBuiltInEasing : { Linear:'Linear',SinIn:'SinIn',SinOut:'SinOut',SinInOut:'SinInOut',QuadIn:'QuadIn',QuadOut:'QuadOut',QuadInOut:'QuadInOut',CubicIn:'CubicIn',CubicOut:'CubicOut',CubicInOut:'CubicInOut',QuartIn:'QuartIn',QuartOut:'QuartOut',QuartInOut:'QuartInOut',QuintIn:'QuintIn',QuintOut:'QuintOut',QuintInOut:'QuintInOut',ExpoIn:'ExpoIn',ExpoOut:'ExpoOut',ExpoInOut:'ExpoInOut',CircIn:'CircIn',CircOut:'CircOut',CircInOut:'CircInOut',EMovieSceneBuiltInEasing_MAX:'EMovieSceneBuiltInEasing_MAX', };
declare class MovieSceneBuiltInEasingFunction extends UObject { 
	Type: EMovieSceneBuiltInEasing;
	static Load(ResourceName: string): MovieSceneBuiltInEasingFunction;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBuiltInEasingFunction;
	static GetDefaultObject(): MovieSceneBuiltInEasingFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBuiltInEasingFunction;
	static C(Other: UObject | any): MovieSceneBuiltInEasingFunction;
}

declare class MovieSceneEasingExternalCurve extends UObject { 
	Curve: CurveFloat;
	static Load(ResourceName: string): MovieSceneEasingExternalCurve;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEasingExternalCurve;
	static GetDefaultObject(): MovieSceneEasingExternalCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEasingExternalCurve;
	static C(Other: UObject | any): MovieSceneEasingExternalCurve;
}

declare class MovieSceneEasingFunction extends Interface { 
	static Load(ResourceName: string): MovieSceneEasingFunction;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEasingFunction;
	static GetDefaultObject(): MovieSceneEasingFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEasingFunction;
	OnEvaluate(Interp: number): number;
	static C(Other: UObject | any): MovieSceneEasingFunction;
}

declare class MovieSceneEvalTimeSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneEvalTimeSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEvalTimeSystem;
	static GetDefaultObject(): MovieSceneEvalTimeSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEvalTimeSystem;
	static C(Other: UObject | any): MovieSceneEvalTimeSystem;
}

declare class MovieSceneEvaluationHookSystem extends MovieSceneEntitySystem { 
	PendingEventsByRootInstance: any;
	static Load(ResourceName: string): MovieSceneEvaluationHookSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEvaluationHookSystem;
	static GetDefaultObject(): MovieSceneEvaluationHookSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEvaluationHookSystem;
	static C(Other: UObject | any): MovieSceneEvaluationHookSystem;
}

declare class MovieSceneHookSection extends MovieSceneSection { 
	bRequiresRangedHook: boolean;
	bRequiresTriggerHooks: boolean;
	static Load(ResourceName: string): MovieSceneHookSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneHookSection;
	static GetDefaultObject(): MovieSceneHookSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneHookSection;
	static C(Other: UObject | any): MovieSceneHookSection;
}

declare class MovieSceneKeyProxy extends Interface { 
	static Load(ResourceName: string): MovieSceneKeyProxy;
	static Find(Outer: UObject, ResourceName: string): MovieSceneKeyProxy;
	static GetDefaultObject(): MovieSceneKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneKeyProxy;
	static C(Other: UObject | any): MovieSceneKeyProxy;
}

declare class MovieSceneMasterInstantiatorSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneMasterInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMasterInstantiatorSystem;
	static GetDefaultObject(): MovieSceneMasterInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMasterInstantiatorSystem;
	static C(Other: UObject | any): MovieSceneMasterInstantiatorSystem;
}

declare class MovieScenePreAnimatedStateSystemInterface extends Interface { 
	static Load(ResourceName: string): MovieScenePreAnimatedStateSystemInterface;
	static Find(Outer: UObject, ResourceName: string): MovieScenePreAnimatedStateSystemInterface;
	static GetDefaultObject(): MovieScenePreAnimatedStateSystemInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePreAnimatedStateSystemInterface;
	static C(Other: UObject | any): MovieScenePreAnimatedStateSystemInterface;
}

declare class MovieSceneCachePreAnimatedStateSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneCachePreAnimatedStateSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCachePreAnimatedStateSystem;
	static GetDefaultObject(): MovieSceneCachePreAnimatedStateSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCachePreAnimatedStateSystem;
	static C(Other: UObject | any): MovieSceneCachePreAnimatedStateSystem;
}

declare class MovieSceneRestorePreAnimatedStateSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneRestorePreAnimatedStateSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneRestorePreAnimatedStateSystem;
	static GetDefaultObject(): MovieSceneRestorePreAnimatedStateSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneRestorePreAnimatedStateSystem;
	static C(Other: UObject | any): MovieSceneRestorePreAnimatedStateSystem;
}

declare type EMovieScenePlayerStatus = 'Stopped' | 'Playing' | 'Scrubbing' | 'Jumping' | 'Stepping' | 'Paused' | 'MAX';
declare var EMovieScenePlayerStatus : { Stopped:'Stopped',Playing:'Playing',Scrubbing:'Scrubbing',Jumping:'Jumping',Stepping:'Stepping',Paused:'Paused',MAX:'MAX', };
declare class MovieSceneSequenceLoopCount { 
	Value: number;
	clone() : MovieSceneSequenceLoopCount;
	static C(Other: UObject | any): MovieSceneSequenceLoopCount;
}

declare class MovieSceneSequencePlaybackSettings { 
	bAutoPlay: boolean;
	LoopCount: MovieSceneSequenceLoopCount;
	PlayRate: number;
	StartTime: number;
	bRandomStartTime: boolean;
	bRestoreState: boolean;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	bDisableCameraCuts: boolean;
	bPauseAtEnd: boolean;
	clone() : MovieSceneSequencePlaybackSettings;
	static C(Other: UObject | any): MovieSceneSequencePlaybackSettings;
}

declare class MovieSceneSequenceReplProperties { 
	LastKnownPosition: FrameTime;
	LastKnownStatus: EMovieScenePlayerStatus;
	LastKnownNumLoops: number;
	clone() : MovieSceneSequenceReplProperties;
	static C(Other: UObject | any): MovieSceneSequenceReplProperties;
}

declare class MovieSceneSequenceActorPointers { 
	SequenceActor: Actor;
	SequenceActorInterface: any;
	clone() : MovieSceneSequenceActorPointers;
	static C(Other: UObject | any): MovieSceneSequenceActorPointers;
}

declare class MovieSceneSequenceTickManager extends UObject { 
	SequenceActors: MovieSceneSequenceActorPointers[];
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): MovieSceneSequenceTickManager;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequenceTickManager;
	static GetDefaultObject(): MovieSceneSequenceTickManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequenceTickManager;
	static C(Other: UObject | any): MovieSceneSequenceTickManager;
}

declare type EMovieScenePositionType = 'Frame' | 'Time' | 'MarkedFrame' | 'EMovieScenePositionType_MAX';
declare var EMovieScenePositionType : { Frame:'Frame',Time:'Time',MarkedFrame:'MarkedFrame',EMovieScenePositionType_MAX:'EMovieScenePositionType_MAX', };
declare type EUpdatePositionMethod = 'Play' | 'Jump' | 'Scrub' | 'EUpdatePositionMethod_MAX';
declare var EUpdatePositionMethod : { Play:'Play',Jump:'Jump',Scrub:'Scrub',EUpdatePositionMethod_MAX:'EUpdatePositionMethod_MAX', };
declare class MovieSceneSequencePlaybackParams { 
	Frame: FrameTime;
	Time: number;
	MarkedFrame: string;
	PositionType: EMovieScenePositionType;
	UpdateMethod: EUpdatePositionMethod;
	bHasJumped: boolean;
	clone() : MovieSceneSequencePlaybackParams;
	static C(Other: UObject | any): MovieSceneSequencePlaybackParams;
	PlayTo(): void;
	static PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams): void;
}

declare class MovieSceneSequencePlayToParams { 
	bExclusive: boolean;
	clone() : MovieSceneSequencePlayToParams;
	static C(Other: UObject | any): MovieSceneSequencePlayToParams;
}

declare class MovieSceneSequencePlayer extends UObject { 
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	OnPlayReverse: UnrealEngineMulticastDelegate<() => void>;
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	OnFinished: UnrealEngineMulticastDelegate<() => void>;
	Status: EMovieScenePlayerStatus;
	bReversePlayback: boolean;
	Sequence: MovieSceneSequence;
	StartTime: FrameNumber;
	DurationFrames: number;
	DurationSubFrames: number;
	CurrentNumLoops: number;
	PlaybackSettings: MovieSceneSequencePlaybackSettings;
	RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
	NetSyncProps: MovieSceneSequenceReplProperties;
	PlaybackClient: any;
	TickManager: MovieSceneSequenceTickManager;
	static Load(ResourceName: string): MovieSceneSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequencePlayer;
	static GetDefaultObject(): MovieSceneSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequencePlayer;
	StopAtCurrentTime(): void;
	Stop(): void;
	SetTimeRange(StartTime: number,Duration: number): void;
	SetPlayRate(PlayRate: number): void;
	SetPlaybackPosition(PlaybackParams: MovieSceneSequencePlaybackParams): void;
	SetFrameRate(FrameRate: FrameRate): void;
	SetFrameRange(StartFrame: number,Duration: number,SubFrames: number): void;
	SetDisableCameraCuts(bInDisableCameraCuts: boolean): void;
	ScrubToSeconds(TimeInSeconds: number): void;
	ScrubToMarkedFrame(InLabel: string): boolean;
	ScrubToFrame(NewPosition: FrameTime): void;
	Scrub(): void;
	RPC_OnStopEvent(StoppedTime: FrameTime): void;
	RPC_OnFinishPlaybackEvent(StoppedTime: FrameTime): void;
	RPC_ExplicitServerUpdateEvent(Method: EUpdatePositionMethod,RelevantTime: FrameTime): void;
	RestoreState(): void;
	PlayToSeconds(TimeInSeconds: number): void;
	PlayToMarkedFrame(InLabel: string): boolean;
	PlayToFrame(NewPosition: FrameTime): void;
	PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams,PlayToParams: MovieSceneSequencePlayToParams): void;
	PlayReverse(): void;
	PlayLooping(NumLoops: number): void;
	Play(): void;
	Pause(): void;
	JumpToSeconds(TimeInSeconds: number): void;
	JumpToMarkedFrame(InLabel: string): boolean;
	JumpToFrame(NewPosition: FrameTime): void;
	IsReversed(): boolean;
	IsPlaying(): boolean;
	IsPaused(): boolean;
	GoToEndAndStop(): void;
	GetStartTime(): QualifiedFrameTime;
	GetSequenceName(bAddClientInfo: boolean): string;
	GetSequence(): MovieSceneSequence;
	GetPlayRate(): number;
	GetObjectBindings(InObject: UObject): MovieSceneObjectBindingID[];
	GetFrameRate(): FrameRate;
	GetFrameDuration(): number;
	GetEndTime(): QualifiedFrameTime;
	GetDuration(): QualifiedFrameTime;
	GetDisableCameraCuts(): boolean;
	GetCurrentTime(): QualifiedFrameTime;
	GetBoundObjects(ObjectBinding: MovieSceneObjectBindingID): UObject[];
	ChangePlaybackDirection(): void;
	static C(Other: UObject | any): MovieSceneSequencePlayer;
}

declare class MovieSceneSequenceActor extends Interface { 
	static Load(ResourceName: string): MovieSceneSequenceActor;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequenceActor;
	static GetDefaultObject(): MovieSceneSequenceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequenceActor;
	static C(Other: UObject | any): MovieSceneSequenceActor;
}

declare class MovieSceneSpawnablesSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneSpawnablesSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSpawnablesSystem;
	static GetDefaultObject(): MovieSceneSpawnablesSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSpawnablesSystem;
	static C(Other: UObject | any): MovieSceneSpawnablesSystem;
}

declare class MovieSceneSpawnSection extends MovieSceneBoolSection { 
	static Load(ResourceName: string): MovieSceneSpawnSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSpawnSection;
	static GetDefaultObject(): MovieSceneSpawnSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSpawnSection;
	static C(Other: UObject | any): MovieSceneSpawnSection;
}

declare class MovieSceneSpawnTrack extends MovieSceneTrack { 
	Sections: MovieSceneSection[];
	ObjectGuid: Guid;
	static Load(ResourceName: string): MovieSceneSpawnTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSpawnTrack;
	static GetDefaultObject(): MovieSceneSpawnTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSpawnTrack;
	static C(Other: UObject | any): MovieSceneSpawnTrack;
}

declare class MovieSceneSectionParameters { 
	StartFrameOffset: FrameNumber;
	bCanLoop: boolean;
	EndFrameOffset: FrameNumber;
	FirstLoopStartFrameOffset: FrameNumber;
	TimeScale: number;
	HierarchicalBias: number;
	StartOffset: number;
	PrerollTime: number;
	PostrollTime: number;
	clone() : MovieSceneSectionParameters;
	static C(Other: UObject | any): MovieSceneSectionParameters;
}

declare class MovieSceneSubSection extends MovieSceneSection { 
	Parameters: MovieSceneSectionParameters;
	StartOffset: number;
	TimeScale: number;
	PrerollTime: number;
	NetworkMask: number;
	SubSequence: MovieSceneSequence;
	static Load(ResourceName: string): MovieSceneSubSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSubSection;
	static GetDefaultObject(): MovieSceneSubSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSubSection;
	SetSequence(Sequence: MovieSceneSequence): void;
	GetSequence(): MovieSceneSequence;
	static C(Other: UObject | any): MovieSceneSubSection;
	GetParentSequenceFrame(InFrame: number,ParentSequence: MovieSceneSequence): number;
	static GetParentSequenceFrame(Section: MovieSceneSubSection,InFrame: number,ParentSequence: MovieSceneSequence): number;
}

declare class MovieSceneSubTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneSubTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSubTrack;
	static GetDefaultObject(): MovieSceneSubTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSubTrack;
	static C(Other: UObject | any): MovieSceneSubTrack;
}

declare class TestMovieSceneTrack extends MovieSceneTrack { 
	bHighPassFilter: boolean;
	SectionArray: MovieSceneSection[];
	static Load(ResourceName: string): TestMovieSceneTrack;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneTrack;
	static GetDefaultObject(): TestMovieSceneTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneTrack;
	static C(Other: UObject | any): TestMovieSceneTrack;
}

declare class TestMovieSceneSection extends MovieSceneSection { 
	static Load(ResourceName: string): TestMovieSceneSection;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSection;
	static GetDefaultObject(): TestMovieSceneSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSection;
	static C(Other: UObject | any): TestMovieSceneSection;
}

declare class TestMovieSceneSequence extends MovieSceneSequence { 
	MovieScene: MovieScene;
	static Load(ResourceName: string): TestMovieSceneSequence;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSequence;
	static GetDefaultObject(): TestMovieSceneSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSequence;
	static C(Other: UObject | any): TestMovieSceneSequence;
}

declare class TestMovieSceneSubTrack extends MovieSceneSubTrack { 
	SectionArray: MovieSceneSection[];
	static Load(ResourceName: string): TestMovieSceneSubTrack;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSubTrack;
	static GetDefaultObject(): TestMovieSceneSubTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSubTrack;
	static C(Other: UObject | any): TestMovieSceneSubTrack;
}

declare class TestMovieSceneSubSection extends MovieSceneSubSection { 
	static Load(ResourceName: string): TestMovieSceneSubSection;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSubSection;
	static GetDefaultObject(): TestMovieSceneSubSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSubSection;
	static C(Other: UObject | any): TestMovieSceneSubSection;
}

declare class TestMovieSceneEvalHookTrack extends MovieSceneTrack { 
	SectionArray: MovieSceneSection[];
	static Load(ResourceName: string): TestMovieSceneEvalHookTrack;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneEvalHookTrack;
	static GetDefaultObject(): TestMovieSceneEvalHookTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneEvalHookTrack;
	static C(Other: UObject | any): TestMovieSceneEvalHookTrack;
}

declare class TestMovieSceneEvalHookSection extends MovieSceneHookSection { 
	static Load(ResourceName: string): TestMovieSceneEvalHookSection;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneEvalHookSection;
	static GetDefaultObject(): TestMovieSceneEvalHookSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneEvalHookSection;
	static C(Other: UObject | any): TestMovieSceneEvalHookSection;
}

declare class MovieSceneTrackInstanceInput { 
	Section: MovieSceneSection;
	clone() : MovieSceneTrackInstanceInput;
	static C(Other: UObject | any): MovieSceneTrackInstanceInput;
}

declare class MovieSceneTrackInstance extends UObject { 
	AnimatedObject: UObject;
	bIsMasterTrackInstance: boolean;
	PrivateLinker: MovieSceneEntitySystemLinker;
	Inputs: MovieSceneTrackInstanceInput[];
	static Load(ResourceName: string): MovieSceneTrackInstance;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackInstance;
	static GetDefaultObject(): MovieSceneTrackInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackInstance;
	static C(Other: UObject | any): MovieSceneTrackInstance;
}

declare class MovieSceneTrackInstanceInstantiator extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneTrackInstanceInstantiator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackInstanceInstantiator;
	static GetDefaultObject(): MovieSceneTrackInstanceInstantiator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackInstanceInstantiator;
	static C(Other: UObject | any): MovieSceneTrackInstanceInstantiator;
}

declare class MovieSceneTrackInstanceSystem extends MovieSceneEntitySystem { 
	Instantiator: MovieSceneTrackInstanceInstantiator;
	static Load(ResourceName: string): MovieSceneTrackInstanceSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackInstanceSystem;
	static GetDefaultObject(): MovieSceneTrackInstanceSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackInstanceSystem;
	static C(Other: UObject | any): MovieSceneTrackInstanceSystem;
}

declare class ChaosPhysicalMaterial extends UObject { 
	Friction: number;
	StaticFriction: number;
	Restitution: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	SleepingLinearVelocityThreshold: number;
	SleepingAngularVelocityThreshold: number;
	static Load(ResourceName: string): ChaosPhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): ChaosPhysicalMaterial;
	static GetDefaultObject(): ChaosPhysicalMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosPhysicalMaterial;
	static C(Other: UObject | any): ChaosPhysicalMaterial;
}

declare type EClusterUnionMethod = 'PointImplicit' | 'DelaunayTriangulation' | 'MinimalSpanningSubsetDelaunayTriangulation' | 'PointImplicitAugmentedWithMinimalDelaunay' | 'None' | 'EClusterUnionMethod_MAX';
declare var EClusterUnionMethod : { PointImplicit:'PointImplicit',DelaunayTriangulation:'DelaunayTriangulation',MinimalSpanningSubsetDelaunayTriangulation:'MinimalSpanningSubsetDelaunayTriangulation',PointImplicitAugmentedWithMinimalDelaunay:'PointImplicitAugmentedWithMinimalDelaunay',None:'None',EClusterUnionMethod_MAX:'EClusterUnionMethod_MAX', };
declare class SolverCollisionFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	clone() : SolverCollisionFilterSettings;
	static C(Other: UObject | any): SolverCollisionFilterSettings;
}

declare class SolverBreakingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverBreakingFilterSettings;
	static C(Other: UObject | any): SolverBreakingFilterSettings;
}

declare class SolverTrailingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverTrailingFilterSettings;
	static C(Other: UObject | any): SolverTrailingFilterSettings;
}

declare class ChaosSolverConfiguration { 
	Iterations: number;
	CollisionPairIterations: number;
	PushOutIterations: number;
	CollisionPushOutPairIterations: number;
	CollisionMarginFraction: number;
	CollisionMarginMax: number;
	CollisionCullDistance: number;
	CollisionMaxPushOutVelocity: number;
	JointPairIterations: number;
	JointPushOutPairIterations: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterUnionMethod;
	bGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	bGenerateBreakData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	bGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	bGenerateContactGraph: boolean;
	clone() : ChaosSolverConfiguration;
	static C(Other: UObject | any): ChaosSolverConfiguration;
}

declare class PhysicsSettingsCore extends DeveloperSettings { 
	DefaultGravityZ: number;
	DefaultTerminalVelocity: number;
	DefaultFluidFriction: number;
	SimulateScratchMemorySize: number;
	RagdollAggregateThreshold: number;
	TriangleMeshTriangleMinAreaThreshold: number;
	bEnableShapeSharing: boolean;
	bEnablePCM: boolean;
	bEnableStabilization: boolean;
	bWarnMissingLocks: boolean;
	bEnable2DPhysics: boolean;
	bDefaultHasComplexCollision: boolean;
	BounceThresholdVelocity: number;
	FrictionCombineMode: EFrictionCombineMode;
	RestitutionCombineMode: EFrictionCombineMode;
	MaxAngularVelocity: number;
	MaxDepenetrationVelocity: number;
	ContactOffsetMultiplier: number;
	MinContactOffset: number;
	MaxContactOffset: number;
	bSimulateSkeletalMeshOnDedicatedServer: boolean;
	DefaultShapeComplexity: ECollisionTraceFlag;
	SolverOptions: ChaosSolverConfiguration;
	static Load(ResourceName: string): PhysicsSettingsCore;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettingsCore;
	static GetDefaultObject(): PhysicsSettingsCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettingsCore;
	static C(Other: UObject | any): PhysicsSettingsCore;
}

declare class ChaosDebugDrawComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosDebugDrawComponent;
	static GetDefaultObject(): ChaosDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDebugDrawComponent;
	static C(Other: UObject | any): ChaosDebugDrawComponent;
}

declare class ChaosEventListenerComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosEventListenerComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosEventListenerComponent;
	static GetDefaultObject(): ChaosEventListenerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosEventListenerComponent;
	static C(Other: UObject | any): ChaosEventListenerComponent;
}

declare class ChaosGameplayEventDispatcher extends ChaosEventListenerComponent { 
	CollisionEventRegistrations: any;
	BreakEventRegistrations: any;
	RemovalEventRegistrations: any;
	static Load(ResourceName: string): ChaosGameplayEventDispatcher;
	static Find(Outer: UObject, ResourceName: string): ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosGameplayEventDispatcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosGameplayEventDispatcher;
	static C(Other: UObject | any): ChaosGameplayEventDispatcher;
}

declare class ChaosNotifyHandlerInterface extends Interface { 
	static Load(ResourceName: string): ChaosNotifyHandlerInterface;
	static Find(Outer: UObject, ResourceName: string): ChaosNotifyHandlerInterface;
	static GetDefaultObject(): ChaosNotifyHandlerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosNotifyHandlerInterface;
	static C(Other: UObject | any): ChaosNotifyHandlerInterface;
}

declare class ChaosPhysicsCollisionInfo { 
	Component: PrimitiveComponent;
	OtherComponent: PrimitiveComponent;
	Location: Vector;
	Normal: Vector;
	AccumulatedImpulse: Vector;
	Velocity: Vector;
	OtherVelocity: Vector;
	AngularVelocity: Vector;
	OtherAngularVelocity: Vector;
	Mass: number;
	OtherMass: number;
	clone() : ChaosPhysicsCollisionInfo;
	static C(Other: UObject | any): ChaosPhysicsCollisionInfo;
	ConvertPhysicsCollisionToHitResult(): HitResult;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
}

declare class ChaosSolverEngineBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static GetDefaultObject(): ChaosSolverEngineBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverEngineBlueprintLibrary;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
	static C(Other: UObject | any): ChaosSolverEngineBlueprintLibrary;
}

declare class ChaosSolver extends UObject { 
	static Load(ResourceName: string): ChaosSolver;
	static Find(Outer: UObject, ResourceName: string): ChaosSolver;
	static GetDefaultObject(): ChaosSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolver;
	static C(Other: UObject | any): ChaosSolver;
}

declare type EClusterConnectionTypeEnum = 'Chaos_PointImplicit' | 'Chaos_DelaunayTriangulation' | 'Chaos_MinimalSpanningSubsetDelaunayTriangulation' | 'Chaos_PointImplicitAugmentedWithMinimalDelaunay' | 'Chaos_None' | 'Chaos_EClsuterCreationParameters_Max' | 'Chaos_MAX';
declare var EClusterConnectionTypeEnum : { Chaos_PointImplicit:'Chaos_PointImplicit',Chaos_DelaunayTriangulation:'Chaos_DelaunayTriangulation',Chaos_MinimalSpanningSubsetDelaunayTriangulation:'Chaos_MinimalSpanningSubsetDelaunayTriangulation',Chaos_PointImplicitAugmentedWithMinimalDelaunay:'Chaos_PointImplicitAugmentedWithMinimalDelaunay',Chaos_None:'Chaos_None',Chaos_EClsuterCreationParameters_Max:'Chaos_EClsuterCreationParameters_Max',Chaos_MAX:'Chaos_MAX', };
declare class ChaosDebugSubstepControl { 
	bPause: boolean;
	bSubstep: boolean;
	bStep: boolean;
	clone() : ChaosDebugSubstepControl;
	static C(Other: UObject | any): ChaosDebugSubstepControl;
}

declare class ChaosSolverActor extends Actor { 
	Properties: ChaosSolverConfiguration;
	TimeStepMultiplier: number;
	CollisionIterations: number;
	PushOutIterations: number;
	PushOutPairIterations: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterConnectionTypeEnum;
	DoGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	DoGenerateBreakingData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	DoGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	MassScale: number;
	bGenerateContactGraph: boolean;
	bHasFloor: boolean;
	FloorHeight: number;
	ChaosDebugSubstepControl: ChaosDebugSubstepControl;
	SpriteComponent: BillboardComponent;
	GameplayEventDispatcherComponent: ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosSolverActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverActor;
	SetSolverActive(bActive: boolean): void;
	SetAsCurrentWorldSolver(): void;
	static C(Other: UObject | any): ChaosSolverActor;
}

declare class ChaosSolverSettings extends DeveloperSettings { 
	DefaultChaosSolverActorClass: SoftClassPath;
	static Load(ResourceName: string): ChaosSolverSettings;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverSettings;
	static GetDefaultObject(): ChaosSolverSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverSettings;
	static C(Other: UObject | any): ChaosSolverSettings;
}

declare class FieldSystem extends UObject { 
	static Load(ResourceName: string): FieldSystem;
	static Find(Outer: UObject, ResourceName: string): FieldSystem;
	static GetDefaultObject(): FieldSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystem;
	static C(Other: UObject | any): FieldSystem;
}

declare class FieldNodeBase extends ActorComponent { 
	static Load(ResourceName: string): FieldNodeBase;
	static Find(Outer: UObject, ResourceName: string): FieldNodeBase;
	static GetDefaultObject(): FieldNodeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeBase;
	static C(Other: UObject | any): FieldNodeBase;
}

declare class FieldSystemMetaData extends ActorComponent { 
	static Load(ResourceName: string): FieldSystemMetaData;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaData;
	static GetDefaultObject(): FieldSystemMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaData;
	static C(Other: UObject | any): FieldSystemMetaData;
}

declare class FieldObjectCommands { 
	TargetNames: string[];
	RootNodes: FieldNodeBase[];
	MetaDatas: FieldSystemMetaData[];
	clone() : FieldObjectCommands;
	static C(Other: UObject | any): FieldObjectCommands;
}

declare type EFieldPhysicsType = 'Field_None' | 'Field_DynamicState' | 'Field_LinearForce' | 'Field_ExternalClusterStrain' | 'Field_Kill' | 'Field_LinearVelocity' | 'Field_AngularVelociy' | 'Field_AngularTorque' | 'Field_InternalClusterStrain' | 'Field_DisableThreshold' | 'Field_SleepingThreshold' | 'Field_PositionStatic' | 'Field_PositionAnimated' | 'Field_PositionTarget' | 'Field_DynamicConstraint' | 'Field_CollisionGroup' | 'Field_ActivateDisabled' | 'Field_InitialLinearVelocity' | 'Field_InitialAngularVelocity' | 'Field_PhysicsType_Max';
declare var EFieldPhysicsType : { Field_None:'Field_None',Field_DynamicState:'Field_DynamicState',Field_LinearForce:'Field_LinearForce',Field_ExternalClusterStrain:'Field_ExternalClusterStrain',Field_Kill:'Field_Kill',Field_LinearVelocity:'Field_LinearVelocity',Field_AngularVelociy:'Field_AngularVelociy',Field_AngularTorque:'Field_AngularTorque',Field_InternalClusterStrain:'Field_InternalClusterStrain',Field_DisableThreshold:'Field_DisableThreshold',Field_SleepingThreshold:'Field_SleepingThreshold',Field_PositionStatic:'Field_PositionStatic',Field_PositionAnimated:'Field_PositionAnimated',Field_PositionTarget:'Field_PositionTarget',Field_DynamicConstraint:'Field_DynamicConstraint',Field_CollisionGroup:'Field_CollisionGroup',Field_ActivateDisabled:'Field_ActivateDisabled',Field_InitialLinearVelocity:'Field_InitialLinearVelocity',Field_InitialAngularVelocity:'Field_InitialAngularVelocity',Field_PhysicsType_Max:'Field_PhysicsType_Max', };
declare class FieldSystemComponent extends PrimitiveComponent { 
	FieldSystem: FieldSystem;
	bIsWorldField: boolean;
	bIsChaosField: boolean;
	SupportedSolvers: ChaosSolverActor[];
	ConstructionCommands: FieldObjectCommands;
	BufferCommands: FieldObjectCommands;
	static Load(ResourceName: string): FieldSystemComponent;
	static Find(Outer: UObject, ResourceName: string): FieldSystemComponent;
	static GetDefaultObject(): FieldSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemComponent;
	ResetFieldSystem(): void;
	RemovePersistentFields(): void;
	ApplyUniformVectorFalloffForce(Enabled: boolean,position: Vector,Direction: Vector,Radius: number,Magnitude: number): void;
	ApplyStrainField(Enabled: boolean,position: Vector,Radius: number,Magnitude: number,Iterations: number): void;
	ApplyStayDynamicField(Enabled: boolean,position: Vector,Radius: number): void;
	ApplyRadialVectorFalloffForce(Enabled: boolean,position: Vector,Radius: number,Magnitude: number): void;
	ApplyRadialForce(Enabled: boolean,position: Vector,Magnitude: number): void;
	ApplyPhysicsField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyLinearForce(Enabled: boolean,Direction: Vector,Magnitude: number): void;
	AddPersistentField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	AddFieldCommand(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	static C(Other: UObject | any): FieldSystemComponent;
}

declare class FieldSystemActor extends Actor { 
	FieldSystemComponent: FieldSystemComponent;
	static GetDefaultObject(): FieldSystemActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemActor;
	static C(Other: UObject | any): FieldSystemActor;
}

declare class FieldSystemMetaDataIteration extends FieldSystemMetaData { 
	Iterations: number;
	static Load(ResourceName: string): FieldSystemMetaDataIteration;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataIteration;
	static GetDefaultObject(): FieldSystemMetaDataIteration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataIteration;
	SetMetaDataIteration(Iterations: number): FieldSystemMetaDataIteration;
	static C(Other: UObject | any): FieldSystemMetaDataIteration;
}

declare type EFieldResolutionType = 'Field_Resolution_Minimal' | 'Field_Resolution_DisabledParents' | 'Field_Resolution_Maximum' | 'Field_Resolution_Max';
declare var EFieldResolutionType : { Field_Resolution_Minimal:'Field_Resolution_Minimal',Field_Resolution_DisabledParents:'Field_Resolution_DisabledParents',Field_Resolution_Maximum:'Field_Resolution_Maximum',Field_Resolution_Max:'Field_Resolution_Max', };
declare class FieldSystemMetaDataProcessingResolution extends FieldSystemMetaData { 
	ResolutionType: EFieldResolutionType;
	static Load(ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static GetDefaultObject(): FieldSystemMetaDataProcessingResolution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataProcessingResolution;
	SetMetaDataaProcessingResolutionType(ResolutionType: EFieldResolutionType): FieldSystemMetaDataProcessingResolution;
	static C(Other: UObject | any): FieldSystemMetaDataProcessingResolution;
}

declare type EFieldFilterType = 'Field_Filter_Dynamic' | 'Field_Filter_Kinematic' | 'Field_Filter_Static' | 'Field_Filter_All' | 'Field_Filter_Sleeping' | 'Field_Filter_Disabled' | 'Field_Filter_Max';
declare var EFieldFilterType : { Field_Filter_Dynamic:'Field_Filter_Dynamic',Field_Filter_Kinematic:'Field_Filter_Kinematic',Field_Filter_Static:'Field_Filter_Static',Field_Filter_All:'Field_Filter_All',Field_Filter_Sleeping:'Field_Filter_Sleeping',Field_Filter_Disabled:'Field_Filter_Disabled',Field_Filter_Max:'Field_Filter_Max', };
declare type EFieldObjectType = 'Field_Object_Rigid' | 'Field_Object_Cloth' | 'Field_Object_Destruction' | 'Field_Object_Character' | 'Field_Object_All' | 'Field_Object_Max';
declare var EFieldObjectType : { Field_Object_Rigid:'Field_Object_Rigid',Field_Object_Cloth:'Field_Object_Cloth',Field_Object_Destruction:'Field_Object_Destruction',Field_Object_Character:'Field_Object_Character',Field_Object_All:'Field_Object_All',Field_Object_Max:'Field_Object_Max', };
declare type EFieldPositionType = 'Field_Position_CenterOfMass' | 'Field_Position_PivotPoint' | 'Field_Position_Max';
declare var EFieldPositionType : { Field_Position_CenterOfMass:'Field_Position_CenterOfMass',Field_Position_PivotPoint:'Field_Position_PivotPoint',Field_Position_Max:'Field_Position_Max', };
declare class FieldSystemMetaDataFilter extends FieldSystemMetaData { 
	FilterType: EFieldFilterType;
	ObjectType: EFieldObjectType;
	PositionType: EFieldPositionType;
	static Load(ResourceName: string): FieldSystemMetaDataFilter;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataFilter;
	static GetDefaultObject(): FieldSystemMetaDataFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataFilter;
	SetMetaDataFilterType(FilterType: EFieldFilterType,ObjectType: EFieldObjectType,PositionType: EFieldPositionType): FieldSystemMetaDataFilter;
	static C(Other: UObject | any): FieldSystemMetaDataFilter;
}

declare class FieldNodeInt extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeInt;
	static Find(Outer: UObject, ResourceName: string): FieldNodeInt;
	static GetDefaultObject(): FieldNodeInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeInt;
	static C(Other: UObject | any): FieldNodeInt;
}

declare class FieldNodeFloat extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeFloat;
	static Find(Outer: UObject, ResourceName: string): FieldNodeFloat;
	static GetDefaultObject(): FieldNodeFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeFloat;
	static C(Other: UObject | any): FieldNodeFloat;
}

declare class FieldNodeVector extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeVector;
	static Find(Outer: UObject, ResourceName: string): FieldNodeVector;
	static GetDefaultObject(): FieldNodeVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeVector;
	static C(Other: UObject | any): FieldNodeVector;
}

declare class UniformInteger extends FieldNodeInt { 
	Magnitude: number;
	static Load(ResourceName: string): UniformInteger;
	static Find(Outer: UObject, ResourceName: string): UniformInteger;
	static GetDefaultObject(): UniformInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformInteger;
	SetUniformInteger(Magnitude: number): UniformInteger;
	static C(Other: UObject | any): UniformInteger;
}

declare type ESetMaskConditionType = 'Field_Set_Always' | 'Field_Set_IFF_NOT_Interior' | 'Field_Set_IFF_NOT_Exterior' | 'Field_MaskCondition_Max' | 'Field_MAX';
declare var ESetMaskConditionType : { Field_Set_Always:'Field_Set_Always',Field_Set_IFF_NOT_Interior:'Field_Set_IFF_NOT_Interior',Field_Set_IFF_NOT_Exterior:'Field_Set_IFF_NOT_Exterior',Field_MaskCondition_Max:'Field_MaskCondition_Max',Field_MAX:'Field_MAX', };
declare class RadialIntMask extends FieldNodeInt { 
	Radius: number;
	position: Vector;
	InteriorValue: number;
	ExteriorValue: number;
	SetMaskCondition: ESetMaskConditionType;
	static Load(ResourceName: string): RadialIntMask;
	static Find(Outer: UObject, ResourceName: string): RadialIntMask;
	static GetDefaultObject(): RadialIntMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialIntMask;
	SetRadialIntMask(Radius: number,position: Vector,InteriorValue: number,ExteriorValue: number,SetMaskConditionIn: ESetMaskConditionType): RadialIntMask;
	static C(Other: UObject | any): RadialIntMask;
}

declare class UniformScalar extends FieldNodeFloat { 
	Magnitude: number;
	static Load(ResourceName: string): UniformScalar;
	static Find(Outer: UObject, ResourceName: string): UniformScalar;
	static GetDefaultObject(): UniformScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScalar;
	SetUniformScalar(Magnitude: number): UniformScalar;
	static C(Other: UObject | any): UniformScalar;
}

declare type EWaveFunctionType = 'Field_Wave_Cosine' | 'Field_Wave_Gaussian' | 'Field_Wave_Falloff' | 'Field_Wave_Decay' | 'Field_Wave_Max';
declare var EWaveFunctionType : { Field_Wave_Cosine:'Field_Wave_Cosine',Field_Wave_Gaussian:'Field_Wave_Gaussian',Field_Wave_Falloff:'Field_Wave_Falloff',Field_Wave_Decay:'Field_Wave_Decay',Field_Wave_Max:'Field_Wave_Max', };
declare type EFieldFalloffType = 'Field_FallOff_None' | 'Field_Falloff_Linear' | 'Field_Falloff_Inverse' | 'Field_Falloff_Squared' | 'Field_Falloff_Logarithmic' | 'Field_Falloff_Max';
declare var EFieldFalloffType : { Field_FallOff_None:'Field_FallOff_None',Field_Falloff_Linear:'Field_Falloff_Linear',Field_Falloff_Inverse:'Field_Falloff_Inverse',Field_Falloff_Squared:'Field_Falloff_Squared',Field_Falloff_Logarithmic:'Field_Falloff_Logarithmic',Field_Falloff_Max:'Field_Falloff_Max', };
declare class WaveScalar extends FieldNodeFloat { 
	Magnitude: number;
	position: Vector;
	Wavelength: number;
	Period: number;
	UFunction: EWaveFunctionType;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): WaveScalar;
	static Find(Outer: UObject, ResourceName: string): WaveScalar;
	static GetDefaultObject(): WaveScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveScalar;
	SetWaveScalar(Magnitude: number,position: Vector,Wavelength: number,Period: number,Time: number,UFunction: EWaveFunctionType,Falloff: EFieldFalloffType): WaveScalar;
	static C(Other: UObject | any): WaveScalar;
}

declare class RadialFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Radius: number;
	position: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): RadialFalloff;
	static Find(Outer: UObject, ResourceName: string): RadialFalloff;
	static GetDefaultObject(): RadialFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialFalloff;
	SetRadialFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Radius: number,position: Vector,Falloff: EFieldFalloffType): RadialFalloff;
	static C(Other: UObject | any): RadialFalloff;
}

declare class PlaneFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Distance: number;
	position: Vector;
	Normal: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): PlaneFalloff;
	static Find(Outer: UObject, ResourceName: string): PlaneFalloff;
	static GetDefaultObject(): PlaneFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneFalloff;
	SetPlaneFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Distance: number,position: Vector,Normal: Vector,Falloff: EFieldFalloffType): PlaneFalloff;
	static C(Other: UObject | any): PlaneFalloff;
}

declare class BoxFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Transform: Transform;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): BoxFalloff;
	static Find(Outer: UObject, ResourceName: string): BoxFalloff;
	static GetDefaultObject(): BoxFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoxFalloff;
	SetBoxFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Transform: Transform,Falloff: EFieldFalloffType): BoxFalloff;
	static C(Other: UObject | any): BoxFalloff;
}

declare class NoiseField extends FieldNodeFloat { 
	MinRange: number;
	MaxRange: number;
	Transform: Transform;
	static Load(ResourceName: string): NoiseField;
	static Find(Outer: UObject, ResourceName: string): NoiseField;
	static GetDefaultObject(): NoiseField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NoiseField;
	SetNoiseField(MinRange: number,MaxRange: number,Transform: Transform): NoiseField;
	static C(Other: UObject | any): NoiseField;
}

declare class UniformVector extends FieldNodeVector { 
	Magnitude: number;
	Direction: Vector;
	static Load(ResourceName: string): UniformVector;
	static Find(Outer: UObject, ResourceName: string): UniformVector;
	static GetDefaultObject(): UniformVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformVector;
	SetUniformVector(Magnitude: number,Direction: Vector): UniformVector;
	static C(Other: UObject | any): UniformVector;
}

declare class RadialVector extends FieldNodeVector { 
	Magnitude: number;
	position: Vector;
	static Load(ResourceName: string): RadialVector;
	static Find(Outer: UObject, ResourceName: string): RadialVector;
	static GetDefaultObject(): RadialVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialVector;
	SetRadialVector(Magnitude: number,position: Vector): RadialVector;
	static C(Other: UObject | any): RadialVector;
}

declare class RandomVector extends FieldNodeVector { 
	Magnitude: number;
	static Load(ResourceName: string): RandomVector;
	static Find(Outer: UObject, ResourceName: string): RandomVector;
	static GetDefaultObject(): RandomVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RandomVector;
	SetRandomVector(Magnitude: number): RandomVector;
	static C(Other: UObject | any): RandomVector;
}

declare type EFieldOperationType = 'Field_Multiply' | 'Field_Divide' | 'Field_Add' | 'Field_Substract' | 'Field_Operation_Max';
declare var EFieldOperationType : { Field_Multiply:'Field_Multiply',Field_Divide:'Field_Divide',Field_Add:'Field_Add',Field_Substract:'Field_Substract',Field_Operation_Max:'Field_Operation_Max', };
declare class OperatorField extends FieldNodeBase { 
	Magnitude: number;
	RightField: FieldNodeBase;
	LeftField: FieldNodeBase;
	Operation: EFieldOperationType;
	static Load(ResourceName: string): OperatorField;
	static Find(Outer: UObject, ResourceName: string): OperatorField;
	static GetDefaultObject(): OperatorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OperatorField;
	SetOperatorField(Magnitude: number,LeftField: FieldNodeBase,RightField: FieldNodeBase,Operation: EFieldOperationType): OperatorField;
	static C(Other: UObject | any): OperatorField;
}

declare class ToIntegerField extends FieldNodeInt { 
	FloatField: FieldNodeFloat;
	static Load(ResourceName: string): ToIntegerField;
	static Find(Outer: UObject, ResourceName: string): ToIntegerField;
	static GetDefaultObject(): ToIntegerField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToIntegerField;
	SetToIntegerField(FloatField: FieldNodeFloat): ToIntegerField;
	static C(Other: UObject | any): ToIntegerField;
}

declare class ToFloatField extends FieldNodeFloat { 
	IntField: FieldNodeInt;
	static Load(ResourceName: string): ToFloatField;
	static Find(Outer: UObject, ResourceName: string): ToFloatField;
	static GetDefaultObject(): ToFloatField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToFloatField;
	SetToFloatField(IntegerField: FieldNodeInt): ToFloatField;
	static C(Other: UObject | any): ToFloatField;
}

declare type EFieldCullingOperationType = 'Field_Culling_Inside' | 'Field_Culling_Outside' | 'Field_Culling_Operation_Max' | 'Field_Culling_MAX';
declare var EFieldCullingOperationType : { Field_Culling_Inside:'Field_Culling_Inside',Field_Culling_Outside:'Field_Culling_Outside',Field_Culling_Operation_Max:'Field_Culling_Operation_Max',Field_Culling_MAX:'Field_Culling_MAX', };
declare class CullingField extends FieldNodeBase { 
	Culling: FieldNodeBase;
	Field: FieldNodeBase;
	Operation: EFieldCullingOperationType;
	static Load(ResourceName: string): CullingField;
	static Find(Outer: UObject, ResourceName: string): CullingField;
	static GetDefaultObject(): CullingField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CullingField;
	SetCullingField(Culling: FieldNodeBase,Field: FieldNodeBase,Operation: EFieldCullingOperationType): CullingField;
	static C(Other: UObject | any): CullingField;
}

declare class ReturnResultsTerminal extends FieldNodeBase { 
	static Load(ResourceName: string): ReturnResultsTerminal;
	static Find(Outer: UObject, ResourceName: string): ReturnResultsTerminal;
	static GetDefaultObject(): ReturnResultsTerminal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReturnResultsTerminal;
	SetReturnResultsTerminal(): ReturnResultsTerminal;
	static C(Other: UObject | any): ReturnResultsTerminal;
}

declare class StatePerObjectConfig extends UObject { 
	PerObjectConfigSection: string;
	bEnabled: boolean;
	static Load(ResourceName: string): StatePerObjectConfig;
	static Find(Outer: UObject, ResourceName: string): StatePerObjectConfig;
	static GetDefaultObject(): StatePerObjectConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatePerObjectConfig;
	static C(Other: UObject | any): StatePerObjectConfig;
}

declare class EscalationManagerConfig extends StatePerObjectConfig { 
	EscalationSeverity: string[];
	static Load(ResourceName: string): EscalationManagerConfig;
	static Find(Outer: UObject, ResourceName: string): EscalationManagerConfig;
	static GetDefaultObject(): EscalationManagerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EscalationManagerConfig;
	static C(Other: UObject | any): EscalationManagerConfig;
}

declare class NetAnalyticsDataConfig { 
	DataName: string;
	bEnabled: boolean;
	clone() : NetAnalyticsDataConfig;
	static C(Other: UObject | any): NetAnalyticsDataConfig;
}

declare class NetAnalyticsAggregatorConfig extends UObject { 
	NetAnalyticsData: NetAnalyticsDataConfig[];
	static Load(ResourceName: string): NetAnalyticsAggregatorConfig;
	static Find(Outer: UObject, ResourceName: string): NetAnalyticsAggregatorConfig;
	static GetDefaultObject(): NetAnalyticsAggregatorConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetAnalyticsAggregatorConfig;
	static C(Other: UObject | any): NetAnalyticsAggregatorConfig;
}

declare type EChaosCollisionSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByHighestImpulse' | 'SortByNearestFirst' | 'Count' | 'EChaosCollisionSortMethod_MAX';
declare var EChaosCollisionSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByHighestImpulse:'SortByHighestImpulse',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosCollisionSortMethod_MAX:'EChaosCollisionSortMethod_MAX', };
declare class ChaosCollisionEventRequestSettings { 
	MaxNumberResults: number;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	MaxDistance: number;
	SortMethod: EChaosCollisionSortMethod;
	clone() : ChaosCollisionEventRequestSettings;
	static C(Other: UObject | any): ChaosCollisionEventRequestSettings;
}

declare type EChaosBreakingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosBreakingSortMethod_MAX';
declare var EChaosBreakingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosBreakingSortMethod_MAX:'EChaosBreakingSortMethod_MAX', };
declare class ChaosBreakingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinRadius: number;
	MinSpeed: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosBreakingSortMethod;
	clone() : ChaosBreakingEventRequestSettings;
	static C(Other: UObject | any): ChaosBreakingEventRequestSettings;
}

declare type EChaosTrailingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosTrailingSortMethod_MAX';
declare var EChaosTrailingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosTrailingSortMethod_MAX:'EChaosTrailingSortMethod_MAX', };
declare class ChaosTrailingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MinSpeed: number;
	MinAngularSpeed: number;
	MaxDistance: number;
	SortMethod: EChaosTrailingSortMethod;
	clone() : ChaosTrailingEventRequestSettings;
	static C(Other: UObject | any): ChaosTrailingEventRequestSettings;
}

declare type EChaosRemovalSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByNearestFirst' | 'Count' | 'EChaosRemovalSortMethod_MAX';
declare var EChaosRemovalSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosRemovalSortMethod_MAX:'EChaosRemovalSortMethod_MAX', };
declare class ChaosRemovalEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosRemovalSortMethod;
	clone() : ChaosRemovalEventRequestSettings;
	static C(Other: UObject | any): ChaosRemovalEventRequestSettings;
}

declare class ChaosCollisionEventData { 
	Location: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	Mass1: number;
	Mass2: number;
	Impulse: Vector;
	clone() : ChaosCollisionEventData;
	static C(Other: UObject | any): ChaosCollisionEventData;
}

declare class ChaosBreakingEventData { 
	Location: Vector;
	Velocity: Vector;
	Mass: number;
	clone() : ChaosBreakingEventData;
	static C(Other: UObject | any): ChaosBreakingEventData;
}

declare class ChaosTrailingEventData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosTrailingEventData;
	static C(Other: UObject | any): ChaosTrailingEventData;
}

declare class ChaosRemovalEventData { 
	Location: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosRemovalEventData;
	static C(Other: UObject | any): ChaosRemovalEventData;
}

declare class GeometryCollectionSource { 
	SourceGeometryObject: SoftObjectPath;
	LocalTransform: Transform;
	SourceMaterial: MaterialInterface[];
	clone() : GeometryCollectionSource;
	static C(Other: UObject | any): GeometryCollectionSource;
}

declare class GeometryCollectionEmbeddedExemplar { 
	StaticMeshExemplar: SoftObjectPath;
	StartCullDistance: number;
	EndCullDistance: number;
	InstanceCount: number;
	clone() : GeometryCollectionEmbeddedExemplar;
	static C(Other: UObject | any): GeometryCollectionEmbeddedExemplar;
}

declare type ECollisionTypeEnum = 'Chaos_Volumetric' | 'Chaos_Surface_Volumetric' | 'Chaos_Max';
declare var ECollisionTypeEnum : { Chaos_Volumetric:'Chaos_Volumetric',Chaos_Surface_Volumetric:'Chaos_Surface_Volumetric',Chaos_Max:'Chaos_Max', };
declare type EImplicitTypeEnum = 'Chaos_Implicit_Box' | 'Chaos_Implicit_Sphere' | 'Chaos_Implicit_Capsule' | 'Chaos_Implicit_LevelSet' | 'Chaos_Implicit_None' | 'Chaos_Implicit_Convex' | 'Chaos_Max';
declare var EImplicitTypeEnum : { Chaos_Implicit_Box:'Chaos_Implicit_Box',Chaos_Implicit_Sphere:'Chaos_Implicit_Sphere',Chaos_Implicit_Capsule:'Chaos_Implicit_Capsule',Chaos_Implicit_LevelSet:'Chaos_Implicit_LevelSet',Chaos_Implicit_None:'Chaos_Implicit_None',Chaos_Implicit_Convex:'Chaos_Implicit_Convex',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionLevelSetData { 
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	clone() : GeometryCollectionLevelSetData;
	static C(Other: UObject | any): GeometryCollectionLevelSetData;
}

declare class GeometryCollectionCollisionParticleData { 
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	clone() : GeometryCollectionCollisionParticleData;
	static C(Other: UObject | any): GeometryCollectionCollisionParticleData;
}

declare class GeometryCollectionCollisionTypeData { 
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	LevelSet: GeometryCollectionLevelSetData;
	CollisionParticles: GeometryCollectionCollisionParticleData;
	CollisionObjectReductionPercentage: number;
	CollisionMarginFraction: number;
	clone() : GeometryCollectionCollisionTypeData;
	static C(Other: UObject | any): GeometryCollectionCollisionTypeData;
}

declare class GeometryCollectionSizeSpecificData { 
	MaxSize: number;
	CollisionShapes: GeometryCollectionCollisionTypeData[];
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	DamageThreshold: number;
	clone() : GeometryCollectionSizeSpecificData;
	static C(Other: UObject | any): GeometryCollectionSizeSpecificData;
}

declare class GeometryCollection extends UObject { 
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	ClusterConnectionType: EClusterConnectionTypeEnum;
	GeometrySource: GeometryCollectionSource[];
	Materials: MaterialInterface[];
	EmbeddedGeometryExemplar: GeometryCollectionEmbeddedExemplar[];
	bUseFullPrecisionUVs: boolean;
	bStripOnCook: boolean;
	EnableNanite: boolean;
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	bMassAsDensity: boolean;
	Mass: number;
	MinimumMassClamp: number;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	bRemoveOnMaxSleep: boolean;
	MaximumSleepTime: Vector2D;
	RemovalDuration: Vector2D;
	SizeSpecificData: GeometryCollectionSizeSpecificData[];
	EnableRemovePiecesOnFracture: boolean;
	RemoveOnFractureMaterials: MaterialInterface[];
	ThumbnailInfo: ThumbnailInfo;
	PersistentGuid: Guid;
	StateGuid: Guid;
	BoneSelectedMaterialIndex: number;
	static Load(ResourceName: string): GeometryCollection;
	static Find(Outer: UObject, ResourceName: string): GeometryCollection;
	static GetDefaultObject(): GeometryCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollection;
	static C(Other: UObject | any): GeometryCollection;
}

declare type EObjectStateTypeEnum = 'Chaos_NONE' | 'Chaos_Object_Sleeping' | 'Chaos_Object_Kinematic' | 'Chaos_Object_Static' | 'Chaos_Object_Dynamic' | 'Chaos_Object_UserDefined' | 'Chaos_Max';
declare var EObjectStateTypeEnum : { Chaos_NONE:'Chaos_NONE',Chaos_Object_Sleeping:'Chaos_Object_Sleeping',Chaos_Object_Kinematic:'Chaos_Object_Kinematic',Chaos_Object_Static:'Chaos_Object_Static',Chaos_Object_Dynamic:'Chaos_Object_Dynamic',Chaos_Object_UserDefined:'Chaos_Object_UserDefined',Chaos_Max:'Chaos_Max', };
declare type EInitialVelocityTypeEnum = 'Chaos_Initial_Velocity_User_Defined' | 'Chaos_Initial_Velocity_None' | 'Chaos_Max';
declare var EInitialVelocityTypeEnum : { Chaos_Initial_Velocity_User_Defined:'Chaos_Initial_Velocity_User_Defined',Chaos_Initial_Velocity_None:'Chaos_Initial_Velocity_None',Chaos_Max:'Chaos_Max', };
declare type EGeometryCollectionCacheType = 'None' | 'Record' | 'Play' | 'RecordAndPlay' | 'EGeometryCollectionCacheType_MAX';
declare var EGeometryCollectionCacheType : { None:'None',Record:'Record',Play:'Play',RecordAndPlay:'RecordAndPlay',EGeometryCollectionCacheType_MAX:'EGeometryCollectionCacheType_MAX', };
declare class SolverCollisionData { 
	Location: Vector;
	AccumulatedImpulse: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	AngularVelocity1: Vector;
	AngularVelocity2: Vector;
	Mass1: number;
	Mass2: number;
	ParticleIndex: number;
	LevelsetIndex: number;
	ParticleIndexMesh: number;
	LevelsetIndexMesh: number;
	clone() : SolverCollisionData;
	static C(Other: UObject | any): SolverCollisionData;
}

declare class SolverBreakingData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	ParticleIndexMesh: number;
	clone() : SolverBreakingData;
	static C(Other: UObject | any): SolverBreakingData;
}

declare class RecordedFrame { 
	Transforms: Transform[];
	TransformIndices: number[];
	PreviousTransformIndices: number[];
	DisabledFlags: boolean[];
	Collisions: SolverCollisionData[];
	Breakings: SolverBreakingData[];
	Trailings: any;
	Timestamp: number;
	clone() : RecordedFrame;
	static C(Other: UObject | any): RecordedFrame;
}

declare class RecordedTransformTrack { 
	Records: RecordedFrame[];
	clone() : RecordedTransformTrack;
	static C(Other: UObject | any): RecordedTransformTrack;
}

declare class GeometryCollectionCache extends UObject { 
	RecordedData: RecordedTransformTrack;
	SupportedCollection: GeometryCollection;
	CompatibleCollectionState: Guid;
	static Load(ResourceName: string): GeometryCollectionCache;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionCache;
	static GetDefaultObject(): GeometryCollectionCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionCache;
	static C(Other: UObject | any): GeometryCollectionCache;
}

declare class GeomComponentCacheParameters { 
	CacheMode: EGeometryCollectionCacheType;
	TargetCache: GeometryCollectionCache;
	ReverseCacheBeginTime: number;
	SaveCollisionData: boolean;
	DoGenerateCollisionData: boolean;
	CollisionDataSizeMax: number;
	DoCollisionDataSpatialHash: boolean;
	CollisionDataSpatialHashRadius: number;
	MaxCollisionPerCell: number;
	SaveBreakingData: boolean;
	DoGenerateBreakingData: boolean;
	BreakingDataSizeMax: number;
	DoBreakingDataSpatialHash: boolean;
	BreakingDataSpatialHashRadius: number;
	MaxBreakingPerCell: number;
	SaveTrailingData: boolean;
	DoGenerateTrailingData: boolean;
	TrailingDataSizeMax: number;
	TrailingMinSpeedThreshold: number;
	TrailingMinVolumeThreshold: number;
	clone() : GeomComponentCacheParameters;
	static C(Other: UObject | any): GeomComponentCacheParameters;
}

declare class ChaosBreakEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	clone() : ChaosBreakEvent;
	static C(Other: UObject | any): ChaosBreakEvent;
}

declare class ChaosRemovalEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Mass: number;
	clone() : ChaosRemovalEvent;
	static C(Other: UObject | any): ChaosRemovalEvent;
}

declare class GeometryCollectionRepData { 
	clone() : GeometryCollectionRepData;
	static C(Other: UObject | any): GeometryCollectionRepData;
}

declare class InstancedStaticMeshInstanceData { 
	Transform: Matrix;
	clone() : InstancedStaticMeshInstanceData;
	static C(Other: UObject | any): InstancedStaticMeshInstanceData;
}

declare class InstancedStaticMeshRandomSeed { 
	StartInstanceIndex: number;
	RandomSeed: number;
	clone() : InstancedStaticMeshRandomSeed;
	static C(Other: UObject | any): InstancedStaticMeshRandomSeed;
}

declare class InstancedStaticMeshMappingInfo { 
	clone() : InstancedStaticMeshMappingInfo;
	static C(Other: UObject | any): InstancedStaticMeshMappingInfo;
}

declare class InstancedStaticMeshComponent extends StaticMeshComponent { 
	PerInstanceSMData: InstancedStaticMeshInstanceData[];
	PerInstancePrevTransform: Matrix[];
	NumCustomDataFloats: number;
	PerInstanceSMCustomData: number[];
	InstancingRandomSeed: number;
	AdditionalRandomSeeds: InstancedStaticMeshRandomSeed[];
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	InstanceReorderTable: number[];
	NumPendingLightmaps: number;
	CachedMappings: InstancedStaticMeshMappingInfo[];
	static Load(ResourceName: string): InstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): InstancedStaticMeshComponent;
	static GetDefaultObject(): InstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedStaticMeshComponent;
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	SetCustomDataValue(InstanceIndex: number,CustomDataIndex: number,CustomDataValue: number,bMarkRenderStateDirty: boolean): boolean;
	SetCullDistances(StartCullDistance: number,EndCullDistance: number): void;
	RemoveInstances(InstancesToRemove: number[]): boolean;
	RemoveInstance(InstanceIndex: number): boolean;
	IsValidInstance(InstanceIndex: number): boolean;
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	GetInstancesOverlappingSphere(Center: Vector,Radius: number,bSphereInWorldSpace: boolean): number[];
	GetInstancesOverlappingBox(Box: Box,bBoxInWorldSpace: boolean): number[];
	GetInstanceCount(): number;
	ClearInstances(): void;
	BatchUpdateInstancesTransforms(StartInstanceIndex: number,NewInstancesTransforms: Transform[],bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	BatchUpdateInstancesTransform(StartInstanceIndex: number,NumInstances: number,NewInstancesTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	AddInstanceWorldSpace(WorldTransform: Transform): number;
	AddInstances(InstanceTransforms: Transform[],bShouldReturnIndices: boolean,bWorldSpace: boolean): number[];
	AddInstance(InstanceTransform: Transform,bWorldSpace: boolean): number;
	static C(Other: UObject | any): InstancedStaticMeshComponent;
	K2_AcquireEditorSMInstanceElementHandle(InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorSMInstanceElementHandle(ISMComponent: InstancedStaticMeshComponent,InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare type EGeometryCollectionPhysicsTypeEnum = 'Chaos_AngularVelocity' | 'Chaos_DynamicState' | 'Chaos_LinearVelocity' | 'Chaos_InitialAngularVelocity' | 'Chaos_InitialLinearVelocity' | 'Chaos_CollisionGroup' | 'Chaos_LinearForce' | 'Chaos_AngularTorque' | 'Chaos_DisableThreshold' | 'Chaos_SleepingThreshold' | 'Chaos_Max';
declare var EGeometryCollectionPhysicsTypeEnum : { Chaos_AngularVelocity:'Chaos_AngularVelocity',Chaos_DynamicState:'Chaos_DynamicState',Chaos_LinearVelocity:'Chaos_LinearVelocity',Chaos_InitialAngularVelocity:'Chaos_InitialAngularVelocity',Chaos_InitialLinearVelocity:'Chaos_InitialLinearVelocity',Chaos_CollisionGroup:'Chaos_CollisionGroup',Chaos_LinearForce:'Chaos_LinearForce',Chaos_AngularTorque:'Chaos_AngularTorque',Chaos_DisableThreshold:'Chaos_DisableThreshold',Chaos_SleepingThreshold:'Chaos_SleepingThreshold',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionComponent extends MeshComponent { 
	ChaosSolverActor: ChaosSolverActor;
	RestCollection: GeometryCollection;
	InitializationFields: FieldSystemActor[];
	Simulating: boolean;
	ObjectType: EObjectStateTypeEnum;
	bForceMotionBlur: boolean;
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	bUseSizeSpecificDamageThreshold: boolean;
	ClusterConnectionType: EClusterConnectionTypeEnum;
	CollisionGroup: number;
	CollisionSampleFraction: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	PhysicalMaterial: ChaosPhysicalMaterial;
	InitialVelocityType: EInitialVelocityTypeEnum;
	InitialLinearVelocity: Vector;
	InitialAngularVelocity: Vector;
	PhysicalMaterialOverride: PhysicalMaterial;
	CacheParameters: GeomComponentCacheParameters;
	RestTransforms: Transform[];
	NotifyGeometryCollectionPhysicsStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	NotifyGeometryCollectionPhysicsLoadingStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	OnChaosBreakEvent: UnrealEngineMulticastDelegate<(BreakEvent: ChaosBreakEvent) => void>;
	OnChaosRemovalEvent: UnrealEngineMulticastDelegate<(RemovalEvent: ChaosRemovalEvent) => void>;
	DesiredCacheTime: number;
	CachePlayback: boolean;
	OnChaosPhysicsCollision: UnrealEngineMulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
	bNotifyBreaks: boolean;
	bNotifyCollisions: boolean;
	bNotifyTrailing: boolean;
	bNotifyRemovals: boolean;
	bStoreVelocities: boolean;
	bShowBoneColors: boolean;
	bEnableReplication: boolean;
	bEnableAbandonAfterLevel: boolean;
	ReplicationAbandonClusterLevel: number;
	RepData: GeometryCollectionRepData;
	SelectedBones: number[];
	HighlightedBones: number[];
	DummyBodySetup: BodySetup;
	EditorActor: Actor;
	EmbeddedGeometryComponents: InstancedStaticMeshComponent[];
	static Load(ResourceName: string): GeometryCollectionComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionComponent;
	static GetDefaultObject(): GeometryCollectionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionComponent;
	SetNotifyRemovals(bNewNotifyRemovals: boolean): void;
	SetNotifyBreaks(bNewNotifyBreaks: boolean): void;
	ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
	OnRep_RepData(OldData: GeometryCollectionRepData): void;
	NetAbandonCluster(TransformIndex: number): void;
	ApplyPhysicsField(Enabled: boolean,Target: EGeometryCollectionPhysicsTypeEnum,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyKinematicField(Radius: number,position: Vector): void;
	static C(Other: UObject | any): GeometryCollectionComponent;
}

declare class GeometryCollectionDebugDrawWarningMessage { 
	clone() : GeometryCollectionDebugDrawWarningMessage;
	static C(Other: UObject | any): GeometryCollectionDebugDrawWarningMessage;
}

declare class GeometryCollectionDebugDrawActorSelectedRigidBody { 
	ID: number;
	Solver: ChaosSolverActor;
	GeometryCollection: GeometryCollectionActor;
	clone() : GeometryCollectionDebugDrawActorSelectedRigidBody;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActorSelectedRigidBody;
}

declare type EGeometryCollectionDebugDrawActorHideGeometry = 'HideNone' | 'HideWithCollision' | 'HideSelected' | 'HideWholeCollection' | 'HideAll' | 'EGeometryCollectionDebugDrawActorHideGeometry_MAX';
declare var EGeometryCollectionDebugDrawActorHideGeometry : { HideNone:'HideNone',HideWithCollision:'HideWithCollision',HideSelected:'HideSelected',HideWholeCollection:'HideWholeCollection',HideAll:'HideAll',EGeometryCollectionDebugDrawActorHideGeometry_MAX:'EGeometryCollectionDebugDrawActorHideGeometry_MAX', };
declare class GeometryCollectionDebugDrawActor extends Actor { 
	WarningMessage: GeometryCollectionDebugDrawWarningMessage;
	SelectedRigidBody: GeometryCollectionDebugDrawActorSelectedRigidBody;
	bDebugDrawWholeCollection: boolean;
	bDebugDrawHierarchy: boolean;
	bDebugDrawClustering: boolean;
	HideGeometry: EGeometryCollectionDebugDrawActorHideGeometry;
	bShowRigidBodyId: boolean;
	bShowRigidBodyCollision: boolean;
	bCollisionAtOrigin: boolean;
	bShowRigidBodyTransform: boolean;
	bShowRigidBodyInertia: boolean;
	bShowRigidBodyVelocity: boolean;
	bShowRigidBodyForce: boolean;
	bShowRigidBodyInfos: boolean;
	bShowTransformIndex: boolean;
	bShowTransform: boolean;
	bShowParent: boolean;
	bShowLevel: boolean;
	bShowConnectivityEdges: boolean;
	bShowGeometryIndex: boolean;
	bShowGeometryTransform: boolean;
	bShowBoundingBox: boolean;
	bShowFaces: boolean;
	bShowFaceIndices: boolean;
	bShowFaceNormals: boolean;
	bShowSingleFace: boolean;
	SingleFaceIndex: number;
	bShowVertices: boolean;
	bShowVertexIndices: boolean;
	bShowVertexNormals: boolean;
	bUseActiveVisualization: boolean;
	PointThickness: number;
	LineThickness: number;
	bTextShadow: boolean;
	TextScale: number;
	NormalScale: number;
	AxisScale: number;
	ArrowScale: number;
	RigidBodyIdColor: Color;
	RigidBodyTransformScale: number;
	RigidBodyCollisionColor: Color;
	RigidBodyInertiaColor: Color;
	RigidBodyVelocityColor: Color;
	RigidBodyForceColor: Color;
	RigidBodyInfoColor: Color;
	TransformIndexColor: Color;
	TransformScale: number;
	LevelColor: Color;
	ParentColor: Color;
	ConnectivityEdgeThickness: number;
	GeometryIndexColor: Color;
	GeometryTransformScale: number;
	BoundingBoxColor: Color;
	FaceColor: Color;
	FaceIndexColor: Color;
	FaceNormalColor: Color;
	SingleFaceColor: Color;
	VertexColor: Color;
	VertexIndexColor: Color;
	VertexNormalColor: Color;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawActor;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActor;
}

declare class GeometryCollectionRenderLevelSetActor extends Actor { 
	TargetVolumeTexture: VolumeTexture;
	RayMarchMaterial: Material;
	SurfaceTolerance: number;
	Isovalue: number;
	Enabled: boolean;
	RenderVolumeBoundingBox: boolean;
	static GetDefaultObject(): GeometryCollectionRenderLevelSetActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionRenderLevelSetActor;
	static C(Other: UObject | any): GeometryCollectionRenderLevelSetActor;
}

declare class GeometryCollectionDebugDrawComponent extends ActorComponent { 
	GeometryCollectionDebugDrawActor: GeometryCollectionDebugDrawActor;
	GeometryCollectionRenderLevelSetActor: GeometryCollectionRenderLevelSetActor;
	static Load(ResourceName: string): GeometryCollectionDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawComponent;
	static C(Other: UObject | any): GeometryCollectionDebugDrawComponent;
}

declare class GeometryCollectionActor extends Actor { 
	GeometryCollectionComponent: GeometryCollectionComponent;
	GeometryCollectionDebugDrawComponent: GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionActor;
	RaycastSingle(Start: Vector,End: Vector,OutHit?: HitResult): {OutHit: HitResult, $: boolean};
	static C(Other: UObject | any): GeometryCollectionActor;
}

declare class ChaosDestructionListener extends SceneComponent { 
	bIsCollisionEventListeningEnabled: boolean;
	bIsBreakingEventListeningEnabled: boolean;
	bIsTrailingEventListeningEnabled: boolean;
	bIsRemovalEventListeningEnabled: boolean;
	CollisionEventRequestSettings: ChaosCollisionEventRequestSettings;
	BreakingEventRequestSettings: ChaosBreakingEventRequestSettings;
	TrailingEventRequestSettings: ChaosTrailingEventRequestSettings;
	RemovalEventRequestSettings: ChaosRemovalEventRequestSettings;
	ChaosSolverActors: any;
	GeometryCollectionActors: any;
	OnCollisionEvents: UnrealEngineMulticastDelegate<(CollisionEvents: ChaosCollisionEventData[]) => void>;
	OnBreakingEvents: UnrealEngineMulticastDelegate<(BreakingEvents: ChaosBreakingEventData[]) => void>;
	OnTrailingEvents: UnrealEngineMulticastDelegate<(TrailingEvents: ChaosTrailingEventData[]) => void>;
	OnRemovalEvents: UnrealEngineMulticastDelegate<(RemovalEvents: ChaosRemovalEventData[]) => void>;
	static Load(ResourceName: string): ChaosDestructionListener;
	static Find(Outer: UObject, ResourceName: string): ChaosDestructionListener;
	static GetDefaultObject(): ChaosDestructionListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDestructionListener;
	SortTrailingEvents(TrailingEvents?: ChaosTrailingEventData[],SortMethod?: EChaosTrailingSortMethod): {TrailingEvents: ChaosTrailingEventData[]};
	SortRemovalEvents(RemovalEvents?: ChaosRemovalEventData[],SortMethod?: EChaosRemovalSortMethod): {RemovalEvents: ChaosRemovalEventData[]};
	SortCollisionEvents(CollisionEvents?: ChaosCollisionEventData[],SortMethod?: EChaosCollisionSortMethod): {CollisionEvents: ChaosCollisionEventData[]};
	SortBreakingEvents(BreakingEvents?: ChaosBreakingEventData[],SortMethod?: EChaosBreakingSortMethod): {BreakingEvents: ChaosBreakingEventData[]};
	SetTrailingEventRequestSettings(InSettings: ChaosTrailingEventRequestSettings): void;
	SetTrailingEventEnabled(bIsEnabled: boolean): void;
	SetRemovalEventRequestSettings(InSettings: ChaosRemovalEventRequestSettings): void;
	SetRemovalEventEnabled(bIsEnabled: boolean): void;
	SetCollisionEventRequestSettings(InSettings: ChaosCollisionEventRequestSettings): void;
	SetCollisionEventEnabled(bIsEnabled: boolean): void;
	SetBreakingEventRequestSettings(InSettings: ChaosBreakingEventRequestSettings): void;
	SetBreakingEventEnabled(bIsEnabled: boolean): void;
	RemoveGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	RemoveChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	IsEventListening(): boolean;
	AddGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	AddChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	static C(Other: UObject | any): ChaosDestructionListener;
}

declare type EAnimExecutionContextConversionResult = 'Succeeded' | 'Failed' | 'EAnimExecutionContextConversionResult_MAX';
declare var EAnimExecutionContextConversionResult : { Succeeded:'Succeeded',Failed:'Failed',EAnimExecutionContextConversionResult_MAX:'EAnimExecutionContextConversionResult_MAX', };
declare class AnimComponentSpacePoseContext extends AnimExecutionContext { 
	clone() : AnimComponentSpacePoseContext;
	static C(Other: UObject | any): AnimComponentSpacePoseContext;
}

declare class AnimInitializationContext extends AnimExecutionContext { 
	clone() : AnimInitializationContext;
	static C(Other: UObject | any): AnimInitializationContext;
}

declare class AnimPoseContext extends AnimExecutionContext { 
	clone() : AnimPoseContext;
	static C(Other: UObject | any): AnimPoseContext;
}

declare class AnimExecutionContext { 
	clone() : AnimExecutionContext;
	static C(Other: UObject | any): AnimExecutionContext;
	ConvertToComponentSpacePoseContext(Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimComponentSpacePoseContext};
	ConvertToInitializationContext(Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimInitializationContext};
	ConvertToPoseContext(Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimPoseContext};
	ConvertToUpdateContext(Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimUpdateContext};
	GetAnimInstance(): AnimInstance;
	static ConvertToComponentSpacePoseContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimComponentSpacePoseContext};
	static ConvertToInitializationContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimInitializationContext};
	static ConvertToPoseContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimPoseContext};
	static ConvertToUpdateContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimUpdateContext};
	static GetAnimInstance(Context: AnimExecutionContext): AnimInstance;
}

declare class AnimUpdateContext extends AnimExecutionContext { 
	clone() : AnimUpdateContext;
	static C(Other: UObject | any): AnimUpdateContext;
	SetSequenceWithInertialBlending(SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase,BlendTime: number): SequencePlayerReference;
	AdvanceTime(SequenceEvaluator: SequenceEvaluatorReference,PlayRate: number): SequenceEvaluatorReference;
	SetSequenceWithInertialBlending(SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase,BlendTime: number): SequenceEvaluatorReference;
	GetCurrentWeight(): number;
	GetDeltaTime(): number;
	IsStateBlendingIn(UNode: AnimationStateResultReference): boolean;
	IsStateBlendingOut(UNode: AnimationStateResultReference): boolean;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase,BlendTime: number): SequencePlayerReference;
	static AdvanceTime(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,PlayRate: number): SequenceEvaluatorReference;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase,BlendTime: number): SequenceEvaluatorReference;
	static GetCurrentWeight(Context: AnimUpdateContext): number;
	static GetDeltaTime(Context: AnimUpdateContext): number;
	static IsStateBlendingIn(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static IsStateBlendingOut(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
}

declare class AnimationStateMachineLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimationStateMachineLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineLibrary;
	static GetDefaultObject(): AnimationStateMachineLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineLibrary;
	static IsStateBlendingOut(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static IsStateBlendingIn(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static ConvertToAnimationStateResultPure(UNode: AnimNodeReference,AnimationState?: AnimationStateResultReference,Result?: boolean): {AnimationState: AnimationStateResultReference, Result: boolean};
	static ConvertToAnimationStateResult(UNode: AnimNodeReference,AnimationState?: AnimationStateResultReference,Result?: EAnimNodeReferenceConversionResult): {AnimationState: AnimationStateResultReference, Result: EAnimNodeReferenceConversionResult};
	static C(Other: UObject | any): AnimationStateMachineLibrary;
}

declare class AnimExecutionContextLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimExecutionContextLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimExecutionContextLibrary;
	static GetDefaultObject(): AnimExecutionContextLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimExecutionContextLibrary;
	Prototype_ThreadSafeAnimUpdateCall(Context: AnimUpdateContext,UNode: AnimNodeReference): void;
	Prototype_ThreadSafeAnimNodeCall(Context: AnimExecutionContext,UNode: AnimNodeReference): void;
	static GetDeltaTime(Context: AnimUpdateContext): number;
	static GetCurrentWeight(Context: AnimUpdateContext): number;
	static GetAnimNodeReference(Instance: AnimInstance,index: number): AnimNodeReference;
	static GetAnimInstance(Context: AnimExecutionContext): AnimInstance;
	static ConvertToUpdateContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimUpdateContext};
	static ConvertToPoseContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimPoseContext};
	static ConvertToInitializationContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimInitializationContext};
	static ConvertToComponentSpacePoseContext(Context: AnimExecutionContext,Result?: EAnimExecutionContextConversionResult): {Result: EAnimExecutionContextConversionResult, $: AnimComponentSpacePoseContext};
	static C(Other: UObject | any): AnimExecutionContextLibrary;
}

declare class AnimNotify_PlayMontageNotify extends AnimNotify { 
	NotifyName: string;
	static Load(ResourceName: string): AnimNotify_PlayMontageNotify;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PlayMontageNotify;
	static GetDefaultObject(): AnimNotify_PlayMontageNotify;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PlayMontageNotify;
	static C(Other: UObject | any): AnimNotify_PlayMontageNotify;
}

declare class AnimNotify_PlayMontageNotifyWindow extends AnimNotifyState { 
	NotifyName: string;
	static Load(ResourceName: string): AnimNotify_PlayMontageNotifyWindow;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PlayMontageNotifyWindow;
	static GetDefaultObject(): AnimNotify_PlayMontageNotifyWindow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PlayMontageNotifyWindow;
	static C(Other: UObject | any): AnimNotify_PlayMontageNotifyWindow;
}

declare class AnimSequencerInstance extends AnimInstance { 
	static Load(ResourceName: string): AnimSequencerInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSequencerInstance;
	static GetDefaultObject(): AnimSequencerInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequencerInstance;
	static C(Other: UObject | any): AnimSequencerInstance;
}

declare class PositionHistory { 
	Positions: Vector[];
	Range: number;
	clone() : PositionHistory;
	static C(Other: UObject | any): PositionHistory;
}

declare type EEasingFuncType = 'Linear' | 'Sinusoidal' | 'Cubic' | 'QuadraticInOut' | 'CubicInOut' | 'HermiteCubic' | 'QuarticInOut' | 'QuinticInOut' | 'CircularIn' | 'CircularOut' | 'CircularInOut' | 'ExpIn' | 'ExpOut' | 'ExpInOut' | 'CustomCurve' | 'EEasingFuncType_MAX';
declare var EEasingFuncType : { Linear:'Linear',Sinusoidal:'Sinusoidal',Cubic:'Cubic',QuadraticInOut:'QuadraticInOut',CubicInOut:'CubicInOut',HermiteCubic:'HermiteCubic',QuarticInOut:'QuarticInOut',QuinticInOut:'QuinticInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut',ExpIn:'ExpIn',ExpOut:'ExpOut',ExpInOut:'ExpInOut',CustomCurve:'CustomCurve',EEasingFuncType_MAX:'EEasingFuncType_MAX', };
declare class KismetAnimationLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetAnimationLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetAnimationLibrary;
	static GetDefaultObject(): KismetAnimationLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetAnimationLibrary;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static K2_StartProfilingTimer(): void;
	static K2_MakePerlinNoiseVectorAndRemap(X: number,Y: number,Z: number,RangeOutMinX: number,RangeOutMaxX: number,RangeOutMinY: number,RangeOutMaxY: number,RangeOutMinZ: number,RangeOutMaxZ: number): Vector;
	static K2_MakePerlinNoiseAndRemap(Value: number,RangeOutMin: number,RangeOutMax: number): number;
	static K2_LookAt(CurrentTransform: Transform,TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	static K2_EndProfilingTimer(bLog: boolean,LogPrefix: string): number;
	static K2_DistanceBetweenTwoSocketsAndMapRange(Component: SkeletalMeshComponent,SocketOrBoneNameA: string,SocketSpaceA: ERelativeTransformSpace,SocketOrBoneNameB: string,SocketSpaceB: ERelativeTransformSpace,bRemapRange: boolean,InRangeMin: number,InRangeMax: number,OutRangeMin: number,OutRangeMax: number): number;
	static K2_DirectionBetweenSockets(Component: SkeletalMeshComponent,SocketOrBoneNameFrom: string,SocketOrBoneNameTo: string): Vector;
	static K2_CalculateVelocityFromSockets(DeltaSeconds: number,Component: SkeletalMeshComponent,SocketOrBoneName: string,ReferenceSocketOrBone: string,SocketSpace: ERelativeTransformSpace,OffsetInBoneSpace: Vector,History?: PositionHistory,NumberOfSamples?: number,VelocityMin?: number,VelocityMax?: number,EasingType?: EEasingFuncType,CustomCurve?: RuntimeFloatCurve): {History: PositionHistory, $: number};
	static K2_CalculateVelocityFromPositionHistory(DeltaSeconds: number,position: Vector,History?: PositionHistory,NumberOfSamples?: number,VelocityMin?: number,VelocityMax?: number): {History: PositionHistory, $: number};
	static CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	static C(Other: UObject | any): KismetAnimationLibrary;
}

declare class LinkedAnimGraphLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LinkedAnimGraphLibrary;
	static Find(Outer: UObject, ResourceName: string): LinkedAnimGraphLibrary;
	static GetDefaultObject(): LinkedAnimGraphLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkedAnimGraphLibrary;
	static HasLinkedAnimInstance(UNode: LinkedAnimGraphReference): boolean;
	static GetLinkedAnimInstance(UNode: LinkedAnimGraphReference): AnimInstance;
	static ConvertToLinkedAnimGraphPure(UNode: AnimNodeReference,LinkedAnimGraph?: LinkedAnimGraphReference,Result?: boolean): {LinkedAnimGraph: LinkedAnimGraphReference, Result: boolean};
	static ConvertToLinkedAnimGraph(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: LinkedAnimGraphReference};
	static C(Other: UObject | any): LinkedAnimGraphLibrary;
}

declare class BranchingPointNotifyPayload { 
	clone() : BranchingPointNotifyPayload;
	static C(Other: UObject | any): BranchingPointNotifyPayload;
}

declare class PlayMontageCallbackProxy extends UObject { 
	OnCompleted: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnBlendOut: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnInterrupted: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnNotifyBegin: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnNotifyEnd: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	static Load(ResourceName: string): PlayMontageCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): PlayMontageCallbackProxy;
	static GetDefaultObject(): PlayMontageCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayMontageCallbackProxy;
	OnNotifyEndReceived(NotifyName: string,BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;
	OnNotifyBeginReceived(NotifyName: string,BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;
	OnMontageEnded(Montage: AnimMontage,bInterrupted: boolean): void;
	OnMontageBlendingOut(Montage: AnimMontage,bInterrupted: boolean): void;
	static CreateProxyObjectForPlayMontage(InSkeletalMeshComponent: SkeletalMeshComponent,MontageToPlay: AnimMontage,PlayRate: number,StartingPosition: number,StartingSection: string): PlayMontageCallbackProxy;
	static C(Other: UObject | any): PlayMontageCallbackProxy;
}

declare class SequenceEvaluatorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceEvaluatorLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceEvaluatorLibrary;
	static GetDefaultObject(): SequenceEvaluatorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceEvaluatorLibrary;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase,BlendTime: number): SequenceEvaluatorReference;
	static SetSequence(SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase): SequenceEvaluatorReference;
	static SetExplicitTime(SequenceEvaluator: SequenceEvaluatorReference,Time: number): SequenceEvaluatorReference;
	static GetSequence(SequenceEvaluator: SequenceEvaluatorReference): AnimSequenceBase;
	static GetAccumulatedTime(SequenceEvaluator: SequenceEvaluatorReference): number;
	static ConvertToSequenceEvaluatorPure(UNode: AnimNodeReference,SequenceEvaluator?: SequenceEvaluatorReference,Result?: boolean): {SequenceEvaluator: SequenceEvaluatorReference, Result: boolean};
	static ConvertToSequenceEvaluator(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SequenceEvaluatorReference};
	static AdvanceTime(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,PlayRate: number): SequenceEvaluatorReference;
	static C(Other: UObject | any): SequenceEvaluatorLibrary;
}

declare class SequencePlayerLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequencePlayerLibrary;
	static Find(Outer: UObject, ResourceName: string): SequencePlayerLibrary;
	static GetDefaultObject(): SequencePlayerLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencePlayerLibrary;
	static SetStartPosition(SequencePlayer: SequencePlayerReference,StartPosition: number): SequencePlayerReference;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase,BlendTime: number): SequencePlayerReference;
	static SetSequence(SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase): SequencePlayerReference;
	static SetPlayRate(SequencePlayer: SequencePlayerReference,PlayRate: number): SequencePlayerReference;
	static SetAccumulatedTime(SequencePlayer: SequencePlayerReference,Time: number): SequencePlayerReference;
	static GetStartPosition(SequencePlayer: SequencePlayerReference): number;
	static GetSequencePure(SequencePlayer: SequencePlayerReference): AnimSequenceBase;
	static GetSequence(SequencePlayer: SequencePlayerReference,SequenceBase?: AnimSequenceBase): {SequenceBase: AnimSequenceBase, $: SequencePlayerReference};
	static GetPlayRate(SequencePlayer: SequencePlayerReference): number;
	static GetLoopAnimation(SequencePlayer: SequencePlayerReference): boolean;
	static GetAccumulatedTime(SequencePlayer: SequencePlayerReference): number;
	static ConvertToSequencePlayerPure(UNode: AnimNodeReference,SequencePlayer?: SequencePlayerReference,Result?: boolean): {SequencePlayer: SequencePlayerReference, Result: boolean};
	static ConvertToSequencePlayer(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SequencePlayerReference};
	static C(Other: UObject | any): SequencePlayerLibrary;
}

declare class SequencerAnimationSupport extends Interface { 
	static Load(ResourceName: string): SequencerAnimationSupport;
	static Find(Outer: UObject, ResourceName: string): SequencerAnimationSupport;
	static GetDefaultObject(): SequencerAnimationSupport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerAnimationSupport;
	static C(Other: UObject | any): SequencerAnimationSupport;
}

declare class SkeletalControlLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SkeletalControlLibrary;
	static Find(Outer: UObject, ResourceName: string): SkeletalControlLibrary;
	static GetDefaultObject(): SkeletalControlLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalControlLibrary;
	static SetAlpha(SkeletalControl: SkeletalControlReference,Alpha: number): SkeletalControlReference;
	static GetAlpha(SkeletalControl: SkeletalControlReference): number;
	static ConvertToSkeletalControlPure(UNode: AnimNodeReference,SkeletalControl?: SkeletalControlReference,Result?: boolean): {SkeletalControl: SkeletalControlReference, Result: boolean};
	static ConvertToSkeletalControl(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SkeletalControlReference};
	static C(Other: UObject | any): SkeletalControlLibrary;
}

declare class CurveEditorFilterBase extends UObject { 
	static Load(ResourceName: string): CurveEditorFilterBase;
	static Find(Outer: UObject, ResourceName: string): CurveEditorFilterBase;
	static GetDefaultObject(): CurveEditorFilterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorFilterBase;
	static C(Other: UObject | any): CurveEditorFilterBase;
}

declare class CurveEditorBakeFilter extends CurveEditorFilterBase { 
	bUseFrameBake: boolean;
	BakeIntervalInFrames: FrameNumber;
	BakeIntervalInSeconds: number;
	static Load(ResourceName: string): CurveEditorBakeFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorBakeFilter;
	static GetDefaultObject(): CurveEditorBakeFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorBakeFilter;
	static C(Other: UObject | any): CurveEditorBakeFilter;
}

declare class KeyPosition { 
	InputValue: any;
	OutputValue: any;
	clone() : KeyPosition;
	static C(Other: UObject | any): KeyPosition;
}

declare class KeyAttributes { 
	bHasArriveTangent: boolean;
	bHasLeaveTangent: boolean;
	bHasInterpMode: boolean;
	bHasTangentMode: boolean;
	bHasTangentWeightMode: boolean;
	bHasArriveTangentWeight: boolean;
	bHasLeaveTangentWeight: boolean;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	ArriveTangentWeight: number;
	LeaveTangentWeight: number;
	clone() : KeyAttributes;
	static C(Other: UObject | any): KeyAttributes;
}

declare class CurveEditorCopyableCurveKeys extends UObject { 
	KeyPositions: KeyPosition[];
	KeyAttributes: KeyAttributes[];
	ShortDisplayName: string;
	LongDisplayName: string;
	IntentionName: string;
	static Load(ResourceName: string): CurveEditorCopyableCurveKeys;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyableCurveKeys;
	static GetDefaultObject(): CurveEditorCopyableCurveKeys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyableCurveKeys;
	static C(Other: UObject | any): CurveEditorCopyableCurveKeys;
}

declare class CurveEditorCopyBuffer extends UObject { 
	Curves: CurveEditorCopyableCurveKeys[];
	TimeOffset: any;
	bAbsolutePosition: boolean;
	static Load(ResourceName: string): CurveEditorCopyBuffer;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyBuffer;
	static GetDefaultObject(): CurveEditorCopyBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyBuffer;
	static C(Other: UObject | any): CurveEditorCopyBuffer;
}

declare class CurveEditorEulerFilter extends CurveEditorFilterBase { 
	static Load(ResourceName: string): CurveEditorEulerFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorEulerFilter;
	static GetDefaultObject(): CurveEditorEulerFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorEulerFilter;
	static C(Other: UObject | any): CurveEditorEulerFilter;
}

declare class CurveEditorKeyProxy extends Interface { 
	static Load(ResourceName: string): CurveEditorKeyProxy;
	static Find(Outer: UObject, ResourceName: string): CurveEditorKeyProxy;
	static GetDefaultObject(): CurveEditorKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorKeyProxy;
	static C(Other: UObject | any): CurveEditorKeyProxy;
}

declare class CurveEditorReduceFilter extends CurveEditorFilterBase { 
	Tolerance: number;
	static Load(ResourceName: string): CurveEditorReduceFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorReduceFilter;
	static GetDefaultObject(): CurveEditorReduceFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorReduceFilter;
	static C(Other: UObject | any): CurveEditorReduceFilter;
}

declare type ECurveEditorTangentVisibility = 'AllTangents' | 'SelectedKeys' | 'NoTangents' | 'ECurveEditorTangentVisibility_MAX';
declare var ECurveEditorTangentVisibility : { AllTangents:'AllTangents',SelectedKeys:'SelectedKeys',NoTangents:'NoTangents',ECurveEditorTangentVisibility_MAX:'ECurveEditorTangentVisibility_MAX', };
declare type ECurveEditorZoomPosition = 'CurrentTime' | 'MousePosition' | 'ECurveEditorZoomPosition_MAX';
declare var ECurveEditorZoomPosition : { CurrentTime:'CurrentTime',MousePosition:'MousePosition',ECurveEditorZoomPosition_MAX:'ECurveEditorZoomPosition_MAX', };
declare class CustomColorForChannel { 
	UObject: Class;
	PropertyName: string;
	Color: LinearColor;
	clone() : CustomColorForChannel;
	static C(Other: UObject | any): CustomColorForChannel;
}

declare class CustomColorForSpaceSwitch { 
	ControlName: string;
	Color: LinearColor;
	clone() : CustomColorForSpaceSwitch;
	static C(Other: UObject | any): CustomColorForSpaceSwitch;
}

declare class CurveEditorSettings extends UObject { 
	bAutoFrameCurveEditor: boolean;
	FrameInputPadding: number;
	FrameOutputPadding: number;
	bShowCurveEditorCurveToolTips: boolean;
	TangentVisibility: ECurveEditorTangentVisibility;
	ZoomPosition: ECurveEditorZoomPosition;
	CustomColors: CustomColorForChannel[];
	ParentSpaceCustomColor: LinearColor;
	WorldSpaceCustomColor: LinearColor;
	ControlSpaceCustomColors: CustomColorForSpaceSwitch[];
	static Load(ResourceName: string): CurveEditorSettings;
	static Find(Outer: UObject, ResourceName: string): CurveEditorSettings;
	static GetDefaultObject(): CurveEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorSettings;
	static C(Other: UObject | any): CurveEditorSettings;
}

declare class RichCurveKeyProxy extends UObject { 
	Value: RichCurveKey;
	static Load(ResourceName: string): RichCurveKeyProxy;
	static Find(Outer: UObject, ResourceName: string): RichCurveKeyProxy;
	static GetDefaultObject(): RichCurveKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichCurveKeyProxy;
	static C(Other: UObject | any): RichCurveKeyProxy;
}

declare class SourceControlState { 
	Filename: string;
	bIsValid: boolean;
	bIsUnknown: boolean;
	bCanCheckIn: boolean;
	bCanCheckOut: boolean;
	bIsCheckedOut: boolean;
	bIsCurrent: boolean;
	bIsSourceControlled: boolean;
	bIsAdded: boolean;
	bIsDeleted: boolean;
	bIsIgnored: boolean;
	bCanEdit: boolean;
	bCanDelete: boolean;
	bIsModified: boolean;
	bCanAdd: boolean;
	bIsConflicted: boolean;
	bCanRevert: boolean;
	bIsCheckedOutOther: boolean;
	CheckedOutOther: string;
	clone() : SourceControlState;
	static C(Other: UObject | any): SourceControlState;
}

declare class SourceControlHelpers extends UObject { 
	static Load(ResourceName: string): SourceControlHelpers;
	static Find(Outer: UObject, ResourceName: string): SourceControlHelpers;
	static GetDefaultObject(): SourceControlHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlHelpers;
	static SyncFiles(InFiles: string[],bSilent: boolean): boolean;
	static SyncFile(InFile: string,bSilent: boolean): boolean;
	static RevertUnchangedFiles(InFiles: string[],bSilent: boolean): boolean;
	static RevertUnchangedFile(InFile: string,bSilent: boolean): boolean;
	static RevertFiles(InFiles: string[],bSilent: boolean): boolean;
	static RevertFile(InFile: string,bSilent: boolean): boolean;
	static QueryFileState(InFile: string,bSilent: boolean): SourceControlState;
	static MarkFilesForDelete(InFiles: string[],bSilent: boolean): boolean;
	static MarkFilesForAdd(InFiles: string[],bSilent: boolean): boolean;
	static MarkFileForDelete(InFile: string,bSilent: boolean): boolean;
	static MarkFileForAdd(InFile: string,bSilent: boolean): boolean;
	static LastErrorMsg(): string;
	static IsEnabled(): boolean;
	static IsAvailable(): boolean;
	static CurrentProvider(): string;
	static CopyFile(InSourceFile: string,InDestFile: string,bSilent: boolean): boolean;
	static CheckOutOrAddFiles(InFiles: string[],bSilent: boolean): boolean;
	static CheckOutOrAddFile(InFile: string,bSilent: boolean): boolean;
	static CheckOutFiles(InFiles: string[],bSilent: boolean): boolean;
	static CheckOutFile(InFile: string,bSilent: boolean): boolean;
	static CheckInFiles(InFiles: string[],InDescription: string,bSilent: boolean): boolean;
	static CheckInFile(InFile: string,InDescription: string,bSilent: boolean): boolean;
	static C(Other: UObject | any): SourceControlHelpers;
}

declare class SourceControlPreferences extends DeveloperSettings { 
	bEnableValidationTag: boolean;
	bShouldDeleteNewFilesOnRevert: boolean;
	CollectionChangelistTags: string[];
	SpecificCollectionChangelistTags: any;
	static Load(ResourceName: string): SourceControlPreferences;
	static Find(Outer: UObject, ResourceName: string): SourceControlPreferences;
	static GetDefaultObject(): SourceControlPreferences;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlPreferences;
	static C(Other: UObject | any): SourceControlPreferences;
}

declare type ECookProgressDisplayMode = 'Nothing' | 'RemainingPackages' | 'PackageNames' | 'NamesAndRemainingPackages' | 'Instigators' | 'InstigatorsAndCount' | 'InstigatorsAndNames' | 'InstigatorsAndNamesAndCount' | 'Max' | 'ECookProgressDisplayMode_MAX';
declare var ECookProgressDisplayMode : { Nothing:'Nothing',RemainingPackages:'RemainingPackages',PackageNames:'PackageNames',NamesAndRemainingPackages:'NamesAndRemainingPackages',Instigators:'Instigators',InstigatorsAndCount:'InstigatorsAndCount',InstigatorsAndNames:'InstigatorsAndNames',InstigatorsAndNamesAndCount:'InstigatorsAndNamesAndCount',Max:'Max',ECookProgressDisplayMode_MAX:'ECookProgressDisplayMode_MAX', };
declare type EBlueprintComponentDataCookingMethod = 'Disabled' | 'AllBlueprints' | 'EnabledBlueprintsOnly' | 'EBlueprintComponentDataCookingMethod_MAX';
declare var EBlueprintComponentDataCookingMethod : { Disabled:'Disabled',AllBlueprints:'AllBlueprints',EnabledBlueprintsOnly:'EnabledBlueprintsOnly',EBlueprintComponentDataCookingMethod_MAX:'EBlueprintComponentDataCookingMethod_MAX', };
declare type ETextureFormatASTCCompressor = 'IntelISPC' | 'Arm' | 'Max' | 'ETextureFormatASTCCompressor_MAX';
declare var ETextureFormatASTCCompressor : { IntelISPC:'IntelISPC',Arm:'Arm',Max:'Max',ETextureFormatASTCCompressor_MAX:'ETextureFormatASTCCompressor_MAX', };
declare class CookerSettings extends DeveloperSettings { 
	bEnableCookOnTheSide: boolean;
	bEnableBuildDDCInBackground: boolean;
	bIterativeCookingForLaunchOn: boolean;
	bIterativeCookingForFileCookContent: boolean;
	bCookOnTheFlyForLaunchOn: boolean;
	CookProgressDisplayMode: ECookProgressDisplayMode;
	bIgnoreIniSettingsOutOfDateForIteration: boolean;
	bIgnoreScriptPackagesOutOfDateForIteration: boolean;
	bCompileBlueprintsInDevelopmentMode: boolean;
	BlueprintComponentDataCookingMethod: EBlueprintComponentDataCookingMethod;
	ClassesExcludedOnDedicatedServer: string[];
	ModulesExcludedOnDedicatedServer: string[];
	ClassesExcludedOnDedicatedClient: string[];
	ModulesExcludedOnDedicatedClient: string[];
	VersionedIntRValues: string[];
	DefaultASTCQualityBySpeed: number;
	DefaultASTCQualityBySize: number;
	DefaultASTCCompressor: ETextureFormatASTCCompressor;
	bAllowASTCHDRProfile: boolean;
	bAllowCookedDataInEditorBuilds: boolean;
	bCookBlueprintComponentTemplateData: boolean;
	static Load(ResourceName: string): CookerSettings;
	static Find(Outer: UObject, ResourceName: string): CookerSettings;
	static GetDefaultObject(): CookerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerSettings;
	static C(Other: UObject | any): CookerSettings;
}

declare type EProjectPackagingBuild = 'Always' | 'Never' | 'IfProjectHasCode' | 'IfEditorWasBuiltLocally' | 'EProjectPackagingBuild_MAX';
declare var EProjectPackagingBuild : { Always:'Always',Never:'Never',IfProjectHasCode:'IfProjectHasCode',IfEditorWasBuiltLocally:'IfEditorWasBuiltLocally',EProjectPackagingBuild_MAX:'EProjectPackagingBuild_MAX', };
declare type EProjectPackagingBuildConfigurations = 'PPBC_Debug' | 'PPBC_DebugGame' | 'PPBC_Development' | 'PPBC_Test' | 'PPBC_Shipping' | 'PPBC_MAX';
declare var EProjectPackagingBuildConfigurations : { PPBC_Debug:'PPBC_Debug',PPBC_DebugGame:'PPBC_DebugGame',PPBC_Development:'PPBC_Development',PPBC_Test:'PPBC_Test',PPBC_Shipping:'PPBC_Shipping',PPBC_MAX:'PPBC_MAX', };
declare class DirectoryPath { 
	Path: string;
	clone() : DirectoryPath;
	static C(Other: UObject | any): DirectoryPath;
}

declare type EProjectPackagingBlueprintNativizationMethod = 'Disabled' | 'Inclusive' | 'Exclusive' | 'EProjectPackagingBlueprintNativizationMethod_MAX';
declare var EProjectPackagingBlueprintNativizationMethod : { Disabled:'Disabled',Inclusive:'Inclusive',Exclusive:'Exclusive',EProjectPackagingBlueprintNativizationMethod_MAX:'EProjectPackagingBlueprintNativizationMethod_MAX', };
declare type EProjectPackagingInternationalizationPresets = 'English' | 'EFIGS' | 'EFIGSCJK' | 'CJK' | 'All' | 'EProjectPackagingInternationalizationPresets_MAX';
declare var EProjectPackagingInternationalizationPresets : { English:'English',EFIGS:'EFIGS',EFIGSCJK:'EFIGSCJK',CJK:'CJK',All:'All',EProjectPackagingInternationalizationPresets_MAX:'EProjectPackagingInternationalizationPresets_MAX', };
declare class ProjectBuildSettings { 
	Name: string;
	SpecificPlatforms: string[];
	BuildCookRunParams: string;
	clone() : ProjectBuildSettings;
	static C(Other: UObject | any): ProjectBuildSettings;
}

declare class ProjectPackagingSettings extends UObject { 
	Build: EProjectPackagingBuild;
	BuildConfiguration: EProjectPackagingBuildConfigurations;
	BuildTarget: string;
	LaunchOnTarget: string;
	StagingDirectory: DirectoryPath;
	FullRebuild: boolean;
	ForDistribution: boolean;
	IncludeDebugFiles: boolean;
	BlueprintNativizationMethod: EProjectPackagingBlueprintNativizationMethod;
	NativizeBlueprintAssets: FilePath[];
	bIncludeNativizedAssetsInProjectGeneration: boolean;
	bExcludeMonolithicEngineHeadersInNativizedCode: boolean;
	UsePakFile: boolean;
	bUseIoStore: boolean;
	bUseZenStore: boolean;
	bMakeBinaryConfig: boolean;
	bGenerateChunks: boolean;
	bGenerateNoChunks: boolean;
	bChunkHardReferencesOnly: boolean;
	bForceOneChunkPerFile: boolean;
	MaxChunkSize: any;
	bBuildHttpChunkInstallData: boolean;
	HttpChunkInstallDataDirectory: DirectoryPath;
	bCompressed: boolean;
	PackageCompressionFormat: string;
	bForceUseProjectCompressionFormatIgnoreHardwareOverride: boolean;
	PackageAdditionalCompressionOptions: string;
	PackageCompressionMethod: string;
	PackageCompressionLevel_DebugDevelopment: number;
	PackageCompressionLevel_TestShipping: number;
	PackageCompressionLevel_Distribution: number;
	PackageCompressionMinBytesSaved: number;
	PackageCompressionMinPercentSaved: number;
	bPackageCompressionEnableDDC: boolean;
	PackageCompressionMinSizeToConsiderDDC: number;
	HttpChunkInstallDataVersion: string;
	IncludePrerequisites: boolean;
	IncludeAppLocalPrerequisites: boolean;
	bShareMaterialShaderCode: boolean;
	bDeterministicShaderCodeOrder: boolean;
	bSharedMaterialNativeLibraries: boolean;
	ApplocalPrerequisitesDirectory: DirectoryPath;
	IncludeCrashReporter: boolean;
	InternationalizationPreset: EProjectPackagingInternationalizationPresets;
	CulturesToStage: string[];
	LocalizationTargetsToChunk: string[];
	LocalizationTargetCatchAllChunkId: number;
	bCookAll: boolean;
	bCookMapsOnly: boolean;
	bEncryptIniFiles: boolean;
	bEncryptPakIndex: boolean;
	GenerateEarlyDownloaderPakFile: boolean;
	bSkipEditorContent: boolean;
	bSkipMovies: boolean;
	UFSMovies: string[];
	NonUFSMovies: string[];
	CompressedChunkWildcard: string[];
	IniKeyBlacklist: string[];
	IniSectionBlacklist: string[];
	EarlyDownloaderPakFileFiles: string[];
	MapsToCook: FilePath[];
	DirectoriesToAlwaysCook: DirectoryPath[];
	DirectoriesToNeverCook: DirectoryPath[];
	TestDirectoriesToNotSearch: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFSServer: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFSServer: DirectoryPath[];
	ProjectCustomBuilds: ProjectBuildSettings[];
	EngineCustomBuilds: ProjectBuildSettings[];
	PerPlatformBuildConfig: any;
	PerPlatformTargetFlavorName: any;
	PerPlatformBuildTarget: any;
	static Load(ResourceName: string): ProjectPackagingSettings;
	static Find(Outer: UObject, ResourceName: string): ProjectPackagingSettings;
	static GetDefaultObject(): ProjectPackagingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProjectPackagingSettings;
	static C(Other: UObject | any): ProjectPackagingSettings;
}

declare type ETextureEditorBackgrounds = 'TextureEditorBackground_SolidColor' | 'TextureEditorBackground_Checkered' | 'TextureEditorBackground_CheckeredFill' | 'TextureEditorBackground_MAX';
declare var ETextureEditorBackgrounds : { TextureEditorBackground_SolidColor:'TextureEditorBackground_SolidColor',TextureEditorBackground_Checkered:'TextureEditorBackground_Checkered',TextureEditorBackground_CheckeredFill:'TextureEditorBackground_CheckeredFill',TextureEditorBackground_MAX:'TextureEditorBackground_MAX', };
declare type ETextureEditorVolumeViewMode = 'TextureEditorVolumeViewMode_DepthSlices' | 'TextureEditorVolumeViewMode_VolumeTrace' | 'TextureEditorVolumeViewMode_MAX';
declare var ETextureEditorVolumeViewMode : { TextureEditorVolumeViewMode_DepthSlices:'TextureEditorVolumeViewMode_DepthSlices',TextureEditorVolumeViewMode_VolumeTrace:'TextureEditorVolumeViewMode_VolumeTrace',TextureEditorVolumeViewMode_MAX:'TextureEditorVolumeViewMode_MAX', };
declare type ETextureEditorZoomMode = 'Custom' | 'Fit' | 'Fill' | 'ETextureEditorZoomMode_MAX';
declare var ETextureEditorZoomMode : { Custom:'Custom',Fit:'Fit',Fill:'Fill',ETextureEditorZoomMode_MAX:'ETextureEditorZoomMode_MAX', };
declare class TextureEditorSettings extends UObject { 
	Background: ETextureEditorBackgrounds;
	VolumeViewMode: ETextureEditorVolumeViewMode;
	BackgroundColor: Color;
	CheckerColorOne: Color;
	CheckerColorTwo: Color;
	CheckerSize: number;
	FitToViewport: boolean;
	ZoomMode: ETextureEditorZoomMode;
	TextureBorderColor: Color;
	TextureBorderEnabled: boolean;
	static Load(ResourceName: string): TextureEditorSettings;
	static Find(Outer: UObject, ResourceName: string): TextureEditorSettings;
	static GetDefaultObject(): TextureEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureEditorSettings;
	static C(Other: UObject | any): TextureEditorSettings;
}

declare class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent { 
	bUseTranslatedInstanceSpace: boolean;
	TranslatedInstanceSpaceOrigin: Vector;
	SortedInstances: number[];
	NumBuiltInstances: number;
	BuiltInstanceBounds: Box;
	UnbuiltInstanceBounds: Box;
	UnbuiltInstanceBoundsList: Box[];
	bEnableDensityScaling: boolean;
	OcclusionLayerNumNodes: number;
	CacheMeshExtendedBounds: BoxSphereBounds;
	bDisableCollision: boolean;
	InstanceCountToRender: number;
	static Load(ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static GetDefaultObject(): HierarchicalInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalInstancedStaticMeshComponent;
	static C(Other: UObject | any): HierarchicalInstancedStaticMeshComponent;
}

declare class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent { 
	OnInstanceTakePointDamage: UnrealEngineMulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: Controller, HitLocation: Vector, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnInstanceTakeRadialDamage: UnrealEngineMulticastDelegate<(Instances: number[], Damages: number[], InstigatedBy: Controller, Origin: Vector, MaxRadius: number, DamageType: DamageType, DamageCauser: Actor) => void>;
	bEnableDiscardOnLoad: boolean;
	FoliageHiddenEditorViews: any;
	GenerationGuid: Guid;
	static Load(ResourceName: string): FoliageInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): FoliageInstancedStaticMeshComponent;
	static GetDefaultObject(): FoliageInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageInstancedStaticMeshComponent;
	static C(Other: UObject | any): FoliageInstancedStaticMeshComponent;
}

declare class FoliageStatistics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): FoliageStatistics;
	static Find(Outer: UObject, ResourceName: string): FoliageStatistics;
	static GetDefaultObject(): FoliageStatistics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageStatistics;
	static FoliageOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static FoliageOverlappingBoxTransforms(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box,OutTransforms?: Transform[]): {OutTransforms: Transform[]};
	static FoliageOverlappingBoxCount(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box): number;
	static C(Other: UObject | any): FoliageStatistics;
}

declare type EFoliageScaling = 'Uniform' | 'Free' | 'LockXY' | 'LockXZ' | 'LockYZ' | 'EFoliageScaling_MAX';
declare var EFoliageScaling : { Uniform:'Uniform',Free:'Free',LockXY:'LockXY',LockXZ:'LockXZ',LockYZ:'LockYZ',EFoliageScaling_MAX:'EFoliageScaling_MAX', };
declare class FloatInterval { 
	Min: number;
	Max: number;
	clone() : FloatInterval;
	static C(Other: UObject | any): FloatInterval;
}

declare class FoliageVertexColorChannelMask { 
	UseMask: boolean;
	MaskThreshold: number;
	InvertMask: boolean;
	clone() : FoliageVertexColorChannelMask;
	static C(Other: UObject | any): FoliageVertexColorChannelMask;
}

declare type FoliageVertexColorMask = 'FOLIAGEVERTEXCOLORMASK_Disabled' | 'FOLIAGEVERTEXCOLORMASK_Red' | 'FOLIAGEVERTEXCOLORMASK_Green' | 'FOLIAGEVERTEXCOLORMASK_Blue' | 'FOLIAGEVERTEXCOLORMASK_Alpha' | 'FOLIAGEVERTEXCOLORMASK_MAX';
declare var FoliageVertexColorMask : { FOLIAGEVERTEXCOLORMASK_Disabled:'FOLIAGEVERTEXCOLORMASK_Disabled',FOLIAGEVERTEXCOLORMASK_Red:'FOLIAGEVERTEXCOLORMASK_Red',FOLIAGEVERTEXCOLORMASK_Green:'FOLIAGEVERTEXCOLORMASK_Green',FOLIAGEVERTEXCOLORMASK_Blue:'FOLIAGEVERTEXCOLORMASK_Blue',FOLIAGEVERTEXCOLORMASK_Alpha:'FOLIAGEVERTEXCOLORMASK_Alpha',FOLIAGEVERTEXCOLORMASK_MAX:'FOLIAGEVERTEXCOLORMASK_MAX', };
declare class Int32Interval { 
	Min: number;
	Max: number;
	clone() : Int32Interval;
	static C(Other: UObject | any): Int32Interval;
}

declare class FoliageDensityFalloff { 
	bUseFalloffCurve: boolean;
	FalloffCurve: RuntimeFloatCurve;
	clone() : FoliageDensityFalloff;
	static C(Other: UObject | any): FoliageDensityFalloff;
}

declare class FoliageType extends UObject { 
	UpdateGuid: Guid;
	Density: number;
	DensityAdjustmentFactor: number;
	Radius: number;
	bSingleInstanceModeOverrideRadius: boolean;
	SingleInstanceModeRadius: number;
	Scaling: EFoliageScaling;
	ScaleX: FloatInterval;
	ScaleY: FloatInterval;
	ScaleZ: FloatInterval;
	VertexColorMaskByChannel: FoliageVertexColorChannelMask;
	VertexColorMask: FoliageVertexColorMask;
	VertexColorMaskThreshold: number;
	VertexColorMaskInvert: boolean;
	ZOffset: FloatInterval;
	AlignToNormal: boolean;
	AverageNormal: boolean;
	AverageNormalSingleComponent: boolean;
	AlignMaxAngle: number;
	RandomYaw: boolean;
	RandomPitchAngle: number;
	GroundSlopeAngle: FloatInterval;
	Height: FloatInterval;
	LandscapeLayers: string[];
	MinimumLayerWeight: number;
	ExclusionLandscapeLayers: string[];
	MinimumExclusionLayerWeight: number;
	LandscapeLayer: string;
	CollisionWithWorld: boolean;
	CollisionScale: Vector;
	AverageNormalSampleCount: number;
	MeshBounds: BoxSphereBounds;
	LowBoundOriginRadius: Vector;
	Mobility: EComponentMobility;
	CullDistance: Int32Interval;
	bEnableStaticLighting: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastContactShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	OverriddenLightMapRes: number;
	LightmapType: ELightmapType;
	bUseAsOccluder: boolean;
	bVisibleInRayTracing: boolean;
	bEvaluateWorldPositionOffset: boolean;
	BodyInstance: BodyInstance;
	CustomNavigableGeometry: EHasCustomNavigableGeometry;
	LightingChannels: LightingChannels;
	bRenderCustomDepth: boolean;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	CustomDepthStencilValue: number;
	TranslucencySortPriority: number;
	HiddenEditorViews: any;
	IsSelected: boolean;
	CollisionRadius: number;
	ShadeRadius: number;
	NumSteps: number;
	InitialSeedDensity: number;
	AverageSpreadDistance: number;
	SpreadVariance: number;
	SeedsPerStep: number;
	DistributionSeed: number;
	MaxInitialSeedOffset: number;
	bCanGrowInShade: boolean;
	bSpawnsInShade: boolean;
	MaxInitialAge: number;
	MaxAge: number;
	OverlapPriority: number;
	ProceduralScale: FloatInterval;
	ScaleCurve: RuntimeFloatCurve;
	DensityFalloff: FoliageDensityFalloff;
	ChangeCount: number;
	ReapplyDensity: boolean;
	ReapplyRadius: boolean;
	ReapplyAlignToNormal: boolean;
	ReapplyRandomYaw: boolean;
	ReapplyScaling: boolean;
	ReapplyScaleX: boolean;
	ReapplyScaleY: boolean;
	ReapplyScaleZ: boolean;
	ReapplyRandomPitchAngle: boolean;
	ReapplyGroundSlope: boolean;
	ReapplyHeight: boolean;
	ReapplyLandscapeLayers: boolean;
	ReapplyZOffset: boolean;
	ReapplyCollisionWithWorld: boolean;
	ReapplyVertexColorMask: boolean;
	bEnableDensityScaling: boolean;
	bEnableDiscardOnLoad: boolean;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureCullMips: number;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	bIncludeInHLOD: boolean;
	ScaleMinX: number;
	ScaleMinY: number;
	ScaleMinZ: number;
	ScaleMaxX: number;
	ScaleMaxY: number;
	ScaleMaxZ: number;
	HeightMin: number;
	HeightMax: number;
	ZOffsetMin: number;
	ZOffsetMax: number;
	StartCullDistance: number;
	EndCullDistance: number;
	UniformScale: boolean;
	LockScaleX: boolean;
	LockScaleY: boolean;
	LockScaleZ: boolean;
	GroundSlope: number;
	MinGroundSlope: number;
	MinScale: number;
	MaxScale: number;
	static Load(ResourceName: string): FoliageType;
	static Find(Outer: UObject, ResourceName: string): FoliageType;
	static GetDefaultObject(): FoliageType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType;
	static C(Other: UObject | any): FoliageType;
}

declare class FoliageType_Actor extends FoliageType { 
	ActorClass: UnrealEngineClass;
	bShouldAttachToBaseComponent: boolean;
	bStaticMeshOnly: boolean;
	StaticMeshOnlyComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): FoliageType_Actor;
	static Find(Outer: UObject, ResourceName: string): FoliageType_Actor;
	static GetDefaultObject(): FoliageType_Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_Actor;
	static C(Other: UObject | any): FoliageType_Actor;
}

declare class FoliageType_InstancedStaticMesh extends FoliageType { 
	Mesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	ComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): FoliageType_InstancedStaticMesh;
	static Find(Outer: UObject, ResourceName: string): FoliageType_InstancedStaticMesh;
	static GetDefaultObject(): FoliageType_InstancedStaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMesh;
	static C(Other: UObject | any): FoliageType_InstancedStaticMesh;
}

declare class PartitionActor extends Actor { 
	GridSize: any;
	static GetDefaultObject(): PartitionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartitionActor;
	static C(Other: UObject | any): PartitionActor;
}

declare class ISMComponentDescriptor { 
	Hash: any;
	ComponentClass: UnrealEngineClass;
	StaticMesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	Mobility: EComponentMobility;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	LightmapType: ELightmapType;
	LightingChannels: LightingChannels;
	RayTracingGroupId: number;
	RayTracingGroupCullingPriority: ERayTracingGroupCullingPriority;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	BodyInstance: BodyInstance;
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	VirtualTextureCullMips: number;
	TranslucencySortPriority: number;
	OverriddenLightMapRes: number;
	CustomDepthStencilValue: number;
	HLODBatchingPolicy: EHLODBatchingPolicy;
	bCastShadow: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastContactShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	bUseAsOccluder: boolean;
	bEnableDensityScaling: boolean;
	bEnableDiscardOnLoad: boolean;
	bRenderCustomDepth: boolean;
	bIncludeInHLOD: boolean;
	bVisibleInRayTracing: boolean;
	bHiddenInGame: boolean;
	bIsEditorOnly: boolean;
	bVisible: boolean;
	bConsiderForActorPlacementWhenHidden: boolean;
	clone() : ISMComponentDescriptor;
	static C(Other: UObject | any): ISMComponentDescriptor;
}

declare class ISMComponentInstance { 
	ClientIndex: number;
	InstanceIndex: number;
	InstanceSubIndex: number;
	clone() : ISMComponentInstance;
	static C(Other: UObject | any): ISMComponentInstance;
}

declare class ISMClientInstance { 
	ComponentIndices: number[];
	clone() : ISMClientInstance;
	static C(Other: UObject | any): ISMClientInstance;
}

declare class ISMClientData { 
	Instances: ISMClientInstance[];
	clone() : ISMClientData;
	static C(Other: UObject | any): ISMClientData;
}

declare class ISMComponentData { 
	Instances: ISMComponentInstance[];
	ClientInstances: ISMClientData[];
	Component: InstancedStaticMeshComponent;
	clone() : ISMComponentData;
	static C(Other: UObject | any): ISMComponentData;
}

declare class ISMPartitionActor extends PartitionActor { 
	Clients: Guid[];
	Descriptors: ISMComponentDescriptor[];
	DescriptorComponents: ISMComponentData[];
	ClientInstanceManagers: any;
	static GetDefaultObject(): ISMPartitionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ISMPartitionActor;
	static C(Other: UObject | any): ISMPartitionActor;
}

declare class InstancedFoliageActor extends ISMPartitionActor { 
	static GetDefaultObject(): InstancedFoliageActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedFoliageActor;
	static RemoveAllInstances(WorldContextObject: UObject,InFoliageType: FoliageType): void;
	static AddInstances(WorldContextObject: UObject,InFoliageType: FoliageType,InTransforms: Transform[]): void;
	static C(Other: UObject | any): InstancedFoliageActor;
}

declare type ENavDataGatheringMode = 'Default' | 'Instant' | 'Lazy' | 'ENavDataGatheringMode_MAX';
declare var ENavDataGatheringMode : { Default:'Default',Instant:'Instant',Lazy:'Lazy',ENavDataGatheringMode_MAX:'ENavDataGatheringMode_MAX', };
declare class StaticMeshActor extends Actor { 
	StaticMeshComponent: StaticMeshComponent;
	bStaticMeshReplicateMovement: boolean;
	NavigationGeometryGatheringMode: ENavDataGatheringMode;
	static GetDefaultObject(): StaticMeshActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshActor;
	SetMobility(InMobility: EComponentMobility): void;
	static C(Other: UObject | any): StaticMeshActor;
}

declare class InteractiveFoliageActor extends StaticMeshActor { 
	CapsuleComponent: CapsuleComponent;
	TouchingActorEntryPosition: Vector;
	FoliageVelocity: Vector;
	FoliageForce: Vector;
	FoliagePosition: Vector;
	FoliageDamageImpulseScale: number;
	FoliageTouchImpulseScale: number;
	FoliageStiffness: number;
	FoliageStiffnessQuadratic: number;
	FoliageDamping: number;
	MaxDamageImpulse: number;
	MaxTouchImpulse: number;
	MaxForce: number;
	Mass: number;
	static GetDefaultObject(): InteractiveFoliageActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveFoliageActor;
	CapsuleTouched(OverlappedComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,OtherBodyIndex: number,bFromSweep: boolean,OverlapInfo: HitResult): void;
	static C(Other: UObject | any): InteractiveFoliageActor;
}

declare class InteractiveFoliageComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): InteractiveFoliageComponent;
	static Find(Outer: UObject, ResourceName: string): InteractiveFoliageComponent;
	static GetDefaultObject(): InteractiveFoliageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveFoliageComponent;
	static C(Other: UObject | any): InteractiveFoliageComponent;
}

declare class FoliageTypeObject { 
	FoliageTypeObject: UObject;
	TypeInstance: FoliageType;
	bIsAsset: boolean;
	Type: UnrealEngineClass;
	clone() : FoliageTypeObject;
	static C(Other: UObject | any): FoliageTypeObject;
}

declare class ProceduralFoliageSpawner extends UObject { 
	RandomSeed: number;
	TileSize: number;
	NumUniqueTiles: number;
	MinimumQuadTreeSize: number;
	FoliageTypes: FoliageTypeObject[];
	static Load(ResourceName: string): ProceduralFoliageSpawner;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageSpawner;
	static GetDefaultObject(): ProceduralFoliageSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawner;
	Simulate(NumSteps: number): void;
	static C(Other: UObject | any): ProceduralFoliageSpawner;
}

declare class ProceduralFoliageComponent extends ActorComponent { 
	FoliageSpawner: ProceduralFoliageSpawner;
	TileOverlap: number;
	bAllowLandscape: boolean;
	bAllowBSP: boolean;
	bAllowStaticMesh: boolean;
	bAllowTranslucent: boolean;
	bAllowFoliage: boolean;
	bShowDebugTiles: boolean;
	DataLayer: ActorDataLayer;
	SpawningVolume: Volume;
	ProceduralGuid: Guid;
	LastSimulationDataLayer: ActorDataLayer;
	static Load(ResourceName: string): ProceduralFoliageComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageComponent;
	static C(Other: UObject | any): ProceduralFoliageComponent;
}

declare class ProceduralFoliageVolume extends Volume { 
	ProceduralComponent: ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageVolume;
	static C(Other: UObject | any): ProceduralFoliageVolume;
}

declare class ProceduralFoliageBlockingVolume extends Volume { 
	ProceduralFoliageVolume: ProceduralFoliageVolume;
	DensityFalloff: FoliageDensityFalloff;
	static GetDefaultObject(): ProceduralFoliageBlockingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageBlockingVolume;
	static C(Other: UObject | any): ProceduralFoliageBlockingVolume;
}

declare class ProceduralFoliageInstance { 
	Rotation: Quat;
	Location: Vector;
	Age: number;
	Normal: Vector;
	Scale: number;
	Type: FoliageType;
	clone() : ProceduralFoliageInstance;
	static C(Other: UObject | any): ProceduralFoliageInstance;
}

declare class ProceduralFoliageTile extends UObject { 
	FoliageSpawner: ProceduralFoliageSpawner;
	InstancesArray: ProceduralFoliageInstance[];
	static Load(ResourceName: string): ProceduralFoliageTile;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageTile;
	static GetDefaultObject(): ProceduralFoliageTile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageTile;
	static C(Other: UObject | any): ProceduralFoliageTile;
}

declare class AutoCompleteCommand { 
	Command: string;
	Desc: string;
	clone() : AutoCompleteCommand;
	static C(Other: UObject | any): AutoCompleteCommand;
}

declare class ConsoleSettings extends UObject { 
	MaxScrollbackSize: number;
	ManualAutoCompleteList: AutoCompleteCommand[];
	AutoCompleteMapPaths: string[];
	BackgroundOpacityPercentage: number;
	bOrderTopToBottom: boolean;
	bDisplayHelpInAutoComplete: boolean;
	InputColor: Color;
	HistoryColor: Color;
	AutoCompleteCommandColor: Color;
	AutoCompleteCVarColor: Color;
	AutoCompleteFadedColor: Color;
	static Load(ResourceName: string): ConsoleSettings;
	static Find(Outer: UObject, ResourceName: string): ConsoleSettings;
	static GetDefaultObject(): ConsoleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConsoleSettings;
	static C(Other: UObject | any): ConsoleSettings;
}

declare class GeneralProjectSettings extends UObject { 
	CompanyName: string;
	CompanyDistinguishedName: string;
	CopyrightNotice: string;
	Description: string;
	Homepage: string;
	LicensingTerms: string;
	PrivacyPolicy: string;
	ProjectID: Guid;
	ProjectName: string;
	ProjectVersion: string;
	SupportContact: string;
	ProjectDisplayedTitle: string;
	ProjectDebugTitleInfo: string;
	bShouldWindowPreserveAspectRatio: boolean;
	bUseBorderlessWindow: boolean;
	bStartInVR: boolean;
	bAllowWindowResize: boolean;
	bAllowClose: boolean;
	bAllowMaximize: boolean;
	bAllowMinimize: boolean;
	static Load(ResourceName: string): GeneralProjectSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralProjectSettings;
	static GetDefaultObject(): GeneralProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralProjectSettings;
	static C(Other: UObject | any): GeneralProjectSettings;
}

declare class TemplateMapInfoOverride { 
	Thumbnail: SoftObjectPath;
	Map: SoftObjectPath;
	DisplayName: string;
	clone() : TemplateMapInfoOverride;
	static C(Other: UObject | any): TemplateMapInfoOverride;
}

declare type ETwoPlayerSplitScreenType = 'Horizontal' | 'Vertical' | 'ETwoPlayerSplitScreenType_MAX';
declare var ETwoPlayerSplitScreenType : { Horizontal:'Horizontal',Vertical:'Vertical',ETwoPlayerSplitScreenType_MAX:'ETwoPlayerSplitScreenType_MAX', };
declare type EThreePlayerSplitScreenType = 'FavorTop' | 'FavorBottom' | 'Vertical' | 'Horizontal' | 'EThreePlayerSplitScreenType_MAX';
declare var EThreePlayerSplitScreenType : { FavorTop:'FavorTop',FavorBottom:'FavorBottom',Vertical:'Vertical',Horizontal:'Horizontal',EThreePlayerSplitScreenType_MAX:'EThreePlayerSplitScreenType_MAX', };
declare type EFourPlayerSplitScreenType = 'Grid' | 'Vertical' | 'Horizontal' | 'EFourPlayerSplitScreenType_MAX';
declare var EFourPlayerSplitScreenType : { Grid:'Grid',Vertical:'Vertical',Horizontal:'Horizontal',EFourPlayerSplitScreenType_MAX:'EFourPlayerSplitScreenType_MAX', };
declare class GameModeName { 
	Name: string;
	GameMode: SoftClassPath;
	clone() : GameModeName;
	static C(Other: UObject | any): GameModeName;
}

declare class GameMapsSettings extends UObject { 
	EditorStartupMap: SoftObjectPath;
	EditorTemplateMapOverrides: TemplateMapInfoOverride[];
	LocalMapOptions: string;
	TransitionMap: SoftObjectPath;
	bUseSplitscreen: boolean;
	TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
	ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
	FourPlayerSplitscreenLayout: EFourPlayerSplitScreenType;
	bOffsetPlayerGamepadIds: boolean;
	GameInstanceClass: SoftClassPath;
	GameDefaultMap: SoftObjectPath;
	ServerDefaultMap: SoftObjectPath;
	GlobalDefaultGameMode: SoftClassPath;
	GlobalDefaultServerGameMode: SoftClassPath;
	GameModeMapPrefixes: GameModeName[];
	GameModeClassAliases: GameModeName[];
	static Load(ResourceName: string): GameMapsSettings;
	static Find(Outer: UObject, ResourceName: string): GameMapsSettings;
	static GetDefaultObject(): GameMapsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMapsSettings;
	SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer: boolean): void;
	GetSkipAssigningGamepadToPlayer1(): boolean;
	static GetGameMapsSettings(): GameMapsSettings;
	static C(Other: UObject | any): GameMapsSettings;
}

declare class GameNetworkManagerSettings extends UObject { 
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	TotalNetBandwidth: number;
	BadPingThreshold: number;
	bIsStandbyCheckingEnabled: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	static Load(ResourceName: string): GameNetworkManagerSettings;
	static Find(Outer: UObject, ResourceName: string): GameNetworkManagerSettings;
	static GetDefaultObject(): GameNetworkManagerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManagerSettings;
	static C(Other: UObject | any): GameNetworkManagerSettings;
}

declare class GameSessionSettings extends UObject { 
	MaxSpectators: number;
	MaxPlayers: number;
	bRequiresPushToTalk: boolean;
	static Load(ResourceName: string): GameSessionSettings;
	static Find(Outer: UObject, ResourceName: string): GameSessionSettings;
	static GetDefaultObject(): GameSessionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSessionSettings;
	static C(Other: UObject | any): GameSessionSettings;
}

declare class HudSettings extends UObject { 
	bShowHUD: boolean;
	DebugDisplay: string[];
	static Load(ResourceName: string): HudSettings;
	static Find(Outer: UObject, ResourceName: string): HudSettings;
	static GetDefaultObject(): HudSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HudSettings;
	static C(Other: UObject | any): HudSettings;
}

declare class GeneralEngineSettings extends UObject { 
	static Load(ResourceName: string): GeneralEngineSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralEngineSettings;
	static GetDefaultObject(): GeneralEngineSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralEngineSettings;
	static C(Other: UObject | any): GeneralEngineSettings;
}

declare type EMultiBoxType = 'MenuBar' | 'ToolBar' | 'VerticalToolBar' | 'SlimHorizontalToolBar' | 'UniformToolBar' | 'Menu' | 'ButtonRow' | 'EMultiBoxType_MAX';
declare var EMultiBoxType : { MenuBar:'MenuBar',ToolBar:'ToolBar',VerticalToolBar:'VerticalToolBar',SlimHorizontalToolBar:'SlimHorizontalToolBar',UniformToolBar:'UniformToolBar',Menu:'Menu',ButtonRow:'ButtonRow',EMultiBoxType_MAX:'EMultiBoxType_MAX', };
declare class ToolMenuOwner { 
	clone() : ToolMenuOwner;
	static C(Other: UObject | any): ToolMenuOwner;
}

declare class ToolMenuContext { 
	ContextObjects: UObject[];
	clone() : ToolMenuContext;
	static C(Other: UObject | any): ToolMenuContext;
}

declare type EMultiBlockType = 'None' | 'ButtonRow' | 'EditableText' | 'Heading' | 'MenuEntry' | 'Separator' | 'ToolBarButton' | 'ToolBarComboButton' | 'Widget' | 'EMultiBlockType_MAX';
declare var EMultiBlockType : { None:'None',ButtonRow:'ButtonRow',EditableText:'EditableText',Heading:'Heading',MenuEntry:'MenuEntry',Separator:'Separator',ToolBarButton:'ToolBarButton',ToolBarComboButton:'ToolBarComboButton',Widget:'Widget',EMultiBlockType_MAX:'EMultiBlockType_MAX', };
declare type EUserInterfaceActionType = 'None' | 'Button' | 'ToggleButton' | 'RadioButton' | 'Check' | 'CollapsedButton' | 'EUserInterfaceActionType_MAX';
declare var EUserInterfaceActionType : { None:'None',Button:'Button',ToggleButton:'ToggleButton',RadioButton:'RadioButton',Check:'Check',CollapsedButton:'CollapsedButton',EUserInterfaceActionType_MAX:'EUserInterfaceActionType_MAX', };
declare type EToolMenuInsertType = 'Default' | 'Before' | 'After' | 'First' | 'EToolMenuInsertType_MAX';
declare var EToolMenuInsertType : { Default:'Default',Before:'Before',After:'After',First:'First',EToolMenuInsertType_MAX:'EToolMenuInsertType_MAX', };
declare class ToolMenuInsert { 
	Name: string;
	position: EToolMenuInsertType;
	clone() : ToolMenuInsert;
	static C(Other: UObject | any): ToolMenuInsert;
}

declare class ScriptSlateIcon { 
	StyleSetName: string;
	StyleName: string;
	SmallStyleName: string;
	clone() : ScriptSlateIcon;
	static C(Other: UObject | any): ScriptSlateIcon;
}

declare class ToolMenuEntryScriptDataAdvanced { 
	TutorialHighlight: string;
	EntryType: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	StyleNameOverride: string;
	bIsSubMenu: boolean;
	bOpenSubMenuOnClick: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bSimpleComboBox: boolean;
	clone() : ToolMenuEntryScriptDataAdvanced;
	static C(Other: UObject | any): ToolMenuEntryScriptDataAdvanced;
}

declare class ToolMenuEntryScriptData { 
	Menu: string;
	Section: string;
	Name: string;
	Label: string;
	Tooltip: string;
	Icon: ScriptSlateIcon;
	OwnerName: string;
	InsertPosition: ToolMenuInsert;
	Advanced: ToolMenuEntryScriptDataAdvanced;
	clone() : ToolMenuEntryScriptData;
	static C(Other: UObject | any): ToolMenuEntryScriptData;
}

declare type ECheckBoxState = 'Unchecked' | 'Checked' | 'Undetermined' | 'ECheckBoxState_MAX';
declare var ECheckBoxState : { Unchecked:'Unchecked',Checked:'Checked',Undetermined:'Undetermined',ECheckBoxState_MAX:'ECheckBoxState_MAX', };
declare class ToolMenuEntryScript extends UObject { 
	Data: ToolMenuEntryScriptData;
	static Load(ResourceName: string): ToolMenuEntryScript;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryScript;
	static GetDefaultObject(): ToolMenuEntryScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryScript;
	RegisterMenuEntry(): void;
	IsVisible(Context: ToolMenuContext): boolean;
	InitEntry(OwnerName: string,Menu: string,Section: string,Name: string,Label: string,Tooltip: string): void;
	GetToolTip(Context: ToolMenuContext): string;
	GetLabel(Context: ToolMenuContext): string;
	GetIcon(Context: ToolMenuContext): ScriptSlateIcon;
	GetCheckState(Context: ToolMenuContext): ECheckBoxState;
	Execute(Context: ToolMenuContext): void;
	ConstructMenuEntry(Menu: ToolMenu,SectionName: string,Context: ToolMenuContext): void;
	CanExecute(Context: ToolMenuContext): boolean;
	static C(Other: UObject | any): ToolMenuEntryScript;
}

declare class ToolMenuEntry { 
	Name: string;
	Owner: ToolMenuOwner;
	Type: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	TutorialHighlightName: string;
	InsertPosition: ToolMenuInsert;
	bShouldCloseWindowAfterMenuSelection: boolean;
	ScriptObject: ToolMenuEntryScript;
	StyleNameOverride: string;
	bCommandIsKeybindOnly: boolean;
	clone() : ToolMenuEntry;
	static C(Other: UObject | any): ToolMenuEntry;
}

declare class ToolMenuSectionDynamic extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionDynamic;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionDynamic;
	static GetDefaultObject(): ToolMenuSectionDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionDynamic;
	ConstructSections(Menu: ToolMenu,Context: ToolMenuContext): void;
	static C(Other: UObject | any): ToolMenuSectionDynamic;
}

declare class ToolMenuSection { 
	Name: string;
	Owner: ToolMenuOwner;
	Blocks: ToolMenuEntry[];
	InsertPosition: ToolMenuInsert;
	Context: ToolMenuContext;
	ToolMenuSectionDynamic: ToolMenuSectionDynamic;
	clone() : ToolMenuSection;
	static C(Other: UObject | any): ToolMenuSection;
}

declare class ToolMenu extends ToolMenuBase { 
	MenuName: string;
	MenuParent: string;
	StyleName: string;
	TutorialHighlightName: string;
	MenuType: EMultiBoxType;
	bShouldCleanupContextOnDestroy: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bCloseSelfOnly: boolean;
	bSearchable: boolean;
	bToolBarIsFocusable: boolean;
	bToolBarForceSmallIcons: boolean;
	bPreventCustomization: boolean;
	MenuOwner: ToolMenuOwner;
	Context: ToolMenuContext;
	Sections: ToolMenuSection[];
	SubMenuParent: ToolMenu;
	SubMenuSourceEntryName: string;
	static Load(ResourceName: string): ToolMenu;
	static Find(Outer: UObject, ResourceName: string): ToolMenu;
	static GetDefaultObject(): ToolMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenu;
	InitMenu(Owner: ToolMenuOwner,Name: string,Parent: string,Type: EMultiBoxType): void;
	AddSubMenuScript(Owner: string,SectionName: string,Name: string,Label: string,Tooltip: string): ToolMenu;
	AddSectionScript(SectionName: string,Label: string,InsertName: string,InsertType: EToolMenuInsertType): void;
	AddMenuEntryObject(InObject: ToolMenuEntryScript): void;
	AddMenuEntry(SectionName: string,Args: ToolMenuEntry): void;
	AddDynamicSectionScript(SectionName: string,UObject: ToolMenuSectionDynamic): void;
	static C(Other: UObject | any): ToolMenu;
}

declare class ToolMenuContextBase extends UObject { 
	static Load(ResourceName: string): ToolMenuContextBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextBase;
	static GetDefaultObject(): ToolMenuContextBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextBase;
	static C(Other: UObject | any): ToolMenuContextBase;
}

declare class SlateTabManagerContext extends ToolMenuContextBase { 
	static Load(ResourceName: string): SlateTabManagerContext;
	static Find(Outer: UObject, ResourceName: string): SlateTabManagerContext;
	static GetDefaultObject(): SlateTabManagerContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTabManagerContext;
	static C(Other: UObject | any): SlateTabManagerContext;
}

declare class CustomizedToolMenu { 
	Name: string;
	Entries: any;
	Sections: any;
	EntryOrder: any;
	SectionOrder: string[];
	clone() : CustomizedToolMenu;
	static C(Other: UObject | any): CustomizedToolMenu;
}

declare class ToolMenus extends UObject { 
	CustomizedMenus: CustomizedToolMenu[];
	MenuSubstitutionsDuringGenerate: any;
	Menus: any;
	static Load(ResourceName: string): ToolMenus;
	static Find(Outer: UObject, ResourceName: string): ToolMenus;
	static GetDefaultObject(): ToolMenus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenus;
	UnregisterOwnerByName(InOwnerName: string): void;
	SetSectionPosition(MenuName: string,SectionName: string,OtherSectionName: string,PositionType: EToolMenuInsertType): void;
	SetSectionLabel(MenuName: string,SectionName: string,Label: string): void;
	RemoveSection(MenuName: string,Section: string): void;
	RemoveMenu(MenuName: string): void;
	RemoveEntry(MenuName: string,Section: string,Name: string): void;
	RegisterMenu(Name: string,Parent: string,Type: EMultiBoxType,bWarnIfAlreadyRegistered: boolean): ToolMenu;
	RefreshMenuWidget(Name: string): boolean;
	RefreshAllWidgets(): void;
	IsMenuRegistered(Name: string): boolean;
	static Get(): ToolMenus;
	FindMenu(Name: string): ToolMenu;
	static FindContext(InContext: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	ExtendMenu(Name: string): ToolMenu;
	static AddMenuEntryObject(MenuEntryObject: ToolMenuEntryScript): boolean;
	static C(Other: UObject | any): ToolMenus;
}

declare class ToolMenuContextExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuContextExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextExtensions;
	static GetDefaultObject(): ToolMenuContextExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextExtensions;
	static FindByClass(Context: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	static C(Other: UObject | any): ToolMenuContextExtensions;
}

declare type EToolMenuStringCommandType = 'Command' | 'Python' | 'Custom' | 'EToolMenuStringCommandType_MAX';
declare var EToolMenuStringCommandType : { Command:'Command',Python:'Python',Custom:'Custom',EToolMenuStringCommandType_MAX:'EToolMenuStringCommandType_MAX', };
declare class ToolMenuStringCommand { 
	Type: EToolMenuStringCommandType;
	CustomType: string;
	string: string;
	clone() : ToolMenuStringCommand;
	static C(Other: UObject | any): ToolMenuStringCommand;
}

declare class ToolMenuEntryExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuEntryExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryExtensions;
	static GetDefaultObject(): ToolMenuEntryExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryExtensions;
	static SetToolTip(Target?: ToolMenuEntry,Tooltip?: string): {Target: ToolMenuEntry};
	static SetStringCommand(Target?: ToolMenuEntry,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Target: ToolMenuEntry};
	static SetLabel(Target?: ToolMenuEntry,Label?: string): {Target: ToolMenuEntry};
	static SetIcon(Target?: ToolMenuEntry,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {Target: ToolMenuEntry};
	static MakeToolMenuOwner(Name: string): ToolMenuOwner;
	static MakeStringCommand(Type: EToolMenuStringCommandType,CustomType: string,string: string): ToolMenuStringCommand;
	static MakeScriptSlateIcon(StyleSetName: string,StyleName: string,SmallStyleName: string): ScriptSlateIcon;
	static InitMenuEntry(InOwner: string,InName: string,InLabel: string,InToolTip: string,CommandType: EToolMenuStringCommandType,CustomCommandType: string,CommandString: string): ToolMenuEntry;
	static GetToolTip(Target: ToolMenuEntry): string;
	static GetLabel(Target: ToolMenuEntry): string;
	static BreakToolMenuOwner(InValue: ToolMenuOwner,Name?: string): {Name: string};
	static BreakStringCommand(InValue: ToolMenuStringCommand,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Type: EToolMenuStringCommandType, CustomType: string, string: string};
	static BreakScriptSlateIcon(InValue: ScriptSlateIcon,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {StyleSetName: string, StyleName: string, SmallStyleName: string};
	static C(Other: UObject | any): ToolMenuEntryExtensions;
}

declare class ToolMenuSectionExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionExtensions;
	static GetDefaultObject(): ToolMenuSectionExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionExtensions;
	static SetLabel(Section?: ToolMenuSection,Label?: string): {Section: ToolMenuSection};
	static GetLabel(Section: ToolMenuSection): string;
	static AddEntryObject(Section?: ToolMenuSection,InObject?: ToolMenuEntryScript): {Section: ToolMenuSection};
	static AddEntry(Section?: ToolMenuSection,Args?: ToolMenuEntry): {Section: ToolMenuSection};
	static C(Other: UObject | any): ToolMenuSectionExtensions;
}

declare type EContentBrowserDataMenuContext_AddNewMenuDomain = 'Toolbar' | 'AssetView' | 'PathView' | 'EContentBrowserDataMenuContext_MAX';
declare var EContentBrowserDataMenuContext_AddNewMenuDomain : { Toolbar:'Toolbar',AssetView:'AssetView',PathView:'PathView',EContentBrowserDataMenuContext_MAX:'EContentBrowserDataMenuContext_MAX', };
declare class ContentBrowserDataMenuContext_AddNewMenu extends UObject { 
	SelectedPaths: string[];
	bContainsValidPackagePath: boolean;
	bCanBeModified: boolean;
	OwnerDomain: EContentBrowserDataMenuContext_AddNewMenuDomain;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_AddNewMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_AddNewMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_AddNewMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_AddNewMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_AddNewMenu;
}

declare class ContentBrowserItem { 
	clone() : ContentBrowserItem;
	static C(Other: UObject | any): ContentBrowserItem;
	GetDisplayName(): string;
	GetVirtualPath(): string;
	IsFile(): boolean;
	IsFolder(): boolean;
	static GetDisplayName(Item: ContentBrowserItem): string;
	static GetVirtualPath(Item: ContentBrowserItem): string;
	static IsFile(Item: ContentBrowserItem): boolean;
	static IsFolder(Item: ContentBrowserItem): boolean;
}

declare class ContentBrowserDataMenuContext_FolderMenu extends UObject { 
	SelectedItems: ContentBrowserItem[];
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_FolderMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_FolderMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_FolderMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_FolderMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_FolderMenu;
}

declare class ContentBrowserDataMenuContext_FileMenu extends UObject { 
	SelectedItems: ContentBrowserItem[];
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_FileMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_FileMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_FileMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_FileMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_FileMenu;
}

declare class ContentBrowserDataMenuContext_DragDropMenu extends UObject { 
	DropTargetItem: ContentBrowserItem;
	DraggedItems: ContentBrowserItem[];
	bCanMove: boolean;
	bCanCopy: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_DragDropMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_DragDropMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_DragDropMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_DragDropMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_DragDropMenu;
}

declare class ContentBrowserDataSource extends UObject { 
	static Load(ResourceName: string): ContentBrowserDataSource;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataSource;
	static GetDefaultObject(): ContentBrowserDataSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataSource;
	static C(Other: UObject | any): ContentBrowserDataSource;
}

declare type EContentBrowserItemTypeFilter = 'IncludeNone' | 'IncludeFolders' | 'IncludeFiles' | 'IncludeAll' | 'EContentBrowserItemTypeFilter_MAX';
declare var EContentBrowserItemTypeFilter : { IncludeNone:'IncludeNone',IncludeFolders:'IncludeFolders',IncludeFiles:'IncludeFiles',IncludeAll:'IncludeAll',EContentBrowserItemTypeFilter_MAX:'EContentBrowserItemTypeFilter_MAX', };
declare type EContentBrowserItemCategoryFilter = 'IncludeNone' | 'IncludeAssets' | 'IncludeClasses' | 'IncludeCollections' | 'IncludeMisc' | 'IncludeAll' | 'EContentBrowserItemCategoryFilter_MAX';
declare var EContentBrowserItemCategoryFilter : { IncludeNone:'IncludeNone',IncludeAssets:'IncludeAssets',IncludeClasses:'IncludeClasses',IncludeCollections:'IncludeCollections',IncludeMisc:'IncludeMisc',IncludeAll:'IncludeAll',EContentBrowserItemCategoryFilter_MAX:'EContentBrowserItemCategoryFilter_MAX', };
declare type EContentBrowserItemAttributeFilter = 'IncludeNone' | 'IncludeProject' | 'IncludeEngine' | 'IncludePlugins' | 'IncludeDeveloper' | 'IncludeLocalized' | 'IncludeAll' | 'EContentBrowserItemAttributeFilter_MAX';
declare var EContentBrowserItemAttributeFilter : { IncludeNone:'IncludeNone',IncludeProject:'IncludeProject',IncludeEngine:'IncludeEngine',IncludePlugins:'IncludePlugins',IncludeDeveloper:'IncludeDeveloper',IncludeLocalized:'IncludeLocalized',IncludeAll:'IncludeAll',EContentBrowserItemAttributeFilter_MAX:'EContentBrowserItemAttributeFilter_MAX', };
declare class ContentBrowserDataFilter { 
	bRecursivePaths: boolean;
	ItemTypeFilter: EContentBrowserItemTypeFilter;
	ItemCategoryFilter: EContentBrowserItemCategoryFilter;
	ItemAttributeFilter: EContentBrowserItemAttributeFilter;
	clone() : ContentBrowserDataFilter;
	static C(Other: UObject | any): ContentBrowserDataFilter;
}

declare class ContentBrowserDataSubsystem extends EditorSubsystem { 
	EnabledDataSources: string[];
	static Load(ResourceName: string): ContentBrowserDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataSubsystem;
	static GetDefaultObject(): ContentBrowserDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataSubsystem;
	GetItemsUnderPath(InPath: string,InFilter: ContentBrowserDataFilter): ContentBrowserItem[];
	GetItemsAtPath(InPath: string,InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem[];
	GetItemAtPath(InPath: string,InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem;
	GetAvailableDataSources(): string[];
	GetActiveDataSources(): string[];
	DeactivateDataSource(Name: string): boolean;
	DeactivateAllDataSources(): void;
	ActivateDataSource(Name: string): boolean;
	ActivateAllDataSources(): void;
	static C(Other: UObject | any): ContentBrowserDataSubsystem;
}

declare class ContentBrowserItemLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ContentBrowserItemLibrary;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserItemLibrary;
	static GetDefaultObject(): ContentBrowserItemLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserItemLibrary;
	static IsFolder(Item: ContentBrowserItem): boolean;
	static IsFile(Item: ContentBrowserItem): boolean;
	static GetVirtualPath(Item: ContentBrowserItem): string;
	static GetDisplayName(Item: ContentBrowserItem): string;
	static C(Other: UObject | any): ContentBrowserItemLibrary;
}

declare class ClassViewerProjectSettings extends UObject { 
	InternalOnlyPaths: DirectoryPath[];
	InternalOnlyClasses: SoftClassPath[];
	static Load(ResourceName: string): ClassViewerProjectSettings;
	static Find(Outer: UObject, ResourceName: string): ClassViewerProjectSettings;
	static GetDefaultObject(): ClassViewerProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassViewerProjectSettings;
	static C(Other: UObject | any): ClassViewerProjectSettings;
}

declare type EHardwareClass = 'Unspecified' | 'Desktop' | 'Mobile' | 'EHardwareClass_MAX';
declare var EHardwareClass : { Unspecified:'Unspecified',Desktop:'Desktop',Mobile:'Mobile',EHardwareClass_MAX:'EHardwareClass_MAX', };
declare type EGraphicsPreset = 'Unspecified' | 'Maximum' | 'Scalable' | 'EGraphicsPreset_MAX';
declare var EGraphicsPreset : { Unspecified:'Unspecified',Maximum:'Maximum',Scalable:'Scalable',EGraphicsPreset_MAX:'EGraphicsPreset_MAX', };
declare class HardwareTargetingSettings extends UObject { 
	TargetedHardwareClass: EHardwareClass;
	AppliedTargetedHardwareClass: EHardwareClass;
	DefaultGraphicsPerformance: EGraphicsPreset;
	AppliedDefaultGraphicsPerformance: EGraphicsPreset;
	static Load(ResourceName: string): HardwareTargetingSettings;
	static Find(Outer: UObject, ResourceName: string): HardwareTargetingSettings;
	static GetDefaultObject(): HardwareTargetingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HardwareTargetingSettings;
	static C(Other: UObject | any): HardwareTargetingSettings;
}

declare class ClassTemplate extends UObject { 
	GeneratedBaseClass: UnrealEngineClass;
	static Load(ResourceName: string): ClassTemplate;
	static Find(Outer: UObject, ResourceName: string): ClassTemplate;
	static GetDefaultObject(): ClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplate;
	static C(Other: UObject | any): ClassTemplate;
}

declare class PluginClassTemplate extends ClassTemplate { 
	PluginName: string;
	static Load(ResourceName: string): PluginClassTemplate;
	static Find(Outer: UObject, ResourceName: string): PluginClassTemplate;
	static GetDefaultObject(): PluginClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginClassTemplate;
	static C(Other: UObject | any): PluginClassTemplate;
}

declare class ClassTemplateEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): ClassTemplateEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): ClassTemplateEditorSubsystem;
	static GetDefaultObject(): ClassTemplateEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplateEditorSubsystem;
	static C(Other: UObject | any): ClassTemplateEditorSubsystem;
}

declare class LocalizedTemplateString { 
	Language: string;
	text: string;
	clone() : LocalizedTemplateString;
	static C(Other: UObject | any): LocalizedTemplateString;
}

declare class TemplateFolderRename { 
	From: string;
	To: string;
	clone() : TemplateFolderRename;
	static C(Other: UObject | any): TemplateFolderRename;
}

declare class TemplateReplacement { 
	Extensions: string[];
	From: string;
	To: string;
	bCaseSensitive: boolean;
	clone() : TemplateReplacement;
	static C(Other: UObject | any): TemplateReplacement;
}

declare type ETemplateSetting = 'Languages' | 'HardwareTarget' | 'GraphicsPreset' | 'StarterContent' | 'XR' | 'Raytracing' | 'All' | 'ETemplateSetting_MAX';
declare var ETemplateSetting : { Languages:'Languages',HardwareTarget:'HardwareTarget',GraphicsPreset:'GraphicsPreset',StarterContent:'StarterContent',XR:'XR',Raytracing:'Raytracing',All:'All',ETemplateSetting_MAX:'ETemplateSetting_MAX', };
declare type EFeaturePackDetailLevel = 'Standard' | 'High' | 'EFeaturePackDetailLevel_MAX';
declare var EFeaturePackDetailLevel : { Standard:'Standard',High:'High',EFeaturePackDetailLevel_MAX:'EFeaturePackDetailLevel_MAX', };
declare class FeaturePackLevelSet { 
	DetailLevels: EFeaturePackDetailLevel[];
	MountName: string;
	clone() : FeaturePackLevelSet;
	static C(Other: UObject | any): FeaturePackLevelSet;
}

declare class TemplateProjectDefs extends UObject { 
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	FoldersToIgnore: string[];
	FilesToIgnore: string[];
	FolderRenames: TemplateFolderRename[];
	FilenameReplacements: TemplateReplacement[];
	ReplacementsInFiles: TemplateReplacement[];
	SortKey: string;
	Categories: string[];
	ClassTypes: string;
	AssetTypes: string;
	bAllowProjectCreation: boolean;
	bIsEnterprise: boolean;
	bIsBlank: boolean;
	bThumbnailAsIcon: boolean;
	HiddenSettings: ETemplateSetting[];
	PacksToInclude: string[];
	EditDetailLevelPreference: EFeaturePackDetailLevel;
	SharedContentPacks: FeaturePackLevelSet[];
	StarterContent: string;
	static Load(ResourceName: string): TemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): TemplateProjectDefs;
	static GetDefaultObject(): TemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateProjectDefs;
	static C(Other: UObject | any): TemplateProjectDefs;
}

declare class DefaultTemplateProjectDefs extends TemplateProjectDefs { 
	static Load(ResourceName: string): DefaultTemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): DefaultTemplateProjectDefs;
	static GetDefaultObject(): DefaultTemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultTemplateProjectDefs;
	static C(Other: UObject | any): DefaultTemplateProjectDefs;
}

declare class TemplateCategoryDef { 
	Key: string;
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	Icon: string;
	IsMajorCategory: boolean;
	clone() : TemplateCategoryDef;
	static C(Other: UObject | any): TemplateCategoryDef;
}

declare class TemplateCategories extends UObject { 
	Categories: TemplateCategoryDef[];
	static Load(ResourceName: string): TemplateCategories;
	static Find(Outer: UObject, ResourceName: string): TemplateCategories;
	static GetDefaultObject(): TemplateCategories;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateCategories;
	static C(Other: UObject | any): TemplateCategories;
}

declare class StatusBarSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): StatusBarSubsystem;
	static Find(Outer: UObject, ResourceName: string): StatusBarSubsystem;
	static GetDefaultObject(): StatusBarSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatusBarSubsystem;
	static C(Other: UObject | any): StatusBarSubsystem;
}

declare class ContentBrowserFrontEndFilterExtension extends UObject { 
	static Load(ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static GetDefaultObject(): ContentBrowserFrontEndFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFrontEndFilterExtension;
	static C(Other: UObject | any): ContentBrowserFrontEndFilterExtension;
}

declare class ContentBrowserAssetContextMenuContext extends UObject { 
	SelectedObjects: any[];
	CommonClass: UnrealEngineClass;
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserAssetContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetContextMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): ContentBrowserAssetContextMenuContext;
}

declare class ContentBrowserAssetViewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetViewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetViewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAssetViewContextMenuContext;
}

declare class ContentBrowserMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserMenuContext;
	static GetDefaultObject(): ContentBrowserMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserMenuContext;
	static C(Other: UObject | any): ContentBrowserMenuContext;
}

declare class ContentBrowserFolderContext extends ContentBrowserMenuContext { 
	bCanBeModified: boolean;
	bNoFolderOnDisk: boolean;
	NumAssetPaths: number;
	NumClassPaths: number;
	static Load(ResourceName: string): ContentBrowserFolderContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFolderContext;
	static GetDefaultObject(): ContentBrowserFolderContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFolderContext;
	static C(Other: UObject | any): ContentBrowserFolderContext;
}

declare class ContentBrowserFilterListContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserFilterListContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFilterListContext;
	static GetDefaultObject(): ContentBrowserFilterListContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFilterListContext;
	static C(Other: UObject | any): ContentBrowserFilterListContext;
}

declare class ContentBrowserAddNewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAddNewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAddNewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAddNewContextMenuContext;
}

declare class ContentBrowserToolbarMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserToolbarMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserToolbarMenuContext;
	static GetDefaultObject(): ContentBrowserToolbarMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserToolbarMenuContext;
	static C(Other: UObject | any): ContentBrowserToolbarMenuContext;
}

declare class TextFilterKeyValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterKeyValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandler;
	static GetDefaultObject(): TextFilterKeyValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandler;
	static C(Other: UObject | any): TextFilterKeyValueHandler;
}

declare class TextFilterKeyValueHandlerEntry { 
	Key: string;
	HandlerClass: Class;
	clone() : TextFilterKeyValueHandlerEntry;
	static C(Other: UObject | any): TextFilterKeyValueHandlerEntry;
}

declare class TextFilterKeyValueHandlers extends UObject { 
	TextFilterKeyValueHandlers: TextFilterKeyValueHandlerEntry[];
	static Load(ResourceName: string): TextFilterKeyValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandlers;
	static GetDefaultObject(): TextFilterKeyValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandlers;
	static C(Other: UObject | any): TextFilterKeyValueHandlers;
}

declare class TextFilterValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandler;
	static GetDefaultObject(): TextFilterValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandler;
	static C(Other: UObject | any): TextFilterValueHandler;
}

declare class TextFilterValueHandlers extends UObject { 
	TextFilterValueHandlers: Class[];
	static Load(ResourceName: string): TextFilterValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandlers;
	static GetDefaultObject(): TextFilterValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandlers;
	static C(Other: UObject | any): TextFilterValueHandlers;
}

declare class AnimNodeFunctionRef { 
	ClassName: string;
	FunctionName: string;
	Class: UnrealEngineClass;
	UFunction: UFunction;
	clone() : AnimNodeFunctionRef;
	static C(Other: UObject | any): AnimNodeFunctionRef;
}

declare class AnimNode_Base { 
	InitialUpdateFunction: AnimNodeFunctionRef;
	BecomeRelevantFunction: AnimNodeFunctionRef;
	UpdateFunction: AnimNodeFunctionRef;
	clone() : AnimNode_Base;
	static C(Other: UObject | any): AnimNode_Base;
}

declare class PoseLinkBase { 
	LinkID: number;
	SourceLinkID: number;
	clone() : PoseLinkBase;
	static C(Other: UObject | any): PoseLinkBase;
}

declare class PoseLink extends PoseLinkBase { 
	clone() : PoseLink;
	static C(Other: UObject | any): PoseLink;
}

declare class AnimNode_Root extends AnimNode_Base { 
	Result: PoseLink;
	Name: string;
	Group: string;
	clone() : AnimNode_Root;
	static C(Other: UObject | any): AnimNode_Root;
}

declare class AnimNode_BlendSpaceSampleResult extends AnimNode_Root { 
	clone() : AnimNode_BlendSpaceSampleResult;
	static C(Other: UObject | any): AnimNode_BlendSpaceSampleResult;
}

declare class AnimGraphNode_BlendSpaceSampleResult extends AnimGraphNode_Base { 
	UNode: AnimNode_BlendSpaceSampleResult;
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceSampleResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceSampleResult;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceSampleResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceSampleResult;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceSampleResult;
}

declare class AnimationBlendSpaceSampleGraph extends AnimationGraph { 
	ResultNode: AnimGraphNode_BlendSpaceSampleResult;
	static Load(ResourceName: string): AnimationBlendSpaceSampleGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationBlendSpaceSampleGraph;
	static GetDefaultObject(): AnimationBlendSpaceSampleGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationBlendSpaceSampleGraph;
	static C(Other: UObject | any): AnimationBlendSpaceSampleGraph;
}

declare class BlueprintCallableFunctionRedirect { 
	ClassName: string;
	OldFunctionName: string;
	NewFunctionName: string;
	BlueprintParamName: string;
	ClassParamName: string;
	clone() : BlueprintCallableFunctionRedirect;
	static C(Other: UObject | any): BlueprintCallableFunctionRedirect;
}

declare class EdGraphSchema_K2 extends EdGraphSchema { 
	EditoronlyBPFunctionRedirects: BlueprintCallableFunctionRedirect[];
	static Load(ResourceName: string): EdGraphSchema_K2;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_K2;
	static GetDefaultObject(): EdGraphSchema_K2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_K2;
	static C(Other: UObject | any): EdGraphSchema_K2;
}

declare class AnimationConduitGraphSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): AnimationConduitGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationConduitGraphSchema;
	static GetDefaultObject(): AnimationConduitGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationConduitGraphSchema;
	static C(Other: UObject | any): AnimationConduitGraphSchema;
}

declare class AnimNode_StateResult extends AnimNode_Root { 
	StateIndex: number;
	clone() : AnimNode_StateResult;
	static C(Other: UObject | any): AnimNode_StateResult;
}

declare class AnimGraphNode_StateResult extends AnimGraphNode_Base { 
	UNode: AnimNode_StateResult;
	static Load(ResourceName: string): AnimGraphNode_StateResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateResult;
	static GetDefaultObject(): AnimGraphNode_StateResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateResult;
	static C(Other: UObject | any): AnimGraphNode_StateResult;
}

declare class AnimGraphNode_CustomTransitionResult extends AnimGraphNode_StateResult { 
	static Load(ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static GetDefaultObject(): AnimGraphNode_CustomTransitionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CustomTransitionResult;
	static C(Other: UObject | any): AnimGraphNode_CustomTransitionResult;
}

declare class AnimationCustomTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_CustomTransitionResult;
	static Load(ResourceName: string): AnimationCustomTransitionGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationCustomTransitionGraph;
	static GetDefaultObject(): AnimationCustomTransitionGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionGraph;
	static C(Other: UObject | any): AnimationCustomTransitionGraph;
}

declare class AnimationGraphSchema extends EdGraphSchema_K2 { 
	PN_SequenceName: string;
	NAME_NeverAsPin: string;
	NAME_PinHiddenByDefault: string;
	NAME_PinShownByDefault: string;
	NAME_AlwaysAsPin: string;
	NAME_CustomizeProperty: string;
	NAME_OnEvaluate: string;
	DefaultEvaluationHandlerName: string;
	static Load(ResourceName: string): AnimationGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationGraphSchema;
	static GetDefaultObject(): AnimationGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraphSchema;
	static C(Other: UObject | any): AnimationGraphSchema;
}

declare class AnimationCustomTransitionSchema extends AnimationGraphSchema { 
	static Load(ResourceName: string): AnimationCustomTransitionSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationCustomTransitionSchema;
	static GetDefaultObject(): AnimationCustomTransitionSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionSchema;
	static C(Other: UObject | any): AnimationCustomTransitionSchema;
}

declare class AnimationStateGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_StateResult;
	static Load(ResourceName: string): AnimationStateGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationStateGraph;
	static GetDefaultObject(): AnimationStateGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraph;
	static C(Other: UObject | any): AnimationStateGraph;
}

declare class AnimationStateGraphSchema extends AnimationGraphSchema { 
	static Load(ResourceName: string): AnimationStateGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationStateGraphSchema;
	static GetDefaultObject(): AnimationStateGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraphSchema;
	static C(Other: UObject | any): AnimationStateGraphSchema;
}

declare class AnimStateEntryNode extends EdGraphNode { 
	static Load(ResourceName: string): AnimStateEntryNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateEntryNode;
	static GetDefaultObject(): AnimStateEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateEntryNode;
	static C(Other: UObject | any): AnimStateEntryNode;
}

declare class AnimGraphNode_StateMachineBase extends AnimGraphNode_Base { 
	EditorStateMachineGraph: AnimationStateMachineGraph;
	static Load(ResourceName: string): AnimGraphNode_StateMachineBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateMachineBase;
	static GetDefaultObject(): AnimGraphNode_StateMachineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateMachineBase;
	static C(Other: UObject | any): AnimGraphNode_StateMachineBase;
}

declare class AnimationStateMachineGraph extends EdGraph { 
	EntryNode: AnimStateEntryNode;
	OwnerAnimGraphNode: AnimGraphNode_StateMachineBase;
	static Load(ResourceName: string): AnimationStateMachineGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineGraph;
	static GetDefaultObject(): AnimationStateMachineGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineGraph;
	static C(Other: UObject | any): AnimationStateMachineGraph;
}

declare class AnimationStateMachineSchema extends EdGraphSchema { 
	static Load(ResourceName: string): AnimationStateMachineSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineSchema;
	static GetDefaultObject(): AnimationStateMachineSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineSchema;
	static C(Other: UObject | any): AnimationStateMachineSchema;
}

declare class AnimNode_TransitionResult extends AnimNode_Base { 
	bCanEnterTransition: boolean;
	clone() : AnimNode_TransitionResult;
	static C(Other: UObject | any): AnimNode_TransitionResult;
}

declare class AnimGraphNode_TransitionResult extends AnimGraphNode_Base { 
	UNode: AnimNode_TransitionResult;
	static Load(ResourceName: string): AnimGraphNode_TransitionResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TransitionResult;
	static GetDefaultObject(): AnimGraphNode_TransitionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TransitionResult;
	static C(Other: UObject | any): AnimGraphNode_TransitionResult;
}

declare class AnimationTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_TransitionResult;
	static Load(ResourceName: string): AnimationTransitionGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationTransitionGraph;
	static GetDefaultObject(): AnimationTransitionGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionGraph;
	static C(Other: UObject | any): AnimationTransitionGraph;
}

declare class AnimationTransitionSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): AnimationTransitionSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationTransitionSchema;
	static GetDefaultObject(): AnimationTransitionSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionSchema;
	static C(Other: UObject | any): AnimationTransitionSchema;
}

declare class AnimBlueprintExtension extends BlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension;
	static GetDefaultObject(): AnimBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension;
	static C(Other: UObject | any): AnimBlueprintExtension;
}

declare class AnimBlueprintExtension_Attributes extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_Attributes;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_Attributes;
	static GetDefaultObject(): AnimBlueprintExtension_Attributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_Attributes;
	static C(Other: UObject | any): AnimBlueprintExtension_Attributes;
}

declare class AnimSubsystem { 
	clone() : AnimSubsystem;
	static C(Other: UObject | any): AnimSubsystem;
}

declare type EPostCopyOperation = 'None' | 'LogicalNegateBool' | 'EPostCopyOperation_MAX';
declare var EPostCopyOperation : { None:'None',LogicalNegateBool:'LogicalNegateBool',EPostCopyOperation_MAX:'EPostCopyOperation_MAX', };
declare class ExposedValueCopyRecord { 
	CopyIndex: number;
	PostCopyOperation: EPostCopyOperation;
	clone() : ExposedValueCopyRecord;
	static C(Other: UObject | any): ExposedValueCopyRecord;
}

declare class ExposedValueHandler { 
	CopyRecords: ExposedValueCopyRecord[];
	UFunction: UFunction;
	BoundFunction: string;
	clone() : ExposedValueHandler;
	static C(Other: UObject | any): ExposedValueHandler;
}

declare class AnimSubsystem_Base extends AnimSubsystem { 
	ExposedValueHandlers: ExposedValueHandler[];
	clone() : AnimSubsystem_Base;
	static C(Other: UObject | any): AnimSubsystem_Base;
}

declare class AnimBlueprintExtension_Base extends AnimBlueprintExtension { 
	Subsystem: AnimSubsystem_Base;
	static Load(ResourceName: string): AnimBlueprintExtension_Base;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_Base;
	static GetDefaultObject(): AnimBlueprintExtension_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_Base;
	static C(Other: UObject | any): AnimBlueprintExtension_Base;
}

declare type EFilterInterpolationType = 'BSIT_Average' | 'BSIT_Linear' | 'BSIT_Cubic' | 'BSIT_EaseInOut' | 'BSIT_ExponentialDecay' | 'BSIT_SpringDamper' | 'BSIT_MAX';
declare var EFilterInterpolationType : { BSIT_Average:'BSIT_Average',BSIT_Linear:'BSIT_Linear',BSIT_Cubic:'BSIT_Cubic',BSIT_EaseInOut:'BSIT_EaseInOut',BSIT_ExponentialDecay:'BSIT_ExponentialDecay',BSIT_SpringDamper:'BSIT_SpringDamper',BSIT_MAX:'BSIT_MAX', };
declare class InterpolationParameter { 
	InterpolationTime: number;
	DampingRatio: number;
	MaxSpeed: number;
	InterpolationType: EFilterInterpolationType;
	clone() : InterpolationParameter;
	static C(Other: UObject | any): InterpolationParameter;
}

declare class AnalysisProperties extends UObject { 
	UFunction: string;
	static Load(ResourceName: string): AnalysisProperties;
	static Find(Outer: UObject, ResourceName: string): AnalysisProperties;
	static GetDefaultObject(): AnalysisProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnalysisProperties;
	static C(Other: UObject | any): AnalysisProperties;
}

declare type ENotifyTriggerMode = 'AllAnimations' | 'HighestWeightedAnimation' | 'None' | 'ENotifyTriggerMode_MAX';
declare var ENotifyTriggerMode : { AllAnimations:'AllAnimations',HighestWeightedAnimation:'HighestWeightedAnimation',None:'None',ENotifyTriggerMode_MAX:'ENotifyTriggerMode_MAX', };
declare type EPreferredTriangulationDirection = 'None' | 'Tangential' | 'Radial' | 'EPreferredTriangulationDirection_MAX';
declare var EPreferredTriangulationDirection : { None:'None',Tangential:'Tangential',Radial:'Radial',EPreferredTriangulationDirection_MAX:'EPreferredTriangulationDirection_MAX', };
declare class PerBoneInterpolation { 
	BoneReference: BoneReference;
	InterpolationSpeedPerSec: number;
	clone() : PerBoneInterpolation;
	static C(Other: UObject | any): PerBoneInterpolation;
}

declare class BlendSample { 
	Animation: AnimSequence;
	SampleValue: Vector;
	RateScale: number;
	bIsValid: boolean;
	clone() : BlendSample;
	static C(Other: UObject | any): BlendSample;
}

declare class EditorElement { 
	Indices: number;
	Weights: number;
	clone() : EditorElement;
	static C(Other: UObject | any): EditorElement;
}

declare class BlendSpaceSegment { 
	SampleIndices: number;
	Vertices: number;
	clone() : BlendSpaceSegment;
	static C(Other: UObject | any): BlendSpaceSegment;
}

declare class BlendSpaceTriangleEdgeInfo { 
	Normal: Vector2D;
	NeighbourTriangleIndex: number;
	AdjacentPerimeterTriangleIndices: number;
	AdjacentPerimeterVertexIndices: number;
	clone() : BlendSpaceTriangleEdgeInfo;
	static C(Other: UObject | any): BlendSpaceTriangleEdgeInfo;
}

declare class BlendSpaceTriangle { 
	SampleIndices: number;
	Vertices: Vector2D;
	EdgeInfo: BlendSpaceTriangleEdgeInfo;
	clone() : BlendSpaceTriangle;
	static C(Other: UObject | any): BlendSpaceTriangle;
}

declare class BlendSpaceData { 
	Segments: BlendSpaceSegment[];
	Triangles: BlendSpaceTriangle[];
	clone() : BlendSpaceData;
	static C(Other: UObject | any): BlendSpaceData;
}

declare class BlendParameter { 
	DisplayName: string;
	Min: number;
	Max: number;
	GridNum: number;
	bSnapToGrid: boolean;
	bWrapInput: boolean;
	clone() : BlendParameter;
	static C(Other: UObject | any): BlendParameter;
}

declare type EBlendSpaceAxis = 'BSA_None' | 'BSA_X' | 'BSA_Y' | 'BSA_MAX';
declare var EBlendSpaceAxis : { BSA_None:'BSA_None',BSA_X:'BSA_X',BSA_Y:'BSA_Y',BSA_MAX:'BSA_MAX', };
declare class BlendSpace extends AnimationAsset { 
	bRotationBlendInMeshSpace: boolean;
	InterpolationParam: InterpolationParameter;
	AnalysisProperties: AnalysisProperties;
	TargetWeightInterpolationSpeedPerSec: number;
	bTargetWeightInterpolationEaseInOut: boolean;
	PreviewBasePose: AnimSequence;
	AnimLength: number;
	NotifyTriggerMode: ENotifyTriggerMode;
	bInterpolateUsingGrid: boolean;
	PreferredTriangulationDirection: EPreferredTriangulationDirection;
	PerBoneBlend: PerBoneInterpolation[];
	SampleIndexWithMarkers: number;
	SampleData: BlendSample[];
	GridSamples: EditorElement[];
	BlendSpaceData: BlendSpaceData;
	BlendParameters: BlendParameter;
	AxisToScaleAnimation: EBlendSpaceAxis;
	DimensionIndices: number[];
	static Load(ResourceName: string): BlendSpace;
	static Find(Outer: UObject, ResourceName: string): BlendSpace;
	static GetDefaultObject(): BlendSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpace;
	static C(Other: UObject | any): BlendSpace;
}

declare class AnimSubsystem_BlendSpaceGraph extends AnimSubsystem { 
	BlendSpaces: BlendSpace[];
	clone() : AnimSubsystem_BlendSpaceGraph;
	static C(Other: UObject | any): AnimSubsystem_BlendSpaceGraph;
}

declare class AnimBlueprintExtension_BlendSpaceGraph extends AnimBlueprintExtension { 
	Class: UnrealEngineClass;
	Subsystem: AnimSubsystem_BlendSpaceGraph;
	static Load(ResourceName: string): AnimBlueprintExtension_BlendSpaceGraph;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_BlendSpaceGraph;
	static GetDefaultObject(): AnimBlueprintExtension_BlendSpaceGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_BlendSpaceGraph;
	static C(Other: UObject | any): AnimBlueprintExtension_BlendSpaceGraph;
}

declare class AnimBlueprintExtension_CachedPose extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_CachedPose;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_CachedPose;
	static GetDefaultObject(): AnimBlueprintExtension_CachedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_CachedPose;
	static C(Other: UObject | any): AnimBlueprintExtension_CachedPose;
}

declare class AnimBlueprintExtension_CallFunction extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_CallFunction;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_CallFunction;
	static GetDefaultObject(): AnimBlueprintExtension_CallFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_CallFunction;
	static C(Other: UObject | any): AnimBlueprintExtension_CallFunction;
}

declare class AnimBlueprintExtension_LinkedAnimGraph extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_LinkedAnimGraph;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_LinkedAnimGraph;
	static GetDefaultObject(): AnimBlueprintExtension_LinkedAnimGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_LinkedAnimGraph;
	static C(Other: UObject | any): AnimBlueprintExtension_LinkedAnimGraph;
}

declare class AnimSubsystemInstance { 
	clone() : AnimSubsystemInstance;
	static C(Other: UObject | any): AnimSubsystemInstance;
}

declare class AnimSubsystemInstance_NodeRelevancy extends AnimSubsystemInstance { 
	clone() : AnimSubsystemInstance_NodeRelevancy;
	static C(Other: UObject | any): AnimSubsystemInstance_NodeRelevancy;
}

declare class AnimBlueprintExtension_NodeRelevancy extends AnimBlueprintExtension { 
	Subsystem: AnimSubsystemInstance_NodeRelevancy;
	static Load(ResourceName: string): AnimBlueprintExtension_NodeRelevancy;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_NodeRelevancy;
	static GetDefaultObject(): AnimBlueprintExtension_NodeRelevancy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_NodeRelevancy;
	static C(Other: UObject | any): AnimBlueprintExtension_NodeRelevancy;
}

declare class PropertyAccessSegment { 
	Name: string;
	struct: Struct;
	Property: any;
	UFunction: UFunction;
	ArrayIndex: number;
	Flags: any;
	clone() : PropertyAccessSegment;
	static C(Other: UObject | any): PropertyAccessSegment;
}

declare class PropertyAccessPath { 
	PathSegmentStartIndex: number;
	PathSegmentCount: number;
	clone() : PropertyAccessPath;
	static C(Other: UObject | any): PropertyAccessPath;
}

declare type EPropertyAccessCopyType = 'None' | 'Plain' | 'Complex' | 'Bool' | 'Struct' | 'Object' | 'Name' | 'Array' | 'PromoteBoolToByte' | 'PromoteBoolToInt32' | 'PromoteBoolToInt64' | 'PromoteBoolToFloat' | 'PromoteBoolToDouble' | 'PromoteByteToInt32' | 'PromoteByteToInt64' | 'PromoteByteToFloat' | 'PromoteByteToDouble' | 'PromoteInt32ToInt64' | 'PromoteInt32ToFloat' | 'PromoteInt32ToDouble' | 'PromoteFloatToDouble' | 'DemoteDoubleToFloat' | 'PromoteArrayFloatToDouble' | 'DemoteArrayDoubleToFloat' | 'EPropertyAccessCopyType_MAX';
declare var EPropertyAccessCopyType : { None:'None',Plain:'Plain',Complex:'Complex',Bool:'Bool',Struct:'Struct',Object:'Object',Name:'Name',Array:'Array',PromoteBoolToByte:'PromoteBoolToByte',PromoteBoolToInt32:'PromoteBoolToInt32',PromoteBoolToInt64:'PromoteBoolToInt64',PromoteBoolToFloat:'PromoteBoolToFloat',PromoteBoolToDouble:'PromoteBoolToDouble',PromoteByteToInt32:'PromoteByteToInt32',PromoteByteToInt64:'PromoteByteToInt64',PromoteByteToFloat:'PromoteByteToFloat',PromoteByteToDouble:'PromoteByteToDouble',PromoteInt32ToInt64:'PromoteInt32ToInt64',PromoteInt32ToFloat:'PromoteInt32ToFloat',PromoteInt32ToDouble:'PromoteInt32ToDouble',PromoteFloatToDouble:'PromoteFloatToDouble',DemoteDoubleToFloat:'DemoteDoubleToFloat',PromoteArrayFloatToDouble:'PromoteArrayFloatToDouble',DemoteArrayDoubleToFloat:'DemoteArrayDoubleToFloat',EPropertyAccessCopyType_MAX:'EPropertyAccessCopyType_MAX', };
declare class PropertyAccessCopy { 
	AccessIndex: number;
	DestAccessStartIndex: number;
	DestAccessEndIndex: number;
	Type: EPropertyAccessCopyType;
	clone() : PropertyAccessCopy;
	static C(Other: UObject | any): PropertyAccessCopy;
}

declare class PropertyAccessCopyBatch { 
	Copies: PropertyAccessCopy[];
	clone() : PropertyAccessCopyBatch;
	static C(Other: UObject | any): PropertyAccessCopyBatch;
}

declare class PropertyAccessIndirectionChain { 
	Property: any;
	IndirectionStartIndex: number;
	IndirectionEndIndex: number;
	clone() : PropertyAccessIndirectionChain;
	static C(Other: UObject | any): PropertyAccessIndirectionChain;
}

declare type EPropertyAccessObjectType = 'None' | 'Object' | 'WeakObject' | 'SoftObject' | 'EPropertyAccessObjectType_MAX';
declare var EPropertyAccessObjectType : { None:'None',Object:'Object',WeakObject:'WeakObject',SoftObject:'SoftObject',EPropertyAccessObjectType_MAX:'EPropertyAccessObjectType_MAX', };
declare type EPropertyAccessIndirectionType = 'Offset' | 'Object' | 'Array' | 'ScriptFunction' | 'NativeFunction' | 'EPropertyAccessIndirectionType_MAX';
declare var EPropertyAccessIndirectionType : { Offset:'Offset',Object:'Object',Array:'Array',ScriptFunction:'ScriptFunction',NativeFunction:'NativeFunction',EPropertyAccessIndirectionType_MAX:'EPropertyAccessIndirectionType_MAX', };
declare class PropertyAccessIndirection { 
	Property: any;
	UFunction: UFunction;
	ReturnBufferSize: number;
	ReturnBufferAlignment: number;
	ArrayIndex: number;
	Offset: any;
	ObjectType: EPropertyAccessObjectType;
	Type: EPropertyAccessIndirectionType;
	clone() : PropertyAccessIndirection;
	static C(Other: UObject | any): PropertyAccessIndirection;
}

declare class PropertyAccessLibrary { 
	PathSegments: PropertyAccessSegment[];
	SrcPaths: PropertyAccessPath[];
	DestPaths: PropertyAccessPath[];
	CopyBatches: PropertyAccessCopyBatch;
	CopyBatchArray: PropertyAccessCopyBatch[];
	SrcAccesses: PropertyAccessIndirectionChain[];
	DestAccesses: PropertyAccessIndirectionChain[];
	Indirections: PropertyAccessIndirection[];
	clone() : PropertyAccessLibrary;
	static C(Other: UObject | any): PropertyAccessLibrary;
}

declare class AnimSubsystem_PropertyAccess extends AnimSubsystem { 
	Library: PropertyAccessLibrary;
	clone() : AnimSubsystem_PropertyAccess;
	static C(Other: UObject | any): AnimSubsystem_PropertyAccess;
}

declare class AnimBlueprintExtension_PropertyAccess extends AnimBlueprintExtension { 
	Subsystem: AnimSubsystem_PropertyAccess;
	static Load(ResourceName: string): AnimBlueprintExtension_PropertyAccess;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_PropertyAccess;
	static GetDefaultObject(): AnimBlueprintExtension_PropertyAccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_PropertyAccess;
	static C(Other: UObject | any): AnimBlueprintExtension_PropertyAccess;
}

declare class AnimBlueprintExtension_StateMachine extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_StateMachine;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_StateMachine;
	static GetDefaultObject(): AnimBlueprintExtension_StateMachine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_StateMachine;
	static C(Other: UObject | any): AnimBlueprintExtension_StateMachine;
}

declare class AnimSubsystem_Tag extends AnimSubsystem { 
	NodeIndices: any;
	clone() : AnimSubsystem_Tag;
	static C(Other: UObject | any): AnimSubsystem_Tag;
}

declare class AnimBlueprintExtension_Tag extends AnimBlueprintExtension { 
	Subsystem: AnimSubsystem_Tag;
	static Load(ResourceName: string): AnimBlueprintExtension_Tag;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_Tag;
	static GetDefaultObject(): AnimBlueprintExtension_Tag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_Tag;
	static C(Other: UObject | any): AnimBlueprintExtension_Tag;
}

declare class AnimBlueprintPostCompileValidation extends UObject { 
	static Load(ResourceName: string): AnimBlueprintPostCompileValidation;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintPostCompileValidation;
	static GetDefaultObject(): AnimBlueprintPostCompileValidation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintPostCompileValidation;
	static C(Other: UObject | any): AnimBlueprintPostCompileValidation;
}

declare type EAnimGraphAttributesDisplayMode = 'HideOnPins' | 'ShowOnPins' | 'Automatic' | 'EAnimGraphAttributesDisplayMode_MAX';
declare var EAnimGraphAttributesDisplayMode : { HideOnPins:'HideOnPins',ShowOnPins:'ShowOnPins',Automatic:'Automatic',EAnimGraphAttributesDisplayMode_MAX:'EAnimGraphAttributesDisplayMode_MAX', };
declare type EAnimGraphAttributeBlend = 'Blendable' | 'NonBlendable' | 'EAnimGraphAttributeBlend_MAX';
declare var EAnimGraphAttributeBlend : { Blendable:'Blendable',NonBlendable:'NonBlendable',EAnimGraphAttributeBlend_MAX:'EAnimGraphAttributeBlend_MAX', };
declare class AnimGraphAttributeDesc { 
	Name: string;
	Icon: SlateBrush;
	DisplayName: string;
	ToolTipText: string;
	Color: SlateColor;
	DisplayMode: EAnimGraphAttributesDisplayMode;
	Blend: EAnimGraphAttributeBlend;
	SortOrder: number;
	clone() : AnimGraphAttributeDesc;
	static C(Other: UObject | any): AnimGraphAttributeDesc;
}

declare class AnimGraphAttributes extends UObject { 
	Attributes: AnimGraphAttributeDesc[];
	static Load(ResourceName: string): AnimGraphAttributes;
	static Find(Outer: UObject, ResourceName: string): AnimGraphAttributes;
	static GetDefaultObject(): AnimGraphAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphAttributes;
	static C(Other: UObject | any): AnimGraphAttributes;
}

declare class AnimGraphNodeCustomizationInterface extends Interface { 
	static Load(ResourceName: string): AnimGraphNodeCustomizationInterface;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNodeCustomizationInterface;
	static GetDefaultObject(): AnimGraphNodeCustomizationInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNodeCustomizationInterface;
	GetTitleColor(): LinearColor;
	static C(Other: UObject | any): AnimGraphNodeCustomizationInterface;
}

declare type EAnimSyncMethod = 'DoNotSync' | 'SyncGroup' | 'Graph' | 'EAnimSyncMethod_MAX';
declare var EAnimSyncMethod : { DoNotSync:'DoNotSync',SyncGroup:'SyncGroup',Graph:'Graph',EAnimSyncMethod_MAX:'EAnimSyncMethod_MAX', };
declare type EAnimGroupRole = 'CanBeLeader' | 'AlwaysFollower' | 'AlwaysLeader' | 'TransitionLeader' | 'TransitionFollower' | 'EAnimGroupRole_MAX';
declare var EAnimGroupRole : { CanBeLeader:'CanBeLeader',AlwaysFollower:'AlwaysFollower',AlwaysLeader:'AlwaysLeader',TransitionLeader:'TransitionLeader',TransitionFollower:'TransitionFollower',EAnimGroupRole_MAX:'EAnimGroupRole_MAX', };
declare class AnimationGroupReference { 
	Method: EAnimSyncMethod;
	GroupName: string;
	GroupRole: EAnimGroupRole;
	clone() : AnimationGroupReference;
	static C(Other: UObject | any): AnimationGroupReference;
}

declare class AnimGraphNode_AssetPlayerBase extends AnimGraphNode_Base { 
	SyncGroup: AnimationGroupReference;
	static Load(ResourceName: string): AnimGraphNode_AssetPlayerBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_AssetPlayerBase;
	static GetDefaultObject(): AnimGraphNode_AssetPlayerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AssetPlayerBase;
	static C(Other: UObject | any): AnimGraphNode_AssetPlayerBase;
}

declare class AnimGraphNode_BlendSpaceBase extends AnimGraphNode_AssetPlayerBase { 
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceBase;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceBase;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceBase;
}

declare type EAnimSyncGroupScope = 'Local' | 'Component' | 'EAnimSyncGroupScope_MAX';
declare var EAnimSyncGroupScope : { Local:'Local',Component:'Component',EAnimSyncGroupScope_MAX:'EAnimSyncGroupScope_MAX', };
declare class AnimNode_AssetPlayerBase extends AnimNode_Base { 
	GroupIndex: number;
	GroupScope: EAnimSyncGroupScope;
	BlendWeight: number;
	InternalTimeAccumulator: number;
	clone() : AnimNode_AssetPlayerBase;
	static C(Other: UObject | any): AnimNode_AssetPlayerBase;
}

declare class AnimNode_BlendSpacePlayer extends AnimNode_AssetPlayerBase { 
	GroupName: string;
	GroupRole: EAnimGroupRole;
	Method: EAnimSyncMethod;
	bIgnoreForRelevancyTest: boolean;
	X: number;
	Y: number;
	PlayRate: number;
	bLoop: boolean;
	bResetPlayTimeWhenBlendSpaceChanges: boolean;
	StartPosition: number;
	BlendSpace: BlendSpace;
	PreviousBlendSpace: BlendSpace;
	clone() : AnimNode_BlendSpacePlayer;
	static C(Other: UObject | any): AnimNode_BlendSpacePlayer;
}

declare class AnimNode_AimOffsetLookAt extends AnimNode_BlendSpacePlayer { 
	BasePose: PoseLink;
	LODThreshold: number;
	SourceSocketName: string;
	PivotSocketName: string;
	LookAtLocation: Vector;
	SocketAxis: Vector;
	Alpha: number;
	clone() : AnimNode_AimOffsetLookAt;
	static C(Other: UObject | any): AnimNode_AimOffsetLookAt;
}

declare class AnimGraphNode_AimOffsetLookAt extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_AimOffsetLookAt;
	static Load(ResourceName: string): AnimGraphNode_AimOffsetLookAt;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_AimOffsetLookAt;
	static GetDefaultObject(): AnimGraphNode_AimOffsetLookAt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AimOffsetLookAt;
	static C(Other: UObject | any): AnimGraphNode_AimOffsetLookAt;
}

declare class AnimGraphNode_SkeletalControlBase extends AnimGraphNode_Base { 
	static Load(ResourceName: string): AnimGraphNode_SkeletalControlBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SkeletalControlBase;
	static GetDefaultObject(): AnimGraphNode_SkeletalControlBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SkeletalControlBase;
	static C(Other: UObject | any): AnimGraphNode_SkeletalControlBase;
}

declare class ComponentSpacePoseLink extends PoseLinkBase { 
	clone() : ComponentSpacePoseLink;
	static C(Other: UObject | any): ComponentSpacePoseLink;
}

declare type EAnimAlphaInputType = 'Float' | 'Bool' | 'Curve' | 'EAnimAlphaInputType_MAX';
declare var EAnimAlphaInputType : { Float:'Float',Bool:'Bool',Curve:'Curve',EAnimAlphaInputType_MAX:'EAnimAlphaInputType_MAX', };
declare class InputScaleBias { 
	Scale: number;
	Bias: number;
	clone() : InputScaleBias;
	static C(Other: UObject | any): InputScaleBias;
}

declare class InputAlphaBoolBlend { 
	BlendInTime: number;
	BlendOutTime: number;
	BlendOption: EAlphaBlendOption;
	bInitialized: boolean;
	CustomCurve: CurveFloat;
	AlphaBlend: AlphaBlend;
	clone() : InputAlphaBoolBlend;
	static C(Other: UObject | any): InputAlphaBoolBlend;
}

declare class InputRange { 
	Min: number;
	Max: number;
	clone() : InputRange;
	static C(Other: UObject | any): InputRange;
}

declare class InputScaleBiasClamp { 
	bMapRange: boolean;
	bClampResult: boolean;
	bInterpResult: boolean;
	InRange: InputRange;
	OutRange: InputRange;
	Scale: number;
	Bias: number;
	ClampMin: number;
	ClampMax: number;
	InterpSpeedIncreasing: number;
	InterpSpeedDecreasing: number;
	clone() : InputScaleBiasClamp;
	static C(Other: UObject | any): InputScaleBiasClamp;
}

declare class AnimNode_SkeletalControlBase extends AnimNode_Base { 
	ComponentPose: ComponentSpacePoseLink;
	LODThreshold: number;
	ActualAlpha: number;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	clone() : AnimNode_SkeletalControlBase;
	static C(Other: UObject | any): AnimNode_SkeletalControlBase;
}

declare type AnimPhysLinearConstraintType = 'Free' | 'Limited' | 'AnimPhysLinearConstraintType_MAX';
declare var AnimPhysLinearConstraintType : { Free:'Free',Limited:'Limited',AnimPhysLinearConstraintType_MAX:'AnimPhysLinearConstraintType_MAX', };
declare type AnimPhysAngularConstraintType = 'Angular' | 'Cone' | 'AnimPhysAngularConstraintType_MAX';
declare var AnimPhysAngularConstraintType : { Angular:'Angular',Cone:'Cone',AnimPhysAngularConstraintType_MAX:'AnimPhysAngularConstraintType_MAX', };
declare type AnimPhysTwistAxis = 'AxisX' | 'AxisY' | 'AxisZ' | 'AnimPhysTwistAxis_MAX';
declare var AnimPhysTwistAxis : { AxisX:'AxisX',AxisY:'AxisY',AxisZ:'AxisZ',AnimPhysTwistAxis_MAX:'AnimPhysTwistAxis_MAX', };
declare class AnimPhysConstraintSetup { 
	LinearXLimitType: AnimPhysLinearConstraintType;
	LinearYLimitType: AnimPhysLinearConstraintType;
	LinearZLimitType: AnimPhysLinearConstraintType;
	LinearAxesMin: Vector;
	LinearAxesMax: Vector;
	AngularConstraintType: AnimPhysAngularConstraintType;
	TwistAxis: AnimPhysTwistAxis;
	AngularTargetAxis: AnimPhysTwistAxis;
	ConeAngle: number;
	AngularXAngle: number;
	AngularYAngle: number;
	AngularZAngle: number;
	AngularLimitsMin: Vector;
	AngularLimitsMax: Vector;
	AngularTarget: Vector;
	clone() : AnimPhysConstraintSetup;
	static C(Other: UObject | any): AnimPhysConstraintSetup;
}

declare type ESphericalLimitType = 'Inner' | 'Outer' | 'ESphericalLimitType_MAX';
declare var ESphericalLimitType : { Inner:'Inner',Outer:'Outer',ESphericalLimitType_MAX:'ESphericalLimitType_MAX', };
declare class AnimPhysSphericalLimit { 
	DrivingBone: BoneReference;
	SphereLocalOffset: Vector;
	LimitRadius: number;
	LimitType: ESphericalLimitType;
	clone() : AnimPhysSphericalLimit;
	static C(Other: UObject | any): AnimPhysSphericalLimit;
}

declare class AnimPhysPlanarLimit { 
	DrivingBone: BoneReference;
	PlaneTransform: Transform;
	clone() : AnimPhysPlanarLimit;
	static C(Other: UObject | any): AnimPhysPlanarLimit;
}

declare type AnimPhysCollisionType = 'CoM' | 'CustomSphere' | 'InnerSphere' | 'OuterSphere' | 'AnimPhysCollisionType_MAX';
declare var AnimPhysCollisionType : { CoM:'CoM',CustomSphere:'CustomSphere',InnerSphere:'InnerSphere',OuterSphere:'OuterSphere',AnimPhysCollisionType_MAX:'AnimPhysCollisionType_MAX', };
declare type AnimPhysSimSpaceType = 'Component' | 'Actor' | 'World' | 'RootRelative' | 'BoneRelative' | 'AnimPhysSimSpaceType_MAX';
declare var AnimPhysSimSpaceType : { Component:'Component',Actor:'Actor',World:'World',RootRelative:'RootRelative',BoneRelative:'BoneRelative',AnimPhysSimSpaceType_MAX:'AnimPhysSimSpaceType_MAX', };
declare type ERotationComponent = 'EulerX' | 'EulerY' | 'EulerZ' | 'QuaternionAngle' | 'SwingAngle' | 'TwistAngle' | 'ERotationComponent_MAX';
declare var ERotationComponent : { EulerX:'EulerX',EulerY:'EulerY',EulerZ:'EulerZ',QuaternionAngle:'QuaternionAngle',SwingAngle:'SwingAngle',TwistAngle:'TwistAngle',ERotationComponent_MAX:'ERotationComponent_MAX', };
declare class RotationRetargetingInfo { 
	bEnabled: boolean;
	Source: Transform;
	Target: Transform;
	RotationComponent: ERotationComponent;
	TwistAxis: Vector;
	bUseAbsoluteAngle: boolean;
	SourceMinimum: number;
	SourceMaximum: number;
	TargetMinimum: number;
	TargetMaximum: number;
	EasingType: EEasingFuncType;
	CustomCurve: RuntimeFloatCurve;
	bFlipEasing: boolean;
	EasingWeight: number;
	bClamp: boolean;
	clone() : RotationRetargetingInfo;
	static C(Other: UObject | any): RotationRetargetingInfo;
}

declare class AnimNode_AnimDynamics extends AnimNode_SkeletalControlBase { 
	LinearDampingOverride: number;
	AngularDampingOverride: number;
	RelativeSpaceBone: BoneReference;
	BoundBone: BoneReference;
	ChainEnd: BoneReference;
	BoxExtents: Vector;
	LocalJointOffset: Vector;
	GravityScale: number;
	GravityOverride: Vector;
	LinearSpringConstant: number;
	AngularSpringConstant: number;
	WindScale: number;
	ComponentLinearAccScale: Vector;
	ComponentLinearVelScale: Vector;
	ComponentAppliedLinearAccClamp: Vector;
	AngularBiasOverride: number;
	NumSolverIterationsPreUpdate: number;
	NumSolverIterationsPostUpdate: number;
	ConstraintSetup: AnimPhysConstraintSetup;
	SphericalLimits: AnimPhysSphericalLimit[];
	SphereCollisionRadius: number;
	ExternalForce: Vector;
	PlanarLimits: AnimPhysPlanarLimit[];
	CollisionType: AnimPhysCollisionType;
	SimulationSpace: AnimPhysSimSpaceType;
	bUseSphericalLimits: boolean;
	bUsePlanarLimit: boolean;
	bDoUpdate: boolean;
	bDoEval: boolean;
	bOverrideLinearDamping: boolean;
	bOverrideAngularBias: boolean;
	bOverrideAngularDamping: boolean;
	bEnableWind: boolean;
	bUseGravityOverride: boolean;
	bGravityOverrideInSimSpace: boolean;
	bLinearSpring: boolean;
	bAngularSpring: boolean;
	bChain: boolean;
	RetargetingSettings: RotationRetargetingInfo;
	clone() : AnimNode_AnimDynamics;
	static C(Other: UObject | any): AnimNode_AnimDynamics;
}

declare class AnimGraphNode_AnimDynamics extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_AnimDynamics;
	bPreviewLive: boolean;
	bShowLinearLimits: boolean;
	bShowAngularLimits: boolean;
	bShowPlanarLimit: boolean;
	bShowSphericalLimit: boolean;
	bShowCollisionSpheres: boolean;
	LastPreviewComponent: SkeletalMeshComponent;
	static Load(ResourceName: string): AnimGraphNode_AnimDynamics;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_AnimDynamics;
	static GetDefaultObject(): AnimGraphNode_AnimDynamics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AnimDynamics;
	static C(Other: UObject | any): AnimGraphNode_AnimDynamics;
}

declare class AnimNode_ApplyAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	LODThreshold: number;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	clone() : AnimNode_ApplyAdditive;
	static C(Other: UObject | any): AnimNode_ApplyAdditive;
}

declare class AnimGraphNode_ApplyAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_ApplyAdditive;
	static Load(ResourceName: string): AnimGraphNode_ApplyAdditive;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ApplyAdditive;
	static GetDefaultObject(): AnimGraphNode_ApplyAdditive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ApplyAdditive;
	static C(Other: UObject | any): AnimGraphNode_ApplyAdditive;
}

declare class AngularRangeLimit { 
	LimitMin: Vector;
	LimitMax: Vector;
	bone: BoneReference;
	clone() : AngularRangeLimit;
	static C(Other: UObject | any): AngularRangeLimit;
}

declare class AnimNode_ApplyLimits extends AnimNode_SkeletalControlBase { 
	AngularRangeLimits: AngularRangeLimit[];
	AngularOffsets: Vector[];
	clone() : AnimNode_ApplyLimits;
	static C(Other: UObject | any): AnimNode_ApplyLimits;
}

declare class AnimGraphNode_ApplyLimits extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ApplyLimits;
	static Load(ResourceName: string): AnimGraphNode_ApplyLimits;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ApplyLimits;
	static GetDefaultObject(): AnimGraphNode_ApplyLimits;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ApplyLimits;
	static C(Other: UObject | any): AnimGraphNode_ApplyLimits;
}

declare class AnimNode_ApplyMeshSpaceAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	AlphaInputType: EAnimAlphaInputType;
	Alpha: number;
	bAlphaBoolEnabled: boolean;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBias: InputScaleBias;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	LODThreshold: number;
	clone() : AnimNode_ApplyMeshSpaceAdditive;
	static C(Other: UObject | any): AnimNode_ApplyMeshSpaceAdditive;
}

declare class AnimGraphNode_ApplyMeshSpaceAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_ApplyMeshSpaceAdditive;
	static Load(ResourceName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
	static GetDefaultObject(): AnimGraphNode_ApplyMeshSpaceAdditive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ApplyMeshSpaceAdditive;
	static C(Other: UObject | any): AnimGraphNode_ApplyMeshSpaceAdditive;
}

declare class BlendBoneByChannelEntry { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bBlendTranslation: boolean;
	bBlendRotation: boolean;
	bBlendScale: boolean;
	clone() : BlendBoneByChannelEntry;
	static C(Other: UObject | any): BlendBoneByChannelEntry;
}

declare type EBoneControlSpace = 'BCS_WorldSpace' | 'BCS_ComponentSpace' | 'BCS_ParentBoneSpace' | 'BCS_BoneSpace' | 'BCS_MAX';
declare var EBoneControlSpace : { BCS_WorldSpace:'BCS_WorldSpace',BCS_ComponentSpace:'BCS_ComponentSpace',BCS_ParentBoneSpace:'BCS_ParentBoneSpace',BCS_BoneSpace:'BCS_BoneSpace',BCS_MAX:'BCS_MAX', };
declare class AnimNode_BlendBoneByChannel extends AnimNode_Base { 
	A: PoseLink;
	B: PoseLink;
	BoneDefinitions: BlendBoneByChannelEntry[];
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	TransformsSpace: EBoneControlSpace;
	clone() : AnimNode_BlendBoneByChannel;
	static C(Other: UObject | any): AnimNode_BlendBoneByChannel;
}

declare class AnimGraphNode_BlendBoneByChannel extends AnimGraphNode_Base { 
	BlendNode: AnimNode_BlendBoneByChannel;
	static Load(ResourceName: string): AnimGraphNode_BlendBoneByChannel;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendBoneByChannel;
	static GetDefaultObject(): AnimGraphNode_BlendBoneByChannel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendBoneByChannel;
	static C(Other: UObject | any): AnimGraphNode_BlendBoneByChannel;
}

declare class AnimGraphNode_BlendListBase extends AnimGraphNode_Base { 
	static Load(ResourceName: string): AnimGraphNode_BlendListBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListBase;
	static GetDefaultObject(): AnimGraphNode_BlendListBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListBase;
	static C(Other: UObject | any): AnimGraphNode_BlendListBase;
}

declare type EBlendListTransitionType = 'StandardBlend' | 'Inertialization' | 'EBlendListTransitionType_MAX';
declare var EBlendListTransitionType : { StandardBlend:'StandardBlend',Inertialization:'Inertialization',EBlendListTransitionType_MAX:'EBlendListTransitionType_MAX', };
declare class AnimNode_BlendListBase extends AnimNode_Base { 
	BlendPose: PoseLink[];
	BlendTime: number[];
	TransitionType: EBlendListTransitionType;
	BlendType: EAlphaBlendOption;
	bResetChildOnActivation: boolean;
	CustomBlendCurve: CurveFloat;
	BlendProfile: BlendProfile;
	clone() : AnimNode_BlendListBase;
	static C(Other: UObject | any): AnimNode_BlendListBase;
}

declare class AnimNode_BlendListByBool extends AnimNode_BlendListBase { 
	bActiveValue: boolean;
	clone() : AnimNode_BlendListByBool;
	static C(Other: UObject | any): AnimNode_BlendListByBool;
}

declare class AnimGraphNode_BlendListByBool extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByBool;
	static Load(ResourceName: string): AnimGraphNode_BlendListByBool;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListByBool;
	static GetDefaultObject(): AnimGraphNode_BlendListByBool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByBool;
	static C(Other: UObject | any): AnimGraphNode_BlendListByBool;
}

declare class AnimNode_BlendListByEnum extends AnimNode_BlendListBase { 
	EnumToPoseIndex: number[];
	ActiveEnumValue: number;
	clone() : AnimNode_BlendListByEnum;
	static C(Other: UObject | any): AnimNode_BlendListByEnum;
}

declare class AnimGraphNode_BlendListByEnum extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByEnum;
	BoundEnum: Enum;
	VisibleEnumEntries: string[];
	static Load(ResourceName: string): AnimGraphNode_BlendListByEnum;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListByEnum;
	static GetDefaultObject(): AnimGraphNode_BlendListByEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByEnum;
	static C(Other: UObject | any): AnimGraphNode_BlendListByEnum;
}

declare class AnimNode_BlendListByInt extends AnimNode_BlendListBase { 
	ActiveChildIndex: number;
	clone() : AnimNode_BlendListByInt;
	static C(Other: UObject | any): AnimNode_BlendListByInt;
}

declare class AnimGraphNode_BlendListByInt extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByInt;
	static Load(ResourceName: string): AnimGraphNode_BlendListByInt;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListByInt;
	static GetDefaultObject(): AnimGraphNode_BlendListByInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByInt;
	static C(Other: UObject | any): AnimGraphNode_BlendListByInt;
}

declare class AnimNode_BlendSpaceEvaluator extends AnimNode_BlendSpacePlayer { 
	NormalizedTime: number;
	bTeleportToNormalizedTime: boolean;
	clone() : AnimNode_BlendSpaceEvaluator;
	static C(Other: UObject | any): AnimNode_BlendSpaceEvaluator;
}

declare class AnimGraphNode_BlendSpaceEvaluator extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_BlendSpaceEvaluator;
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceEvaluator;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceEvaluator;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceEvaluator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceEvaluator;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceEvaluator;
}

declare class BlendSpaceGraph extends EdGraph { 
	BlendSpace: BlendSpace;
	static Load(ResourceName: string): BlendSpaceGraph;
	static Find(Outer: UObject, ResourceName: string): BlendSpaceGraph;
	static GetDefaultObject(): BlendSpaceGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpaceGraph;
	static C(Other: UObject | any): BlendSpaceGraph;
}

declare class AnimGraphNode_BlendSpaceGraphBase extends AnimGraphNode_Base { 
	BlendSpace: BlendSpace;
	BlendSpaceClass: UnrealEngineClass;
	BlendSpaceGraph: BlendSpaceGraph;
	Graphs: EdGraph[];
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceGraphBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceGraphBase;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceGraphBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceGraphBase;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceGraphBase;
}

declare class AnimNode_BlendSpaceGraphBase extends AnimNode_Base { 
	X: number;
	Y: number;
	GroupName: string;
	GroupRole: EAnimGroupRole;
	BlendSpace: BlendSpace;
	SamplePoseLinks: PoseLink[];
	clone() : AnimNode_BlendSpaceGraphBase;
	static C(Other: UObject | any): AnimNode_BlendSpaceGraphBase;
}

declare class AnimNode_BlendSpaceGraph extends AnimNode_BlendSpaceGraphBase { 
	clone() : AnimNode_BlendSpaceGraph;
	static C(Other: UObject | any): AnimNode_BlendSpaceGraph;
}

declare class AnimGraphNode_BlendSpaceGraph extends AnimGraphNode_BlendSpaceGraphBase { 
	UNode: AnimNode_BlendSpaceGraph;
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceGraph;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceGraph;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceGraph;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceGraph;
}

declare class AnimGraphNode_BlendSpacePlayer extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_BlendSpacePlayer;
	static Load(ResourceName: string): AnimGraphNode_BlendSpacePlayer;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpacePlayer;
	static GetDefaultObject(): AnimGraphNode_BlendSpacePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpacePlayer;
	static C(Other: UObject | any): AnimGraphNode_BlendSpacePlayer;
}

declare type EComponentType = 'None' | 'TranslationX' | 'TranslationY' | 'TranslationZ' | 'RotationX' | 'RotationY' | 'RotationZ' | 'Scale' | 'ScaleX' | 'ScaleY' | 'ScaleZ' | 'EComponentType_MAX';
declare var EComponentType : { None:'None',TranslationX:'TranslationX',TranslationY:'TranslationY',TranslationZ:'TranslationZ',RotationX:'RotationX',RotationY:'RotationY',RotationZ:'RotationZ',Scale:'Scale',ScaleX:'ScaleX',ScaleY:'ScaleY',ScaleZ:'ScaleZ',EComponentType_MAX:'EComponentType_MAX', };
declare type EDrivenDestinationMode = 'Bone' | 'MorphTarget' | 'MaterialParameter' | 'EDrivenDestinationMode_MAX';
declare var EDrivenDestinationMode : { Bone:'Bone',MorphTarget:'MorphTarget',MaterialParameter:'MaterialParameter',EDrivenDestinationMode_MAX:'EDrivenDestinationMode_MAX', };
declare type EDrivenBoneModificationMode = 'AddToInput' | 'ReplaceComponent' | 'AddToRefPose' | 'EDrivenBoneModificationMode_MAX';
declare var EDrivenBoneModificationMode : { AddToInput:'AddToInput',ReplaceComponent:'ReplaceComponent',AddToRefPose:'AddToRefPose',EDrivenBoneModificationMode_MAX:'EDrivenBoneModificationMode_MAX', };
declare class AnimNode_BoneDrivenController extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	DrivingCurve: CurveFloat;
	Multiplier: number;
	RangeMin: number;
	RangeMax: number;
	RemappedMin: number;
	RemappedMax: number;
	ParameterName: string;
	TargetBone: BoneReference;
	TargetComponent: EComponentType;
	DestinationMode: EDrivenDestinationMode;
	ModificationMode: EDrivenBoneModificationMode;
	SourceComponent: EComponentType;
	bUseRange: boolean;
	bAffectTargetTranslationX: boolean;
	bAffectTargetTranslationY: boolean;
	bAffectTargetTranslationZ: boolean;
	bAffectTargetRotationX: boolean;
	bAffectTargetRotationY: boolean;
	bAffectTargetRotationZ: boolean;
	bAffectTargetScaleX: boolean;
	bAffectTargetScaleY: boolean;
	bAffectTargetScaleZ: boolean;
	clone() : AnimNode_BoneDrivenController;
	static C(Other: UObject | any): AnimNode_BoneDrivenController;
}

declare class AnimGraphNode_BoneDrivenController extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_BoneDrivenController;
	static Load(ResourceName: string): AnimGraphNode_BoneDrivenController;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BoneDrivenController;
	static GetDefaultObject(): AnimGraphNode_BoneDrivenController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BoneDrivenController;
	static C(Other: UObject | any): AnimGraphNode_BoneDrivenController;
}

declare class K2Node_CallFunction extends K2Node { 
	bIsPureFunc: boolean;
	bIsConstFunc: boolean;
	bWantsEnumToExecExpansion: boolean;
	bIsInterfaceCall: boolean;
	bIsFinalFunction: boolean;
	bIsBeadFunction: boolean;
	FunctionReference: MemberReference;
	CallFunctionName: string;
	CallFunctionClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_CallFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallFunction;
	static GetDefaultObject(): K2Node_CallFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunction;
	static C(Other: UObject | any): K2Node_CallFunction;
}

declare type EAnimFunctionCallSite = 'OnInitialize' | 'OnUpdate' | 'OnBecomeRelevant' | 'OnEvaluate' | 'OnInitializePostRecursion' | 'OnUpdatePostRecursion' | 'OnBecomeRelevantPostRecursion' | 'OnEvaluatePostRecursion' | 'OnStartedBlendingOut' | 'OnStartedBlendingIn' | 'OnFinishedBlendingOut' | 'OnFinishedBlendingIn' | 'EAnimFunctionCallSite_MAX';
declare var EAnimFunctionCallSite : { OnInitialize:'OnInitialize',OnUpdate:'OnUpdate',OnBecomeRelevant:'OnBecomeRelevant',OnEvaluate:'OnEvaluate',OnInitializePostRecursion:'OnInitializePostRecursion',OnUpdatePostRecursion:'OnUpdatePostRecursion',OnBecomeRelevantPostRecursion:'OnBecomeRelevantPostRecursion',OnEvaluatePostRecursion:'OnEvaluatePostRecursion',OnStartedBlendingOut:'OnStartedBlendingOut',OnStartedBlendingIn:'OnStartedBlendingIn',OnFinishedBlendingOut:'OnFinishedBlendingOut',OnFinishedBlendingIn:'OnFinishedBlendingIn',EAnimFunctionCallSite_MAX:'EAnimFunctionCallSite_MAX', };
declare class AnimNode_CallFunction extends AnimNode_Base { 
	Source: PoseLink;
	UFunction: AnimNodeFunctionRef;
	CallSite: EAnimFunctionCallSite;
	clone() : AnimNode_CallFunction;
	static C(Other: UObject | any): AnimNode_CallFunction;
}

declare class AnimGraphNode_CallFunction extends AnimGraphNode_Base { 
	InnerGraph: EdGraph;
	CallFunctionPrototype: K2Node_CallFunction;
	UNode: AnimNode_CallFunction;
	static Load(ResourceName: string): AnimGraphNode_CallFunction;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CallFunction;
	static GetDefaultObject(): AnimGraphNode_CallFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CallFunction;
	static C(Other: UObject | any): AnimGraphNode_CallFunction;
}

declare class SocketReference { 
	SocketName: string;
	clone() : SocketReference;
	static C(Other: UObject | any): SocketReference;
}

declare class BoneSocketTarget { 
	bUseSocket: boolean;
	BoneReference: BoneReference;
	SocketReference: SocketReference;
	clone() : BoneSocketTarget;
	static C(Other: UObject | any): BoneSocketTarget;
}

declare class AnimNode_CCDIK extends AnimNode_SkeletalControlBase { 
	EffectorLocation: Vector;
	EffectorLocationSpace: EBoneControlSpace;
	EffectorTarget: BoneSocketTarget;
	TipBone: BoneReference;
	RootBone: BoneReference;
	Precision: number;
	MaxIterations: number;
	bStartFromTail: boolean;
	bEnableRotationLimit: boolean;
	RotationLimitPerJoints: number[];
	clone() : AnimNode_CCDIK;
	static C(Other: UObject | any): AnimNode_CCDIK;
}

declare class AnimGraphNode_CCDIK extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_CCDIK;
	static Load(ResourceName: string): AnimGraphNode_CCDIK;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CCDIK;
	static GetDefaultObject(): AnimGraphNode_CCDIK;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CCDIK;
	static C(Other: UObject | any): AnimGraphNode_CCDIK;
}

declare class AnimNode_ConvertComponentToLocalSpace extends AnimNode_Base { 
	ComponentPose: ComponentSpacePoseLink;
	clone() : AnimNode_ConvertComponentToLocalSpace;
	static C(Other: UObject | any): AnimNode_ConvertComponentToLocalSpace;
}

declare class AnimGraphNode_ComponentToLocalSpace extends AnimGraphNode_Base { 
	UNode: AnimNode_ConvertComponentToLocalSpace;
	static Load(ResourceName: string): AnimGraphNode_ComponentToLocalSpace;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ComponentToLocalSpace;
	static GetDefaultObject(): AnimGraphNode_ComponentToLocalSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ComponentToLocalSpace;
	static C(Other: UObject | any): AnimGraphNode_ComponentToLocalSpace;
}

declare type EConstraintOffsetOption = 'None' | 'Offset_RefPose' | 'EConstraintOffsetOption_MAX';
declare var EConstraintOffsetOption : { None:'None',Offset_RefPose:'Offset_RefPose',EConstraintOffsetOption_MAX:'EConstraintOffsetOption_MAX', };
declare type ETransformConstraintType = 'Translation' | 'Rotation' | 'Scale' | 'Parent' | 'ETransformConstraintType_MAX';
declare var ETransformConstraintType : { Translation:'Translation',Rotation:'Rotation',Scale:'Scale',Parent:'Parent',ETransformConstraintType_MAX:'ETransformConstraintType_MAX', };
declare class FilterOptionPerAxis { 
	bX: boolean;
	bY: boolean;
	bZ: boolean;
	clone() : FilterOptionPerAxis;
	static C(Other: UObject | any): FilterOptionPerAxis;
}

declare class Constraint { 
	TargetBone: BoneReference;
	OffsetOption: EConstraintOffsetOption;
	TransformType: ETransformConstraintType;
	PerAxis: FilterOptionPerAxis;
	clone() : Constraint;
	static C(Other: UObject | any): Constraint;
}

declare class AnimNode_Constraint extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	ConstraintSetup: Constraint[];
	ConstraintWeights: number[];
	clone() : AnimNode_Constraint;
	static C(Other: UObject | any): AnimNode_Constraint;
}

declare class AnimGraphNode_Constraint extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Constraint;
	static Load(ResourceName: string): AnimGraphNode_Constraint;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Constraint;
	static GetDefaultObject(): AnimGraphNode_Constraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Constraint;
	static C(Other: UObject | any): AnimGraphNode_Constraint;
}

declare class AnimNode_CopyBone extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bCopyTranslation: boolean;
	bCopyRotation: boolean;
	bCopyScale: boolean;
	ControlSpace: EBoneControlSpace;
	clone() : AnimNode_CopyBone;
	static C(Other: UObject | any): AnimNode_CopyBone;
}

declare class AnimGraphNode_CopyBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_CopyBone;
	static Load(ResourceName: string): AnimGraphNode_CopyBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CopyBone;
	static GetDefaultObject(): AnimGraphNode_CopyBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyBone;
	static C(Other: UObject | any): AnimGraphNode_CopyBone;
}

declare type CopyBoneDeltaMode = 'Accumulate' | 'Copy' | 'CopyBoneDeltaMode_MAX';
declare var CopyBoneDeltaMode : { Accumulate:'Accumulate',Copy:'Copy',CopyBoneDeltaMode_MAX:'CopyBoneDeltaMode_MAX', };
declare class AnimNode_CopyBoneDelta extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bCopyTranslation: boolean;
	bCopyRotation: boolean;
	bCopyScale: boolean;
	CopyMode: CopyBoneDeltaMode;
	TranslationMultiplier: number;
	RotationMultiplier: number;
	ScaleMultiplier: number;
	clone() : AnimNode_CopyBoneDelta;
	static C(Other: UObject | any): AnimNode_CopyBoneDelta;
}

declare class AnimGraphNode_CopyBoneDelta extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_CopyBoneDelta;
	static Load(ResourceName: string): AnimGraphNode_CopyBoneDelta;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CopyBoneDelta;
	static GetDefaultObject(): AnimGraphNode_CopyBoneDelta;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyBoneDelta;
	static C(Other: UObject | any): AnimGraphNode_CopyBoneDelta;
}

declare class AnimNode_CopyPoseFromMesh extends AnimNode_Base { 
	SourceMeshComponent: any;
	bUseAttachedParent: boolean;
	bCopyCurves: boolean;
	bCopyCustomAttributes: boolean;
	bUseMeshPose: boolean;
	RootBoneToCopy: string;
	clone() : AnimNode_CopyPoseFromMesh;
	static C(Other: UObject | any): AnimNode_CopyPoseFromMesh;
}

declare class AnimGraphNode_CopyPoseFromMesh extends AnimGraphNode_Base { 
	UNode: AnimNode_CopyPoseFromMesh;
	static Load(ResourceName: string): AnimGraphNode_CopyPoseFromMesh;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CopyPoseFromMesh;
	static GetDefaultObject(): AnimGraphNode_CopyPoseFromMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyPoseFromMesh;
	static C(Other: UObject | any): AnimGraphNode_CopyPoseFromMesh;
}

declare class AnimNode_CurveSource extends AnimNode_Base { 
	SourcePose: PoseLink;
	SourceBinding: string;
	Alpha: number;
	CurveSource: any;
	clone() : AnimNode_CurveSource;
	static C(Other: UObject | any): AnimNode_CurveSource;
}

declare class AnimGraphNode_CurveSource extends AnimGraphNode_Base { 
	UNode: AnimNode_CurveSource;
	static Load(ResourceName: string): AnimGraphNode_CurveSource;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CurveSource;
	static GetDefaultObject(): AnimGraphNode_CurveSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CurveSource;
	static C(Other: UObject | any): AnimGraphNode_CurveSource;
}

declare class AnimGraphNode_CustomProperty extends AnimGraphNode_Base { 
	KnownExposableProperties: string[];
	ExposedPropertyNames: string[];
	CustomPinProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): AnimGraphNode_CustomProperty;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CustomProperty;
	static GetDefaultObject(): AnimGraphNode_CustomProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CustomProperty;
	static C(Other: UObject | any): AnimGraphNode_CustomProperty;
}

declare type EBoneRotationSource = 'BRS_KeepComponentSpaceRotation' | 'BRS_KeepLocalSpaceRotation' | 'BRS_CopyFromTarget' | 'BRS_MAX';
declare var EBoneRotationSource : { BRS_KeepComponentSpaceRotation:'BRS_KeepComponentSpaceRotation',BRS_KeepLocalSpaceRotation:'BRS_KeepLocalSpaceRotation',BRS_CopyFromTarget:'BRS_CopyFromTarget',BRS_MAX:'BRS_MAX', };
declare class AnimNode_Fabrik extends AnimNode_SkeletalControlBase { 
	EffectorTransform: Transform;
	EffectorTarget: BoneSocketTarget;
	TipBone: BoneReference;
	RootBone: BoneReference;
	Precision: number;
	MaxIterations: number;
	EffectorTransformSpace: EBoneControlSpace;
	EffectorRotationSource: EBoneRotationSource;
	bEnableDebugDraw: boolean;
	EffectorTransformBone: BoneReference;
	clone() : AnimNode_Fabrik;
	static C(Other: UObject | any): AnimNode_Fabrik;
}

declare class AnimGraphNode_Fabrik extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Fabrik;
	static Load(ResourceName: string): AnimGraphNode_Fabrik;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Fabrik;
	static GetDefaultObject(): AnimGraphNode_Fabrik;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Fabrik;
	static C(Other: UObject | any): AnimGraphNode_Fabrik;
}

declare class AnimNode_HandIKRetargeting extends AnimNode_SkeletalControlBase { 
	RightHandFK: BoneReference;
	LeftHandFK: BoneReference;
	RightHandIK: BoneReference;
	LeftHandIK: BoneReference;
	IKBonesToMove: BoneReference[];
	HandFKWeight: number;
	clone() : AnimNode_HandIKRetargeting;
	static C(Other: UObject | any): AnimNode_HandIKRetargeting;
}

declare class AnimGraphNode_HandIKRetargeting extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_HandIKRetargeting;
	static Load(ResourceName: string): AnimGraphNode_HandIKRetargeting;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_HandIKRetargeting;
	static GetDefaultObject(): AnimGraphNode_HandIKRetargeting;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_HandIKRetargeting;
	static C(Other: UObject | any): AnimGraphNode_HandIKRetargeting;
}

declare type ERefPoseType = 'EIT_LocalSpace' | 'EIT_Additive' | 'EIT_MAX';
declare var ERefPoseType : { EIT_LocalSpace:'EIT_LocalSpace',EIT_Additive:'EIT_Additive',EIT_MAX:'EIT_MAX', };
declare class AnimNode_RefPose extends AnimNode_Base { 
	RefPoseType: ERefPoseType;
	clone() : AnimNode_RefPose;
	static C(Other: UObject | any): AnimNode_RefPose;
}

declare class AnimGraphNode_RefPoseBase extends AnimGraphNode_Base { 
	UNode: AnimNode_RefPose;
	static Load(ResourceName: string): AnimGraphNode_RefPoseBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RefPoseBase;
	static GetDefaultObject(): AnimGraphNode_RefPoseBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RefPoseBase;
	static C(Other: UObject | any): AnimGraphNode_RefPoseBase;
}

declare class AnimGraphNode_IdentityPose extends AnimGraphNode_RefPoseBase { 
	static Load(ResourceName: string): AnimGraphNode_IdentityPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_IdentityPose;
	static GetDefaultObject(): AnimGraphNode_IdentityPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_IdentityPose;
	static C(Other: UObject | any): AnimGraphNode_IdentityPose;
}

declare class AnimNode_Inertialization extends AnimNode_Base { 
	Source: PoseLink;
	FilteredCurves: string[];
	clone() : AnimNode_Inertialization;
	static C(Other: UObject | any): AnimNode_Inertialization;
}

declare class AnimGraphNode_Inertialization extends AnimGraphNode_Base { 
	UNode: AnimNode_Inertialization;
	static Load(ResourceName: string): AnimGraphNode_Inertialization;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Inertialization;
	static GetDefaultObject(): AnimGraphNode_Inertialization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Inertialization;
	static C(Other: UObject | any): AnimGraphNode_Inertialization;
}

declare type ELayeredBoneBlendMode = 'BranchFilter' | 'BlendMask' | 'ELayeredBoneBlendMode_MAX';
declare var ELayeredBoneBlendMode : { BranchFilter:'BranchFilter',BlendMask:'BlendMask',ELayeredBoneBlendMode_MAX:'ELayeredBoneBlendMode_MAX', };
declare class BranchFilter { 
	BoneName: string;
	BlendDepth: number;
	clone() : BranchFilter;
	static C(Other: UObject | any): BranchFilter;
}

declare class InputBlendPose { 
	BranchFilters: BranchFilter[];
	clone() : InputBlendPose;
	static C(Other: UObject | any): InputBlendPose;
}

declare type ECurveBlendOption = 'Override' | 'DoNotOverride' | 'NormalizeByWeight' | 'BlendByWeight' | 'UseBasePose' | 'UseMaxValue' | 'UseMinValue' | 'ECurveBlendOption_MAX';
declare var ECurveBlendOption : { Override:'Override',DoNotOverride:'DoNotOverride',NormalizeByWeight:'NormalizeByWeight',BlendByWeight:'BlendByWeight',UseBasePose:'UseBasePose',UseMaxValue:'UseMaxValue',UseMinValue:'UseMinValue',ECurveBlendOption_MAX:'ECurveBlendOption_MAX', };
declare class PerBoneBlendWeight { 
	SourceIndex: number;
	BlendWeight: number;
	clone() : PerBoneBlendWeight;
	static C(Other: UObject | any): PerBoneBlendWeight;
}

declare class AnimNode_LayeredBoneBlend extends AnimNode_Base { 
	BasePose: PoseLink;
	BlendPoses: PoseLink[];
	BlendMode: ELayeredBoneBlendMode;
	BlendMasks: BlendProfile[];
	LayerSetup: InputBlendPose[];
	BlendWeights: number[];
	bMeshSpaceRotationBlend: boolean;
	bMeshSpaceScaleBlend: boolean;
	CurveBlendOption: ECurveBlendOption;
	bBlendRootMotionBasedOnRootBone: boolean;
	LODThreshold: number;
	PerBoneBlendWeights: PerBoneBlendWeight[];
	SkeletonGuid: Guid;
	VirtualBoneGuid: Guid;
	clone() : AnimNode_LayeredBoneBlend;
	static C(Other: UObject | any): AnimNode_LayeredBoneBlend;
}

declare class AnimGraphNode_LayeredBoneBlend extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_LayeredBoneBlend;
	static Load(ResourceName: string): AnimGraphNode_LayeredBoneBlend;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LayeredBoneBlend;
	static GetDefaultObject(): AnimGraphNode_LayeredBoneBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LayeredBoneBlend;
	static C(Other: UObject | any): AnimGraphNode_LayeredBoneBlend;
}

declare class AnimLegIKDefinition { 
	IKFootBone: BoneReference;
	FKFootBone: BoneReference;
	NumBonesInLimb: number;
	MinRotationAngle: number;
	FootBoneForwardAxis: EAxis;
	HingeRotationAxis: EAxis;
	bEnableRotationLimit: boolean;
	bEnableKneeTwistCorrection: boolean;
	clone() : AnimLegIKDefinition;
	static C(Other: UObject | any): AnimLegIKDefinition;
}

declare class AnimNode_LegIK extends AnimNode_SkeletalControlBase { 
	ReachPrecision: number;
	MaxIterations: number;
	LegsDefinition: AnimLegIKDefinition[];
	clone() : AnimNode_LegIK;
	static C(Other: UObject | any): AnimNode_LegIK;
}

declare class AnimGraphNode_LegIK extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_LegIK;
	static Load(ResourceName: string): AnimGraphNode_LegIK;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LegIK;
	static GetDefaultObject(): AnimGraphNode_LegIK;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LegIK;
	static C(Other: UObject | any): AnimGraphNode_LegIK;
}

declare class AnimGraphNode_LinkedAnimGraphBase extends AnimGraphNode_CustomProperty { 
	static Load(ResourceName: string): AnimGraphNode_LinkedAnimGraphBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LinkedAnimGraphBase;
	static GetDefaultObject(): AnimGraphNode_LinkedAnimGraphBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LinkedAnimGraphBase;
	static C(Other: UObject | any): AnimGraphNode_LinkedAnimGraphBase;
}

declare class AnimNode_CustomProperty extends AnimNode_Base { 
	SourcePropertyNames: string[];
	DestPropertyNames: string[];
	TargetInstance: UObject;
	clone() : AnimNode_CustomProperty;
	static C(Other: UObject | any): AnimNode_CustomProperty;
}

declare class AnimNode_LinkedAnimGraph extends AnimNode_CustomProperty { 
	InputPoses: PoseLink[];
	InputPoseNames: string[];
	InstanceClass: UnrealEngineClass;
	Tag: string;
	bReceiveNotifiesFromLinkedInstances: boolean;
	bPropagateNotifiesToLinkedInstances: boolean;
	clone() : AnimNode_LinkedAnimGraph;
	static C(Other: UObject | any): AnimNode_LinkedAnimGraph;
}

declare class AnimGraphNode_LinkedAnimGraph extends AnimGraphNode_LinkedAnimGraphBase { 
	UNode: AnimNode_LinkedAnimGraph;
	static Load(ResourceName: string): AnimGraphNode_LinkedAnimGraph;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LinkedAnimGraph;
	static GetDefaultObject(): AnimGraphNode_LinkedAnimGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LinkedAnimGraph;
	static C(Other: UObject | any): AnimGraphNode_LinkedAnimGraph;
}

declare class AnimLayerInterface extends Interface { 
	static Load(ResourceName: string): AnimLayerInterface;
	static Find(Outer: UObject, ResourceName: string): AnimLayerInterface;
	static GetDefaultObject(): AnimLayerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimLayerInterface;
	static C(Other: UObject | any): AnimLayerInterface;
}

declare class AnimNode_LinkedAnimLayer extends AnimNode_LinkedAnimGraph { 
	Interface: UnrealEngineClass;
	Layer: string;
	clone() : AnimNode_LinkedAnimLayer;
	static C(Other: UObject | any): AnimNode_LinkedAnimLayer;
}

declare class AnimGraphNode_LinkedAnimLayer extends AnimGraphNode_LinkedAnimGraphBase { 
	UNode: AnimNode_LinkedAnimLayer;
	InterfaceGuid: Guid;
	static Load(ResourceName: string): AnimGraphNode_LinkedAnimLayer;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LinkedAnimLayer;
	static GetDefaultObject(): AnimGraphNode_LinkedAnimLayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LinkedAnimLayer;
	static C(Other: UObject | any): AnimGraphNode_LinkedAnimLayer;
}

declare class AnimNode_LinkedInputPose extends AnimNode_Base { 
	Name: string;
	Graph: string;
	InputPose: PoseLink;
	clone() : AnimNode_LinkedInputPose;
	static C(Other: UObject | any): AnimNode_LinkedInputPose;
}

declare class AnimBlueprintFunctionPinInfo { 
	Name: string;
	Type: EdGraphPinType;
	clone() : AnimBlueprintFunctionPinInfo;
	static C(Other: UObject | any): AnimBlueprintFunctionPinInfo;
}

declare class AnimGraphNode_LinkedInputPose extends AnimGraphNode_Base { 
	UNode: AnimNode_LinkedInputPose;
	Inputs: AnimBlueprintFunctionPinInfo[];
	FunctionReference: MemberReference;
	InputPoseIndex: number;
	static Load(ResourceName: string): AnimGraphNode_LinkedInputPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LinkedInputPose;
	static GetDefaultObject(): AnimGraphNode_LinkedInputPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LinkedInputPose;
	static C(Other: UObject | any): AnimGraphNode_LinkedInputPose;
}

declare class AnimGraphNode_LocalRefPose extends AnimGraphNode_RefPoseBase { 
	static Load(ResourceName: string): AnimGraphNode_LocalRefPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LocalRefPose;
	static GetDefaultObject(): AnimGraphNode_LocalRefPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LocalRefPose;
	static C(Other: UObject | any): AnimGraphNode_LocalRefPose;
}

declare class AnimNode_ConvertLocalToComponentSpace extends AnimNode_Base { 
	LocalPose: PoseLink;
	clone() : AnimNode_ConvertLocalToComponentSpace;
	static C(Other: UObject | any): AnimNode_ConvertLocalToComponentSpace;
}

declare class AnimGraphNode_LocalToComponentSpace extends AnimGraphNode_Base { 
	UNode: AnimNode_ConvertLocalToComponentSpace;
	static Load(ResourceName: string): AnimGraphNode_LocalToComponentSpace;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LocalToComponentSpace;
	static GetDefaultObject(): AnimGraphNode_LocalToComponentSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LocalToComponentSpace;
	static C(Other: UObject | any): AnimGraphNode_LocalToComponentSpace;
}

declare class Axis { 
	Axis: Vector;
	bInLocalSpace: boolean;
	clone() : Axis;
	static C(Other: UObject | any): Axis;
}

declare type EInterpolationBlend = 'Linear' | 'Cubic' | 'Sinusoidal' | 'EaseInOutExponent2' | 'EaseInOutExponent3' | 'EaseInOutExponent4' | 'EaseInOutExponent5' | 'MAX';
declare var EInterpolationBlend : { Linear:'Linear',Cubic:'Cubic',Sinusoidal:'Sinusoidal',EaseInOutExponent2:'EaseInOutExponent2',EaseInOutExponent3:'EaseInOutExponent3',EaseInOutExponent4:'EaseInOutExponent4',EaseInOutExponent5:'EaseInOutExponent5',MAX:'MAX', };
declare type EAxisOption = 'X' | 'Y' | 'Z' | 'X_Neg' | 'Y_Neg' | 'Z_Neg' | 'Custom' | 'EAxisOption_MAX';
declare var EAxisOption : { X:'X',Y:'Y',Z:'Z',X_Neg:'X_Neg',Y_Neg:'Y_Neg',Z_Neg:'Z_Neg',Custom:'Custom',EAxisOption_MAX:'EAxisOption_MAX', };
declare class AnimNode_LookAt extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	LookAtTarget: BoneSocketTarget;
	LookAtLocation: Vector;
	LookAt_Axis: Axis;
	bUseLookUpAxis: boolean;
	InterpolationType: EInterpolationBlend;
	LookUp_Axis: Axis;
	LookAtClamp: number;
	InterpolationTime: number;
	InterpolationTriggerThreashold: number;
	LookAtBone: BoneReference;
	LookAtSocket: string;
	LookAtAxis: EAxisOption;
	CustomLookAtAxis: Vector;
	LookUpAxis: EAxisOption;
	CustomLookUpAxis: Vector;
	clone() : AnimNode_LookAt;
	static C(Other: UObject | any): AnimNode_LookAt;
}

declare class AnimGraphNode_LookAt extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_LookAt;
	static Load(ResourceName: string): AnimGraphNode_LookAt;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LookAt;
	static GetDefaultObject(): AnimGraphNode_LookAt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LookAt;
	static C(Other: UObject | any): AnimGraphNode_LookAt;
}

declare class AnimNode_MakeDynamicAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	bMeshSpaceAdditive: boolean;
	clone() : AnimNode_MakeDynamicAdditive;
	static C(Other: UObject | any): AnimNode_MakeDynamicAdditive;
}

declare class AnimGraphNode_MakeDynamicAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_MakeDynamicAdditive;
	static Load(ResourceName: string): AnimGraphNode_MakeDynamicAdditive;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_MakeDynamicAdditive;
	static GetDefaultObject(): AnimGraphNode_MakeDynamicAdditive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MakeDynamicAdditive;
	static C(Other: UObject | any): AnimGraphNode_MakeDynamicAdditive;
}

declare class AnimNode_MeshSpaceRefPose extends AnimNode_Base { 
	clone() : AnimNode_MeshSpaceRefPose;
	static C(Other: UObject | any): AnimNode_MeshSpaceRefPose;
}

declare class AnimGraphNode_MeshRefPose extends AnimGraphNode_Base { 
	UNode: AnimNode_MeshSpaceRefPose;
	static Load(ResourceName: string): AnimGraphNode_MeshRefPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_MeshRefPose;
	static GetDefaultObject(): AnimGraphNode_MeshRefPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MeshRefPose;
	static C(Other: UObject | any): AnimGraphNode_MeshRefPose;
}

declare class AnimNode_MirrorBase extends AnimNode_Base { 
	Source: PoseLink;
	clone() : AnimNode_MirrorBase;
	static C(Other: UObject | any): AnimNode_MirrorBase;
}

declare class AnimNode_Mirror extends AnimNode_MirrorBase { 
	bMirror: boolean;
	MirrorDataTable: MirrorDataTable;
	BlendTime: number;
	bResetChild: boolean;
	bBoneMirroring: boolean;
	bCurveMirroring: boolean;
	bAttributeMirroring: boolean;
	clone() : AnimNode_Mirror;
	static C(Other: UObject | any): AnimNode_Mirror;
}

declare class AnimGraphNode_Mirror extends AnimGraphNode_Base { 
	UNode: AnimNode_Mirror;
	static Load(ResourceName: string): AnimGraphNode_Mirror;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Mirror;
	static GetDefaultObject(): AnimGraphNode_Mirror;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Mirror;
	static C(Other: UObject | any): AnimGraphNode_Mirror;
}

declare type EBoneModificationMode = 'BMM_Ignore' | 'BMM_Replace' | 'BMM_Additive' | 'BMM_MAX';
declare var EBoneModificationMode : { BMM_Ignore:'BMM_Ignore',BMM_Replace:'BMM_Replace',BMM_Additive:'BMM_Additive',BMM_MAX:'BMM_MAX', };
declare class AnimNode_ModifyBone extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	Translation: Vector;
	Rotation: Rotator;
	Scale: Vector;
	TranslationMode: EBoneModificationMode;
	RotationMode: EBoneModificationMode;
	ScaleMode: EBoneModificationMode;
	TranslationSpace: EBoneControlSpace;
	RotationSpace: EBoneControlSpace;
	ScaleSpace: EBoneControlSpace;
	clone() : AnimNode_ModifyBone;
	static C(Other: UObject | any): AnimNode_ModifyBone;
}

declare class AnimGraphNode_ModifyBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ModifyBone;
	static Load(ResourceName: string): AnimGraphNode_ModifyBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ModifyBone;
	static GetDefaultObject(): AnimGraphNode_ModifyBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ModifyBone;
	static C(Other: UObject | any): AnimGraphNode_ModifyBone;
}

declare type EModifyCurveApplyMode = 'Add' | 'Scale' | 'Blend' | 'WeightedMovingAverage' | 'RemapCurve' | 'EModifyCurveApplyMode_MAX';
declare var EModifyCurveApplyMode : { Add:'Add',Scale:'Scale',Blend:'Blend',WeightedMovingAverage:'WeightedMovingAverage',RemapCurve:'RemapCurve',EModifyCurveApplyMode_MAX:'EModifyCurveApplyMode_MAX', };
declare class AnimNode_ModifyCurve extends AnimNode_Base { 
	SourcePose: PoseLink;
	CurveMap: any;
	CurveValues: number[];
	CurveNames: string[];
	Alpha: number;
	ApplyMode: EModifyCurveApplyMode;
	clone() : AnimNode_ModifyCurve;
	static C(Other: UObject | any): AnimNode_ModifyCurve;
}

declare class AnimGraphNode_ModifyCurve extends AnimGraphNode_Base { 
	UNode: AnimNode_ModifyCurve;
	static Load(ResourceName: string): AnimGraphNode_ModifyCurve;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ModifyCurve;
	static GetDefaultObject(): AnimGraphNode_ModifyCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ModifyCurve;
	static C(Other: UObject | any): AnimGraphNode_ModifyCurve;
}

declare class AnimNode_MultiWayBlend extends AnimNode_Base { 
	Poses: PoseLink[];
	DesiredAlphas: number[];
	AlphaScaleBias: InputScaleBias;
	bAdditiveNode: boolean;
	bNormalizeAlpha: boolean;
	clone() : AnimNode_MultiWayBlend;
	static C(Other: UObject | any): AnimNode_MultiWayBlend;
}

declare class AnimGraphNode_MultiWayBlend extends AnimGraphNode_Base { 
	UNode: AnimNode_MultiWayBlend;
	static Load(ResourceName: string): AnimGraphNode_MultiWayBlend;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_MultiWayBlend;
	static GetDefaultObject(): AnimGraphNode_MultiWayBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MultiWayBlend;
	static C(Other: UObject | any): AnimGraphNode_MultiWayBlend;
}

declare class AnimNode_ObserveBone extends AnimNode_SkeletalControlBase { 
	BoneToObserve: BoneReference;
	DisplaySpace: EBoneControlSpace;
	bRelativeToRefPose: boolean;
	Translation: Vector;
	Rotation: Rotator;
	Scale: Vector;
	clone() : AnimNode_ObserveBone;
	static C(Other: UObject | any): AnimNode_ObserveBone;
}

declare class AnimGraphNode_ObserveBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ObserveBone;
	static Load(ResourceName: string): AnimGraphNode_ObserveBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ObserveBone;
	static GetDefaultObject(): AnimGraphNode_ObserveBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ObserveBone;
	static C(Other: UObject | any): AnimGraphNode_ObserveBone;
}

declare class AnimGraphNode_PoseHandler extends AnimGraphNode_AssetPlayerBase { 
	static Load(ResourceName: string): AnimGraphNode_PoseHandler;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseHandler;
	static GetDefaultObject(): AnimGraphNode_PoseHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseHandler;
	static C(Other: UObject | any): AnimGraphNode_PoseHandler;
}

declare class AnimNode_PoseHandler extends AnimNode_AssetPlayerBase { 
	PoseAsset: PoseAsset;
	clone() : AnimNode_PoseHandler;
	static C(Other: UObject | any): AnimNode_PoseHandler;
}

declare class AnimNode_PoseBlendNode extends AnimNode_PoseHandler { 
	SourcePose: PoseLink;
	BlendOption: EAlphaBlendOption;
	CustomCurve: CurveFloat;
	clone() : AnimNode_PoseBlendNode;
	static C(Other: UObject | any): AnimNode_PoseBlendNode;
}

declare class AnimGraphNode_PoseBlendNode extends AnimGraphNode_PoseHandler { 
	UNode: AnimNode_PoseBlendNode;
	static Load(ResourceName: string): AnimGraphNode_PoseBlendNode;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseBlendNode;
	static GetDefaultObject(): AnimGraphNode_PoseBlendNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseBlendNode;
	static C(Other: UObject | any): AnimGraphNode_PoseBlendNode;
}

declare class AnimNode_PoseByName extends AnimNode_PoseHandler { 
	PoseName: string;
	PoseWeight: number;
	clone() : AnimNode_PoseByName;
	static C(Other: UObject | any): AnimNode_PoseByName;
}

declare class AnimGraphNode_PoseByName extends AnimGraphNode_AssetPlayerBase { 
	UNode: AnimNode_PoseByName;
	static Load(ResourceName: string): AnimGraphNode_PoseByName;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseByName;
	static GetDefaultObject(): AnimGraphNode_PoseByName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseByName;
	static C(Other: UObject | any): AnimGraphNode_PoseByName;
}

declare class PoseDriverTransform { 
	TargetTranslation: Vector;
	TargetRotation: Rotator;
	clone() : PoseDriverTransform;
	static C(Other: UObject | any): PoseDriverTransform;
}

declare type ERBFDistanceMethod = 'Euclidean' | 'Quaternion' | 'SwingAngle' | 'TwistAngle' | 'DefaultMethod' | 'ERBFDistanceMethod_MAX';
declare var ERBFDistanceMethod : { Euclidean:'Euclidean',Quaternion:'Quaternion',SwingAngle:'SwingAngle',TwistAngle:'TwistAngle',DefaultMethod:'DefaultMethod',ERBFDistanceMethod_MAX:'ERBFDistanceMethod_MAX', };
declare type ERBFFunctionType = 'Gaussian' | 'Exponential' | 'Linear' | 'Cubic' | 'Quintic' | 'DefaultFunction' | 'ERBFFunctionType_MAX';
declare var ERBFFunctionType : { Gaussian:'Gaussian',Exponential:'Exponential',Linear:'Linear',Cubic:'Cubic',Quintic:'Quintic',DefaultFunction:'DefaultFunction',ERBFFunctionType_MAX:'ERBFFunctionType_MAX', };
declare class PoseDriverTarget { 
	BoneTransforms: PoseDriverTransform[];
	TargetRotation: Rotator;
	TargetScale: number;
	DistanceMethod: ERBFDistanceMethod;
	FunctionType: ERBFFunctionType;
	bApplyCustomCurve: boolean;
	CustomCurve: RichCurve;
	DrivenName: string;
	bIsHidden: boolean;
	clone() : PoseDriverTarget;
	static C(Other: UObject | any): PoseDriverTarget;
}

declare type ERBFSolverType = 'Additive' | 'Interpolative' | 'ERBFSolverType_MAX';
declare var ERBFSolverType : { Additive:'Additive',Interpolative:'Interpolative',ERBFSolverType_MAX:'ERBFSolverType_MAX', };
declare type EBoneAxis = 'BA_X' | 'BA_Y' | 'BA_Z' | 'BA_MAX';
declare var EBoneAxis : { BA_X:'BA_X',BA_Y:'BA_Y',BA_Z:'BA_Z',BA_MAX:'BA_MAX', };
declare type ERBFNormalizeMethod = 'OnlyNormalizeAboveOne' | 'AlwaysNormalize' | 'NormalizeWithinMedian' | 'NoNormalization' | 'ERBFNormalizeMethod_MAX';
declare var ERBFNormalizeMethod : { OnlyNormalizeAboveOne:'OnlyNormalizeAboveOne',AlwaysNormalize:'AlwaysNormalize',NormalizeWithinMedian:'NormalizeWithinMedian',NoNormalization:'NoNormalization',ERBFNormalizeMethod_MAX:'ERBFNormalizeMethod_MAX', };
declare class RBFParams { 
	TargetDimensions: number;
	SolverType: ERBFSolverType;
	Radius: number;
	bAutomaticRadius: boolean;
	UFunction: ERBFFunctionType;
	DistanceMethod: ERBFDistanceMethod;
	TwistAxis: EBoneAxis;
	WeightThreshold: number;
	NormalizeMethod: ERBFNormalizeMethod;
	MedianReference: Vector;
	MedianMin: number;
	MedianMax: number;
	clone() : RBFParams;
	static C(Other: UObject | any): RBFParams;
}

declare type EPoseDriverType = 'SwingAndTwist' | 'SwingOnly' | 'Translation' | 'EPoseDriverType_MAX';
declare var EPoseDriverType : { SwingAndTwist:'SwingAndTwist',SwingOnly:'SwingOnly',Translation:'Translation',EPoseDriverType_MAX:'EPoseDriverType_MAX', };
declare type EPoseDriverSource = 'Rotation' | 'Translation' | 'EPoseDriverSource_MAX';
declare var EPoseDriverSource : { Rotation:'Rotation',Translation:'Translation',EPoseDriverSource_MAX:'EPoseDriverSource_MAX', };
declare type EPoseDriverOutput = 'DrivePoses' | 'DriveCurves' | 'EPoseDriverOutput_MAX';
declare var EPoseDriverOutput : { DrivePoses:'DrivePoses',DriveCurves:'DriveCurves',EPoseDriverOutput_MAX:'EPoseDriverOutput_MAX', };
declare class AnimNode_PoseDriver extends AnimNode_PoseHandler { 
	SourcePose: PoseLink;
	SourceBones: BoneReference[];
	OnlyDriveBones: BoneReference[];
	PoseTargets: PoseDriverTarget[];
	EvalSpaceBone: BoneReference;
	bEvalFromRefPose: boolean;
	RBFParams: RBFParams;
	SourceBone: BoneReference;
	TwistAxis: EBoneAxis;
	Type: EPoseDriverType;
	RadialScaling: number;
	DriveSource: EPoseDriverSource;
	DriveOutput: EPoseDriverOutput;
	bOnlyDriveSelectedBones: boolean;
	bSoloDrivenOnly: boolean;
	LODThreshold: number;
	clone() : AnimNode_PoseDriver;
	static C(Other: UObject | any): AnimNode_PoseDriver;
}

declare class AnimGraphNode_PoseDriver extends AnimGraphNode_PoseHandler { 
	UNode: AnimNode_PoseDriver;
	AxisLength: number;
	ConeSubdivision: number;
	bDrawDebugCones: boolean;
	LastPreviewComponent: SkeletalMeshComponent;
	static Load(ResourceName: string): AnimGraphNode_PoseDriver;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseDriver;
	static GetDefaultObject(): AnimGraphNode_PoseDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseDriver;
	SetSourceBones(BoneNames: string[]): void;
	SetRBFParameters(Parameters: RBFParams): void;
	SetPoseDriverSource(DriverSource: EPoseDriverSource): void;
	SetPoseDriverOutput(DriverOutput: EPoseDriverOutput): void;
	SetOnlyDriveSelectedBones(bOnlyDriveSelectedBones: boolean): void;
	SetDrivingBones(BoneNames: string[]): void;
	GetSourceBoneNames(BoneNames?: string[]): {BoneNames: string[]};
	GetRBFParameters(): RBFParams;
	GetPoseDriverSource(): EPoseDriverSource;
	GetPoseDriverOutput(): EPoseDriverOutput;
	GetOnlyDriveSelectedBones(): boolean;
	GetDrivingBoneNames(BoneNames?: string[]): {BoneNames: string[]};
	CopyTargetsFromPoseAsset(): void;
	static C(Other: UObject | any): AnimGraphNode_PoseDriver;
}

declare type ESnapshotSourceMode = 'NamedSnapshot' | 'SnapshotPin' | 'ESnapshotSourceMode_MAX';
declare var ESnapshotSourceMode : { NamedSnapshot:'NamedSnapshot',SnapshotPin:'SnapshotPin',ESnapshotSourceMode_MAX:'ESnapshotSourceMode_MAX', };
declare class AnimNode_PoseSnapshot extends AnimNode_Base { 
	SnapshotName: string;
	Snapshot: PoseSnapshot;
	Mode: ESnapshotSourceMode;
	clone() : AnimNode_PoseSnapshot;
	static C(Other: UObject | any): AnimNode_PoseSnapshot;
}

declare class AnimGraphNode_PoseSnapshot extends AnimGraphNode_Base { 
	UNode: AnimNode_PoseSnapshot;
	static Load(ResourceName: string): AnimGraphNode_PoseSnapshot;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseSnapshot;
	static GetDefaultObject(): AnimGraphNode_PoseSnapshot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseSnapshot;
	static C(Other: UObject | any): AnimGraphNode_PoseSnapshot;
}

declare class RandomPlayerSequenceEntry { 
	Sequence: AnimSequence;
	ChanceToPlay: number;
	MinLoopCount: number;
	MaxLoopCount: number;
	MinPlayRate: number;
	MaxPlayRate: number;
	BlendIn: AlphaBlend;
	clone() : RandomPlayerSequenceEntry;
	static C(Other: UObject | any): RandomPlayerSequenceEntry;
}

declare class AnimNode_RandomPlayer extends AnimNode_Base { 
	Entries: RandomPlayerSequenceEntry[];
	bShuffleMode: boolean;
	clone() : AnimNode_RandomPlayer;
	static C(Other: UObject | any): AnimNode_RandomPlayer;
}

declare class AnimGraphNode_RandomPlayer extends AnimGraphNode_Base { 
	UNode: AnimNode_RandomPlayer;
	static Load(ResourceName: string): AnimGraphNode_RandomPlayer;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RandomPlayer;
	static GetDefaultObject(): AnimGraphNode_RandomPlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RandomPlayer;
	static C(Other: UObject | any): AnimGraphNode_RandomPlayer;
}

declare class AnimNode_ResetRoot extends AnimNode_SkeletalControlBase { 
	clone() : AnimNode_ResetRoot;
	static C(Other: UObject | any): AnimNode_ResetRoot;
}

declare class AnimGraphNode_ResetRoot extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ResetRoot;
	static Load(ResourceName: string): AnimGraphNode_ResetRoot;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ResetRoot;
	static GetDefaultObject(): AnimGraphNode_ResetRoot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ResetRoot;
	static C(Other: UObject | any): AnimGraphNode_ResetRoot;
}

declare class SimSpaceSettings { 
	MasterAlpha: number;
	VelocityScaleZ: number;
	MaxLinearVelocity: number;
	MaxAngularVelocity: number;
	MaxLinearAcceleration: number;
	MaxAngularAcceleration: number;
	ExternalLinearDrag: number;
	ExternalLinearDragV: Vector;
	ExternalLinearVelocity: Vector;
	ExternalAngularVelocity: Vector;
	clone() : SimSpaceSettings;
	static C(Other: UObject | any): SimSpaceSettings;
}

declare type ESimulationSpace = 'ComponentSpace' | 'WorldSpace' | 'BaseBoneSpace' | 'ESimulationSpace_MAX';
declare var ESimulationSpace : { ComponentSpace:'ComponentSpace',WorldSpace:'WorldSpace',BaseBoneSpace:'BaseBoneSpace',ESimulationSpace_MAX:'ESimulationSpace_MAX', };
declare class AnimNode_RigidBody extends AnimNode_SkeletalControlBase { 
	OverridePhysicsAsset: PhysicsAsset;
	OverrideWorldGravity: Vector;
	ExternalForce: Vector;
	ComponentLinearAccScale: Vector;
	ComponentLinearVelScale: Vector;
	ComponentAppliedLinearAccClamp: Vector;
	SimSpaceSettings: SimSpaceSettings;
	CachedBoundsScale: number;
	BaseBoneRef: BoneReference;
	OverlapChannel: ECollisionChannel;
	SimulationSpace: ESimulationSpace;
	bForceDisableCollisionBetweenConstraintBodies: boolean;
	bEnableWorldGeometry: boolean;
	bOverrideWorldGravity: boolean;
	bTransferBoneVelocities: boolean;
	bFreezeIncomingPoseOnStart: boolean;
	bClampLinearTranslationLimitToRefPose: boolean;
	WorldSpaceMinimumScale: number;
	EvaluationResetTime: number;
	bComponentSpaceSimulation: boolean;
	clone() : AnimNode_RigidBody;
	static C(Other: UObject | any): AnimNode_RigidBody;
}

declare class AnimGraphNode_RigidBody extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_RigidBody;
	static Load(ResourceName: string): AnimGraphNode_RigidBody;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RigidBody;
	static GetDefaultObject(): AnimGraphNode_RigidBody;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RigidBody;
	static C(Other: UObject | any): AnimGraphNode_RigidBody;
}

declare class AnimGraphNode_Root extends AnimGraphNode_Base { 
	UNode: AnimNode_Root;
	static Load(ResourceName: string): AnimGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Root;
	static GetDefaultObject(): AnimGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Root;
	static C(Other: UObject | any): AnimGraphNode_Root;
}

declare class AnimNode_RotateRootBone extends AnimNode_Base { 
	BasePose: PoseLink;
	Pitch: number;
	Yaw: number;
	PitchScaleBiasClamp: InputScaleBiasClamp;
	YawScaleBiasClamp: InputScaleBiasClamp;
	MeshToComponent: Rotator;
	clone() : AnimNode_RotateRootBone;
	static C(Other: UObject | any): AnimNode_RotateRootBone;
}

declare class AnimGraphNode_RotateRootBone extends AnimGraphNode_Base { 
	UNode: AnimNode_RotateRootBone;
	static Load(ResourceName: string): AnimGraphNode_RotateRootBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RotateRootBone;
	static GetDefaultObject(): AnimGraphNode_RotateRootBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotateRootBone;
	static C(Other: UObject | any): AnimGraphNode_RotateRootBone;
}

declare class AnimNode_RotationMultiplier extends AnimNode_SkeletalControlBase { 
	TargetBone: BoneReference;
	SourceBone: BoneReference;
	Multiplier: number;
	RotationAxisToRefer: EBoneAxis;
	bIsAdditive: boolean;
	clone() : AnimNode_RotationMultiplier;
	static C(Other: UObject | any): AnimNode_RotationMultiplier;
}

declare class AnimGraphNode_RotationMultiplier extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_RotationMultiplier;
	static Load(ResourceName: string): AnimGraphNode_RotationMultiplier;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RotationMultiplier;
	static GetDefaultObject(): AnimGraphNode_RotationMultiplier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotationMultiplier;
	static C(Other: UObject | any): AnimGraphNode_RotationMultiplier;
}

declare class AnimNode_RotationOffsetBlendSpace extends AnimNode_BlendSpacePlayer { 
	BasePose: PoseLink;
	LODThreshold: number;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	clone() : AnimNode_RotationOffsetBlendSpace;
	static C(Other: UObject | any): AnimNode_RotationOffsetBlendSpace;
}

declare class AnimGraphNode_RotationOffsetBlendSpace extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_RotationOffsetBlendSpace;
	static Load(ResourceName: string): AnimGraphNode_RotationOffsetBlendSpace;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RotationOffsetBlendSpace;
	static GetDefaultObject(): AnimGraphNode_RotationOffsetBlendSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotationOffsetBlendSpace;
	static C(Other: UObject | any): AnimGraphNode_RotationOffsetBlendSpace;
}

declare class AnimNode_RotationOffsetBlendSpaceGraph extends AnimNode_BlendSpaceGraphBase { 
	BasePose: PoseLink;
	LODThreshold: number;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	clone() : AnimNode_RotationOffsetBlendSpaceGraph;
	static C(Other: UObject | any): AnimNode_RotationOffsetBlendSpaceGraph;
}

declare class AnimGraphNode_RotationOffsetBlendSpaceGraph extends AnimGraphNode_BlendSpaceGraphBase { 
	UNode: AnimNode_RotationOffsetBlendSpaceGraph;
	static Load(ResourceName: string): AnimGraphNode_RotationOffsetBlendSpaceGraph;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RotationOffsetBlendSpaceGraph;
	static GetDefaultObject(): AnimGraphNode_RotationOffsetBlendSpaceGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotationOffsetBlendSpaceGraph;
	static C(Other: UObject | any): AnimGraphNode_RotationOffsetBlendSpaceGraph;
}

declare class AnimNode_SaveCachedPose extends AnimNode_Base { 
	Pose: PoseLink;
	CachePoseName: string;
	clone() : AnimNode_SaveCachedPose;
	static C(Other: UObject | any): AnimNode_SaveCachedPose;
}

declare class AnimGraphNode_SaveCachedPose extends AnimGraphNode_Base { 
	UNode: AnimNode_SaveCachedPose;
	CacheName: string;
	static Load(ResourceName: string): AnimGraphNode_SaveCachedPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SaveCachedPose;
	static GetDefaultObject(): AnimGraphNode_SaveCachedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SaveCachedPose;
	static C(Other: UObject | any): AnimGraphNode_SaveCachedPose;
}

declare type EScaleChainInitialLength = 'FixedDefaultLengthValue' | 'Distance' | 'ChainLength' | 'EScaleChainInitialLength_MAX';
declare var EScaleChainInitialLength : { FixedDefaultLengthValue:'FixedDefaultLengthValue',Distance:'Distance',ChainLength:'ChainLength',EScaleChainInitialLength_MAX:'EScaleChainInitialLength_MAX', };
declare class AnimNode_ScaleChainLength extends AnimNode_Base { 
	InputPose: PoseLink;
	DefaultChainLength: number;
	ChainStartBone: BoneReference;
	ChainEndBone: BoneReference;
	TargetLocation: Vector;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	ChainInitialLength: EScaleChainInitialLength;
	clone() : AnimNode_ScaleChainLength;
	static C(Other: UObject | any): AnimNode_ScaleChainLength;
}

declare class AnimGraphNode_ScaleChainLength extends AnimGraphNode_Base { 
	UNode: AnimNode_ScaleChainLength;
	static Load(ResourceName: string): AnimGraphNode_ScaleChainLength;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ScaleChainLength;
	static GetDefaultObject(): AnimGraphNode_ScaleChainLength;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ScaleChainLength;
	static C(Other: UObject | any): AnimGraphNode_ScaleChainLength;
}

declare class AnimNode_SequenceEvaluatorBase extends AnimNode_AssetPlayerBase { 
	clone() : AnimNode_SequenceEvaluatorBase;
	static C(Other: UObject | any): AnimNode_SequenceEvaluatorBase;
}

declare type ESequenceEvalReinit = 'NoReset' | 'StartPosition' | 'ExplicitTime' | 'ESequenceEvalReinit_MAX';
declare var ESequenceEvalReinit : { NoReset:'NoReset',StartPosition:'StartPosition',ExplicitTime:'ExplicitTime',ESequenceEvalReinit_MAX:'ESequenceEvalReinit_MAX', };
declare class AnimNode_SequenceEvaluator extends AnimNode_SequenceEvaluatorBase { 
	GroupName: string;
	GroupRole: EAnimGroupRole;
	Method: EAnimSyncMethod;
	bIgnoreForRelevancyTest: boolean;
	Sequence: AnimSequenceBase;
	ExplicitTime: number;
	bShouldLoop: boolean;
	bTeleportToExplicitTime: boolean;
	ReinitializationBehavior: ESequenceEvalReinit;
	StartPosition: number;
	clone() : AnimNode_SequenceEvaluator;
	static C(Other: UObject | any): AnimNode_SequenceEvaluator;
}

declare class AnimGraphNode_SequenceEvaluator extends AnimGraphNode_AssetPlayerBase { 
	UNode: AnimNode_SequenceEvaluator;
	static Load(ResourceName: string): AnimGraphNode_SequenceEvaluator;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SequenceEvaluator;
	static GetDefaultObject(): AnimGraphNode_SequenceEvaluator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SequenceEvaluator;
	static C(Other: UObject | any): AnimGraphNode_SequenceEvaluator;
}

declare class InputScaleBiasClampState { 
	clone() : InputScaleBiasClampState;
	static C(Other: UObject | any): InputScaleBiasClampState;
}

declare class AnimNode_SequencePlayerBase extends AnimNode_AssetPlayerBase { 
	PlayRateScaleBiasClampState: InputScaleBiasClampState;
	clone() : AnimNode_SequencePlayerBase;
	static C(Other: UObject | any): AnimNode_SequencePlayerBase;
}

declare class InputScaleBiasClampConstants { 
	bMapRange: boolean;
	bClampResult: boolean;
	bInterpResult: boolean;
	InRange: InputRange;
	OutRange: InputRange;
	Scale: number;
	Bias: number;
	ClampMin: number;
	ClampMax: number;
	InterpSpeedIncreasing: number;
	InterpSpeedDecreasing: number;
	clone() : InputScaleBiasClampConstants;
	static C(Other: UObject | any): InputScaleBiasClampConstants;
}

declare class AnimNode_SequencePlayer extends AnimNode_SequencePlayerBase { 
	GroupName: string;
	GroupRole: EAnimGroupRole;
	Method: EAnimSyncMethod;
	bIgnoreForRelevancyTest: boolean;
	Sequence: AnimSequenceBase;
	PlayRateBasis: number;
	PlayRate: number;
	PlayRateScaleBiasClampConstants: InputScaleBiasClampConstants;
	PlayRateScaleBiasClamp: InputScaleBiasClamp;
	StartPosition: number;
	bLoopAnimation: boolean;
	bStartFromMatchingPose: boolean;
	clone() : AnimNode_SequencePlayer;
	static C(Other: UObject | any): AnimNode_SequencePlayer;
}

declare class AnimGraphNode_SequencePlayer extends AnimGraphNode_AssetPlayerBase { 
	UNode: AnimNode_SequencePlayer;
	static Load(ResourceName: string): AnimGraphNode_SequencePlayer;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SequencePlayer;
	static GetDefaultObject(): AnimGraphNode_SequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SequencePlayer;
	static C(Other: UObject | any): AnimGraphNode_SequencePlayer;
}

declare class AnimNode_Slot extends AnimNode_Base { 
	Source: PoseLink;
	SlotName: string;
	bAlwaysUpdateSourcePose: boolean;
	clone() : AnimNode_Slot;
	static C(Other: UObject | any): AnimNode_Slot;
}

declare class AnimGraphNode_Slot extends AnimGraphNode_Base { 
	UNode: AnimNode_Slot;
	static Load(ResourceName: string): AnimGraphNode_Slot;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Slot;
	static GetDefaultObject(): AnimGraphNode_Slot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Slot;
	static C(Other: UObject | any): AnimGraphNode_Slot;
}

declare type ESplineBoneAxis = 'None' | 'X' | 'Y' | 'Z' | 'ESplineBoneAxis_MAX';
declare var ESplineBoneAxis : { None:'None',X:'X',Y:'Y',Z:'Z',ESplineBoneAxis_MAX:'ESplineBoneAxis_MAX', };
declare class AnimNode_SplineIK extends AnimNode_SkeletalControlBase { 
	StartBone: BoneReference;
	EndBone: BoneReference;
	BoneAxis: ESplineBoneAxis;
	bAutoCalculateSpline: boolean;
	PointCount: number;
	ControlPoints: Transform[];
	Roll: number;
	TwistStart: number;
	TwistEnd: number;
	TwistBlend: AlphaBlend;
	Stretch: number;
	Offset: number;
	clone() : AnimNode_SplineIK;
	static C(Other: UObject | any): AnimNode_SplineIK;
}

declare class AnimGraphNode_SplineIK extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_SplineIK;
	static Load(ResourceName: string): AnimGraphNode_SplineIK;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SplineIK;
	static GetDefaultObject(): AnimGraphNode_SplineIK;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SplineIK;
	static C(Other: UObject | any): AnimGraphNode_SplineIK;
}

declare class AnimNode_SpringBone extends AnimNode_SkeletalControlBase { 
	SpringBone: BoneReference;
	MaxDisplacement: number;
	SpringStiffness: number;
	SpringDamping: number;
	ErrorResetThresh: number;
	bNoZSpring: boolean;
	bLimitDisplacement: boolean;
	bTranslateX: boolean;
	bTranslateY: boolean;
	bTranslateZ: boolean;
	bRotateX: boolean;
	bRotateY: boolean;
	bRotateZ: boolean;
	clone() : AnimNode_SpringBone;
	static C(Other: UObject | any): AnimNode_SpringBone;
}

declare class AnimGraphNode_SpringBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_SpringBone;
	static Load(ResourceName: string): AnimGraphNode_SpringBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SpringBone;
	static GetDefaultObject(): AnimGraphNode_SpringBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SpringBone;
	static C(Other: UObject | any): AnimGraphNode_SpringBone;
}

declare class AnimNode_StateMachine extends AnimNode_Base { 
	StateMachineIndexInClass: number;
	MaxTransitionsPerFrame: number;
	bSkipFirstUpdateTransition: boolean;
	bReinitializeOnBecomingRelevant: boolean;
	bCreateNotifyMetaData: boolean;
	bAllowConduitEntryStates: boolean;
	clone() : AnimNode_StateMachine;
	static C(Other: UObject | any): AnimNode_StateMachine;
}

declare class AnimGraphNode_StateMachine extends AnimGraphNode_StateMachineBase { 
	UNode: AnimNode_StateMachine;
	static Load(ResourceName: string): AnimGraphNode_StateMachine;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateMachine;
	static GetDefaultObject(): AnimGraphNode_StateMachine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateMachine;
	static C(Other: UObject | any): AnimGraphNode_StateMachine;
}

declare class AnimNode_Sync extends AnimNode_Base { 
	Source: PoseLink;
	GroupName: string;
	GroupRole: EAnimGroupRole;
	clone() : AnimNode_Sync;
	static C(Other: UObject | any): AnimNode_Sync;
}

declare class AnimGraphNode_Sync extends AnimGraphNode_Base { 
	UNode: AnimNode_Sync;
	static Load(ResourceName: string): AnimGraphNode_Sync;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Sync;
	static GetDefaultObject(): AnimGraphNode_Sync;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Sync;
	static C(Other: UObject | any): AnimGraphNode_Sync;
}

declare class RotationLimit { 
	LimitMin: Vector;
	LimitMax: Vector;
	clone() : RotationLimit;
	static C(Other: UObject | any): RotationLimit;
}

declare class AnimNode_Trail extends AnimNode_SkeletalControlBase { 
	TrailBone: BoneReference;
	ChainLength: number;
	ChainBoneAxis: EAxis;
	bInvertChainBoneAxis: boolean;
	bLimitStretch: boolean;
	bLimitRotation: boolean;
	bUsePlanarLimit: boolean;
	bActorSpaceFakeVel: boolean;
	bReorientParentToChild: boolean;
	bEnableDebug: boolean;
	bShowBaseMotion: boolean;
	bShowTrailLocation: boolean;
	bShowLimit: boolean;
	DebugLifeTime: number;
	TrailRelaxation: number;
	MaxDeltaTime: number;
	RelaxationSpeedScale: number;
	TrailRelaxationSpeed: RuntimeFloatCurve;
	RelaxationSpeedScaleInputProcessor: InputScaleBiasClamp;
	RotationLimits: RotationLimit[];
	RotationOffsets: Vector[];
	PlanarLimits: AnimPhysPlanarLimit[];
	StretchLimit: number;
	FakeVelocity: Vector;
	BaseJoint: BoneReference;
	TrailBoneRotationBlendAlpha: number;
	LastBoneRotationAnimAlphaBlend: number;
	clone() : AnimNode_Trail;
	static C(Other: UObject | any): AnimNode_Trail;
}

declare class AnimGraphNode_Trail extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Trail;
	static Load(ResourceName: string): AnimGraphNode_Trail;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Trail;
	static GetDefaultObject(): AnimGraphNode_Trail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Trail;
	static C(Other: UObject | any): AnimGraphNode_Trail;
}

declare type EEvaluatorDataSource = 'EDS_SourcePose' | 'EDS_DestinationPose' | 'EDS_MAX';
declare var EEvaluatorDataSource : { EDS_SourcePose:'EDS_SourcePose',EDS_DestinationPose:'EDS_DestinationPose',EDS_MAX:'EDS_MAX', };
declare type EEvaluatorMode = 'EM_Standard' | 'EM_Freeze' | 'EM_DelayedFreeze' | 'EM_MAX';
declare var EEvaluatorMode : { EM_Standard:'EM_Standard',EM_Freeze:'EM_Freeze',EM_DelayedFreeze:'EM_DelayedFreeze',EM_MAX:'EM_MAX', };
declare class AnimNode_TransitionPoseEvaluator extends AnimNode_Base { 
	FramesToCachePose: number;
	DataSource: EEvaluatorDataSource;
	EvaluatorMode: EEvaluatorMode;
	clone() : AnimNode_TransitionPoseEvaluator;
	static C(Other: UObject | any): AnimNode_TransitionPoseEvaluator;
}

declare class AnimGraphNode_TransitionPoseEvaluator extends AnimGraphNode_Base { 
	UNode: AnimNode_TransitionPoseEvaluator;
	static Load(ResourceName: string): AnimGraphNode_TransitionPoseEvaluator;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TransitionPoseEvaluator;
	static GetDefaultObject(): AnimGraphNode_TransitionPoseEvaluator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TransitionPoseEvaluator;
	static C(Other: UObject | any): AnimGraphNode_TransitionPoseEvaluator;
}

declare class ReferenceBoneFrame { 
	bone: BoneReference;
	Axis: Axis;
	clone() : ReferenceBoneFrame;
	static C(Other: UObject | any): ReferenceBoneFrame;
}

declare class AnimCurveParam { 
	Name: string;
	clone() : AnimCurveParam;
	static C(Other: UObject | any): AnimCurveParam;
}

declare class AnimNode_TwistCorrectiveNode extends AnimNode_SkeletalControlBase { 
	BaseFrame: ReferenceBoneFrame;
	TwistFrame: ReferenceBoneFrame;
	TwistPlaneNormalAxis: Axis;
	RangeMax: number;
	RemappedMin: number;
	RemappedMax: number;
	Curve: AnimCurveParam;
	clone() : AnimNode_TwistCorrectiveNode;
	static C(Other: UObject | any): AnimNode_TwistCorrectiveNode;
}

declare class AnimGraphNode_TwistCorrectiveNode extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_TwistCorrectiveNode;
	static Load(ResourceName: string): AnimGraphNode_TwistCorrectiveNode;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TwistCorrectiveNode;
	static GetDefaultObject(): AnimGraphNode_TwistCorrectiveNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TwistCorrectiveNode;
	static C(Other: UObject | any): AnimGraphNode_TwistCorrectiveNode;
}

declare class AnimNode_TwoBoneIK extends AnimNode_SkeletalControlBase { 
	IKBone: BoneReference;
	StartStretchRatio: number;
	MaxStretchScale: number;
	StretchLimits: Vector2D;
	bNoTwist: boolean;
	JointTargetSpaceBoneName: string;
	EffectorSpaceBoneName: string;
	EffectorLocation: Vector;
	EffectorTarget: BoneSocketTarget;
	JointTargetLocation: Vector;
	JointTarget: BoneSocketTarget;
	TwistAxis: Axis;
	EffectorLocationSpace: EBoneControlSpace;
	JointTargetLocationSpace: EBoneControlSpace;
	bAllowStretching: boolean;
	bTakeRotationFromEffectorSpace: boolean;
	bMaintainEffectorRelRot: boolean;
	bAllowTwist: boolean;
	clone() : AnimNode_TwoBoneIK;
	static C(Other: UObject | any): AnimNode_TwoBoneIK;
}

declare class AnimGraphNode_TwoBoneIK extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_TwoBoneIK;
	bEnableDebugDraw: boolean;
	static Load(ResourceName: string): AnimGraphNode_TwoBoneIK;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TwoBoneIK;
	static GetDefaultObject(): AnimGraphNode_TwoBoneIK;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TwoBoneIK;
	static C(Other: UObject | any): AnimGraphNode_TwoBoneIK;
}

declare class AnimNode_TwoWayBlend extends AnimNode_Base { 
	A: PoseLink;
	B: PoseLink;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	bResetChildOnActivation: boolean;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	clone() : AnimNode_TwoWayBlend;
	static C(Other: UObject | any): AnimNode_TwoWayBlend;
}

declare class AnimGraphNode_TwoWayBlend extends AnimGraphNode_Base { 
	BlendNode: AnimNode_TwoWayBlend;
	static Load(ResourceName: string): AnimGraphNode_TwoWayBlend;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TwoWayBlend;
	static GetDefaultObject(): AnimGraphNode_TwoWayBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TwoWayBlend;
	static C(Other: UObject | any): AnimGraphNode_TwoWayBlend;
}

declare class AnimNode_UseCachedPose extends AnimNode_Base { 
	LinkToCachingNode: PoseLink;
	CachePoseName: string;
	clone() : AnimNode_UseCachedPose;
	static C(Other: UObject | any): AnimNode_UseCachedPose;
}

declare class AnimGraphNode_UseCachedPose extends AnimGraphNode_Base { 
	UNode: AnimNode_UseCachedPose;
	SaveCachedPoseNode: any;
	NameOfCache: string;
	static Load(ResourceName: string): AnimGraphNode_UseCachedPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_UseCachedPose;
	static GetDefaultObject(): AnimGraphNode_UseCachedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_UseCachedPose;
	static C(Other: UObject | any): AnimGraphNode_UseCachedPose;
}

declare class AnimPreviewAttacheInstance extends AnimInstance { 
	static Load(ResourceName: string): AnimPreviewAttacheInstance;
	static Find(Outer: UObject, ResourceName: string): AnimPreviewAttacheInstance;
	static GetDefaultObject(): AnimPreviewAttacheInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimPreviewAttacheInstance;
	static C(Other: UObject | any): AnimPreviewAttacheInstance;
}

declare class AnimSingleNodeInstance extends AnimInstance { 
	CurrentAsset: AnimationAsset;
	PostEvaluateAnimEvent: UnrealEngineDelegate<() => void>;
	static Load(ResourceName: string): AnimSingleNodeInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSingleNodeInstance;
	static GetDefaultObject(): AnimSingleNodeInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSingleNodeInstance;
	StopAnim(): void;
	SetReverse(bInReverse: boolean): void;
	SetPreviewCurveOverride(PoseName: string,Value: number,bRemoveIfZero: boolean): void;
	SetPositionWithPreviousTime(InPosition: number,InPreviousTime: number,bFireNotifies: boolean): void;
	SetPosition(InPosition: number,bFireNotifies: boolean): void;
	SetPlayRate(InPlayRate: number): void;
	SetPlaying(bIsPlaying: boolean): void;
	SetMirrorDataTable(MirrorDataTable: MirrorDataTable): void;
	SetLooping(bIsLooping: boolean): void;
	SetBlendSpacePosition(InPosition: Vector): void;
	SetAnimationAsset(NewAsset: AnimationAsset,bIsLooping: boolean,InPlayRate: number): void;
	PlayAnim(bIsLooping: boolean,InPlayRate: number,InStartPosition: number): void;
	GetMirrorDataTable(): MirrorDataTable;
	GetLength(): number;
	GetAnimationAsset(): AnimationAsset;
	static C(Other: UObject | any): AnimSingleNodeInstance;
}

declare type EMontagePreviewType = 'EMPT_Normal' | 'EMPT_AllSections' | 'EMPT_MAX';
declare var EMontagePreviewType : { EMPT_Normal:'EMPT_Normal',EMPT_AllSections:'EMPT_AllSections',EMPT_MAX:'EMPT_MAX', };
declare class AnimPreviewInstance extends AnimSingleNodeInstance { 
	MontagePreviewType: EMontagePreviewType;
	MontagePreviewStartSectionIdx: number;
	static Load(ResourceName: string): AnimPreviewInstance;
	static Find(Outer: UObject, ResourceName: string): AnimPreviewInstance;
	static GetDefaultObject(): AnimPreviewInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimPreviewInstance;
	static C(Other: UObject | any): AnimPreviewInstance;
}

declare class AnimStateNodeBase extends EdGraphNode { 
	static Load(ResourceName: string): AnimStateNodeBase;
	static Find(Outer: UObject, ResourceName: string): AnimStateNodeBase;
	static GetDefaultObject(): AnimStateNodeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateNodeBase;
	static C(Other: UObject | any): AnimStateNodeBase;
}

declare class AnimStateAliasNode extends AnimStateNodeBase { 
	bGlobalAlias: boolean;
	StateAliasName: string;
	AliasedStateNodes: any;
	static Load(ResourceName: string): AnimStateAliasNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateAliasNode;
	static GetDefaultObject(): AnimStateAliasNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateAliasNode;
	static C(Other: UObject | any): AnimStateAliasNode;
}

declare class AnimStateConduitNode extends AnimStateNodeBase { 
	BoundGraph: EdGraph;
	static Load(ResourceName: string): AnimStateConduitNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateConduitNode;
	static GetDefaultObject(): AnimStateConduitNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateConduitNode;
	static C(Other: UObject | any): AnimStateConduitNode;
}

declare type EAnimStateType = 'AST_SingleAnimation' | 'AST_BlendGraph' | 'AST_MAX';
declare var EAnimStateType : { AST_SingleAnimation:'AST_SingleAnimation',AST_BlendGraph:'AST_BlendGraph',AST_MAX:'AST_MAX', };
declare class AnimStateNode extends AnimStateNodeBase { 
	BoundGraph: EdGraph;
	StateType: EAnimStateType;
	StateEntered: AnimNotifyEvent;
	StateLeft: AnimNotifyEvent;
	StateFullyBlended: AnimNotifyEvent;
	bAlwaysResetOnEntry: boolean;
	static Load(ResourceName: string): AnimStateNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateNode;
	static GetDefaultObject(): AnimStateNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateNode;
	static C(Other: UObject | any): AnimStateNode;
}

declare type ETransitionBlendMode = 'TBM_Linear' | 'TBM_Cubic' | 'TBM_MAX';
declare var ETransitionBlendMode : { TBM_Linear:'TBM_Linear',TBM_Cubic:'TBM_Cubic',TBM_MAX:'TBM_MAX', };
declare type ETransitionLogicType = 'TLT_StandardBlend' | 'TLT_Inertialization' | 'TLT_Custom' | 'TLT_MAX';
declare var ETransitionLogicType : { TLT_StandardBlend:'TLT_StandardBlend',TLT_Inertialization:'TLT_Inertialization',TLT_Custom:'TLT_Custom',TLT_MAX:'TLT_MAX', };
declare class AnimStateTransitionNode extends AnimStateNodeBase { 
	BoundGraph: EdGraph;
	CustomTransitionGraph: EdGraph;
	PriorityOrder: number;
	CrossfadeDuration: number;
	CrossfadeMode: ETransitionBlendMode;
	BlendMode: EAlphaBlendOption;
	CustomBlendCurve: CurveFloat;
	BlendProfile: BlendProfile;
	bAutomaticRuleBasedOnSequencePlayerInState: boolean;
	SyncGroupNameToRequireValidMarkersRule: string;
	LogicType: ETransitionLogicType;
	TransitionStart: AnimNotifyEvent;
	TransitionEnd: AnimNotifyEvent;
	TransitionInterrupt: AnimNotifyEvent;
	Bidirectional: boolean;
	bSharedRules: boolean;
	bSharedCrossfade: boolean;
	SharedRulesName: string;
	SharedRulesGuid: Guid;
	SharedColor: LinearColor;
	SharedCrossfadeName: string;
	SharedCrossfadeGuid: Guid;
	SharedCrossfadeIdx: number;
	static Load(ResourceName: string): AnimStateTransitionNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateTransitionNode;
	static GetDefaultObject(): AnimStateTransitionNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateTransitionNode;
	static C(Other: UObject | any): AnimStateTransitionNode;
}

declare class ClassVariableCreator extends Interface { 
	static Load(ResourceName: string): ClassVariableCreator;
	static Find(Outer: UObject, ResourceName: string): ClassVariableCreator;
	static GetDefaultObject(): ClassVariableCreator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassVariableCreator;
	static C(Other: UObject | any): ClassVariableCreator;
}

declare class K2Node_AnimGetter extends K2Node_CallFunction { 
	SourceNode: AnimGraphNode_Base;
	SourceStateNode: AnimStateNodeBase;
	GetterClass: UnrealEngineClass;
	SourceAnimBlueprint: AnimBlueprint;
	CachedTitle: string;
	Contexts: string[];
	static Load(ResourceName: string): K2Node_AnimGetter;
	static Find(Outer: UObject, ResourceName: string): K2Node_AnimGetter;
	static GetDefaultObject(): K2Node_AnimGetter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AnimGetter;
	static C(Other: UObject | any): K2Node_AnimGetter;
}

declare class K2Node_AnimNodeReference extends K2Node { 
	Tag: string;
	static Load(ResourceName: string): K2Node_AnimNodeReference;
	static Find(Outer: UObject, ResourceName: string): K2Node_AnimNodeReference;
	static GetDefaultObject(): K2Node_AnimNodeReference;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AnimNodeReference;
	static C(Other: UObject | any): K2Node_AnimNodeReference;
}

declare class K2Node_BaseAsyncTask extends K2Node { 
	ProxyFactoryFunctionName: string;
	ProxyFactoryClass: UnrealEngineClass;
	ProxyClass: UnrealEngineClass;
	ProxyActivateFunctionName: string;
	static Load(ResourceName: string): K2Node_BaseAsyncTask;
	static Find(Outer: UObject, ResourceName: string): K2Node_BaseAsyncTask;
	static GetDefaultObject(): K2Node_BaseAsyncTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseAsyncTask;
	static C(Other: UObject | any): K2Node_BaseAsyncTask;
}

declare class K2Node_PlayMontage extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_PlayMontage;
	static Find(Outer: UObject, ResourceName: string): K2Node_PlayMontage;
	static GetDefaultObject(): K2Node_PlayMontage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PlayMontage;
	static C(Other: UObject | any): K2Node_PlayMontage;
}

declare type ETransitionGetter = 'AnimationAsset_GetCurrentTime' | 'AnimationAsset_GetLength' | 'AnimationAsset_GetCurrentTimeFraction' | 'AnimationAsset_GetTimeFromEnd' | 'AnimationAsset_GetTimeFromEndFraction' | 'CurrentState_ElapsedTime' | 'CurrentState_GetBlendWeight' | 'CurrentTransitionDuration' | 'ArbitraryState_GetBlendWeight' | 'ETransitionGetter_MAX';
declare var ETransitionGetter : { AnimationAsset_GetCurrentTime:'AnimationAsset_GetCurrentTime',AnimationAsset_GetLength:'AnimationAsset_GetLength',AnimationAsset_GetCurrentTimeFraction:'AnimationAsset_GetCurrentTimeFraction',AnimationAsset_GetTimeFromEnd:'AnimationAsset_GetTimeFromEnd',AnimationAsset_GetTimeFromEndFraction:'AnimationAsset_GetTimeFromEndFraction',CurrentState_ElapsedTime:'CurrentState_ElapsedTime',CurrentState_GetBlendWeight:'CurrentState_GetBlendWeight',CurrentTransitionDuration:'CurrentTransitionDuration',ArbitraryState_GetBlendWeight:'ArbitraryState_GetBlendWeight',ETransitionGetter_MAX:'ETransitionGetter_MAX', };
declare class K2Node_TransitionRuleGetter extends K2Node { 
	GetterType: ETransitionGetter;
	AssociatedAnimAssetPlayerNode: AnimGraphNode_Base;
	AssociatedStateNode: AnimStateNode;
	static Load(ResourceName: string): K2Node_TransitionRuleGetter;
	static Find(Outer: UObject, ResourceName: string): K2Node_TransitionRuleGetter;
	static GetDefaultObject(): K2Node_TransitionRuleGetter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TransitionRuleGetter;
	static C(Other: UObject | any): K2Node_TransitionRuleGetter;
}

declare class BlueprintNodeSpawner extends UObject { 
	NodeClass: UnrealEngineClass;
	static Load(ResourceName: string): BlueprintNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintNodeSpawner;
	static GetDefaultObject(): BlueprintNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintNodeSpawner;
	static C(Other: UObject | any): BlueprintNodeSpawner;
}

declare class BlueprintEventNodeSpawner extends BlueprintNodeSpawner { 
	EventFunc: UFunction;
	CustomEventName: string;
	static Load(ResourceName: string): BlueprintEventNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintEventNodeSpawner;
	static GetDefaultObject(): BlueprintEventNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEventNodeSpawner;
	static C(Other: UObject | any): BlueprintEventNodeSpawner;
}

declare class BlueprintBoundEventNodeSpawner extends BlueprintEventNodeSpawner { 
	EventDelegate: any;
	static Load(ResourceName: string): BlueprintBoundEventNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintBoundEventNodeSpawner;
	static GetDefaultObject(): BlueprintBoundEventNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundEventNodeSpawner;
	static C(Other: UObject | any): BlueprintBoundEventNodeSpawner;
}

declare class BlueprintBoundNodeSpawner extends BlueprintNodeSpawner { 
	static Load(ResourceName: string): BlueprintBoundNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintBoundNodeSpawner;
	static GetDefaultObject(): BlueprintBoundNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundNodeSpawner;
	static C(Other: UObject | any): BlueprintBoundNodeSpawner;
}

declare class BlueprintComponentNodeSpawner extends BlueprintNodeSpawner { 
	ComponentClass: UnrealEngineClass;
	ComponentName: string;
	ComponentAssetName: string;
	static Load(ResourceName: string): BlueprintComponentNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintComponentNodeSpawner;
	static GetDefaultObject(): BlueprintComponentNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintComponentNodeSpawner;
	static C(Other: UObject | any): BlueprintComponentNodeSpawner;
}

declare class BlueprintFieldNodeSpawner extends BlueprintNodeSpawner { 
	OwnerClass: UnrealEngineClass;
	Field: Field;
	Property: any;
	static Load(ResourceName: string): BlueprintFieldNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintFieldNodeSpawner;
	static GetDefaultObject(): BlueprintFieldNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFieldNodeSpawner;
	static C(Other: UObject | any): BlueprintFieldNodeSpawner;
}

declare class BlueprintDelegateNodeSpawner extends BlueprintFieldNodeSpawner { 
	static Load(ResourceName: string): BlueprintDelegateNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintDelegateNodeSpawner;
	static GetDefaultObject(): BlueprintDelegateNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintDelegateNodeSpawner;
	static C(Other: UObject | any): BlueprintDelegateNodeSpawner;
}

declare type EBlueprintBreakpointReloadMethod = 'RestoreAll' | 'RestoreAllAndDisable' | 'DiscardAll' | 'EBlueprintBreakpointReloadMethod_MAX';
declare var EBlueprintBreakpointReloadMethod : { RestoreAll:'RestoreAll',RestoreAllAndDisable:'RestoreAllAndDisable',DiscardAll:'DiscardAll',EBlueprintBreakpointReloadMethod_MAX:'EBlueprintBreakpointReloadMethod_MAX', };
declare type ESaveOnCompile = 'SoC_Never' | 'SoC_SuccessOnly' | 'SoC_Always' | 'SoC_MAX';
declare var ESaveOnCompile : { SoC_Never:'SoC_Never',SoC_SuccessOnly:'SoC_SuccessOnly',SoC_Always:'SoC_Always',SoC_MAX:'SoC_MAX', };
declare class BlueprintEditorSettings extends DeveloperSettings { 
	bDrawMidpointArrowsInBlueprints: boolean;
	bShowGraphInstructionText: boolean;
	bHideUnrelatedNodes: boolean;
	bShowShortTooltips: boolean;
	bSplitContextTargetSettings: boolean;
	bExposeAllMemberComponentFunctions: boolean;
	bShowContextualFavorites: boolean;
	bExposeDeprecatedFunctions: boolean;
	bCompactCallOnMemberNodes: boolean;
	bFlattenFavoritesMenus: boolean;
	bAutoCastObjectConnections: boolean;
	bShowViewportOnSimulate: boolean;
	bSpawnDefaultBlueprintNodes: boolean;
	bHideConstructionScriptComponentsInDetailsView: boolean;
	bHostFindInBlueprintsInGlobalTab: boolean;
	bNavigateToNativeFunctionsFromCallNodes: boolean;
	bDoubleClickNavigatesToParent: boolean;
	bEnableTypePromotion: boolean;
	TypePromotionPinDenyList: any;
	BreakpointReloadMethod: EBlueprintBreakpointReloadMethod;
	bEnablePinValueInspectionTooltips: boolean;
	bEnableNamespaceEditorFeatures: boolean;
	bEnableNamespaceFilteringFeatures: boolean;
	bEnableNamespaceImportingFeatures: boolean;
	NamespacesToAlwaysInclude: string[];
	bFavorPureCastNodes: boolean;
	SaveOnCompile: ESaveOnCompile;
	bJumpToNodeErrors: boolean;
	bAllowExplicitImpureNodeDisabling: boolean;
	bShowActionMenuItemSignatures: boolean;
	bBlueprintNodeUniqueNames: boolean;
	bShowDetailedCompileResults: boolean;
	CompileEventDisplayThresholdMs: number;
	NodeTemplateCacheCapMB: number;
	bShowInheritedVariables: boolean;
	bAlwaysShowInterfacesInOverrides: boolean;
	bShowParentClassInOverrides: boolean;
	bShowEmptySections: boolean;
	bShowAccessSpecifier: boolean;
	Bookmarks: any;
	BookmarkNodes: BPEditorBookmarkNode[];
	PerBlueprintSettings: any;
	bIncludeCommentNodesInBookmarksTab: boolean;
	bShowBookmarksForCurrentDocumentOnlyInTab: boolean;
	GraphEditorQuickJumps: any;
	BaseClassesToAllowRecompilingDuringPlayInEditor: Class[];
	static Load(ResourceName: string): BlueprintEditorSettings;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorSettings;
	static GetDefaultObject(): BlueprintEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorSettings;
	static C(Other: UObject | any): BlueprintEditorSettings;
}

declare class BlueprintFunctionNodeSpawner extends BlueprintFieldNodeSpawner { 
	static Load(ResourceName: string): BlueprintFunctionNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionNodeSpawner;
	static GetDefaultObject(): BlueprintFunctionNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionNodeSpawner;
	static C(Other: UObject | any): BlueprintFunctionNodeSpawner;
}

declare class BlueprintVariableNodeSpawner extends BlueprintFieldNodeSpawner { 
	LocalVarOuter: EdGraph;
	LocalVarDesc: BPVariableDescription;
	static Load(ResourceName: string): BlueprintVariableNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintVariableNodeSpawner;
	static GetDefaultObject(): BlueprintVariableNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintVariableNodeSpawner;
	static C(Other: UObject | any): BlueprintVariableNodeSpawner;
}

declare class K2Node_ActorBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	EventOwner: Actor;
	static Load(ResourceName: string): K2Node_ActorBoundEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_ActorBoundEvent;
	static GetDefaultObject(): K2Node_ActorBoundEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ActorBoundEvent;
	static C(Other: UObject | any): K2Node_ActorBoundEvent;
}

declare class K2Node_AddComponent extends K2Node_CallFunction { 
	bHasExposedVariable: boolean;
	TemplateBlueprint: string;
	TemplateType: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_AddComponent;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddComponent;
	static GetDefaultObject(): K2Node_AddComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddComponent;
	static C(Other: UObject | any): K2Node_AddComponent;
}

declare class K2Node_ConstructObjectFromClass extends K2Node { 
	static Load(ResourceName: string): K2Node_ConstructObjectFromClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_ConstructObjectFromClass;
	static GetDefaultObject(): K2Node_ConstructObjectFromClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConstructObjectFromClass;
	static C(Other: UObject | any): K2Node_ConstructObjectFromClass;
}

declare class K2Node_AddComponentByClass extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_AddComponentByClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddComponentByClass;
	static GetDefaultObject(): K2Node_AddComponentByClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddComponentByClass;
	static C(Other: UObject | any): K2Node_AddComponentByClass;
}

declare class K2Node_BaseMCDelegate extends K2Node { 
	DelegateReference: MemberReference;
	static Load(ResourceName: string): K2Node_BaseMCDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_BaseMCDelegate;
	static GetDefaultObject(): K2Node_BaseMCDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseMCDelegate;
	static C(Other: UObject | any): K2Node_BaseMCDelegate;
}

declare class K2Node_AddDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_AddDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddDelegate;
	static GetDefaultObject(): K2Node_AddDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddDelegate;
	static C(Other: UObject | any): K2Node_AddDelegate;
}

declare class K2Node_AddPinInterface extends Interface { 
	static Load(ResourceName: string): K2Node_AddPinInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddPinInterface;
	static GetDefaultObject(): K2Node_AddPinInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddPinInterface;
	static C(Other: UObject | any): K2Node_AddPinInterface;
}

declare class K2Node_AssignDelegate extends K2Node_AddDelegate { 
	static Load(ResourceName: string): K2Node_AssignDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_AssignDelegate;
	static GetDefaultObject(): K2Node_AssignDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignDelegate;
	static C(Other: UObject | any): K2Node_AssignDelegate;
}

declare class K2Node_AssignmentStatement extends K2Node { 
	static Load(ResourceName: string): K2Node_AssignmentStatement;
	static Find(Outer: UObject, ResourceName: string): K2Node_AssignmentStatement;
	static GetDefaultObject(): K2Node_AssignmentStatement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignmentStatement;
	static C(Other: UObject | any): K2Node_AssignmentStatement;
}

declare class K2Node_AsyncAction extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_AsyncAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_AsyncAction;
	static GetDefaultObject(): K2Node_AsyncAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AsyncAction;
	static C(Other: UObject | any): K2Node_AsyncAction;
}

declare class K2Node_BitmaskLiteral extends K2Node { 
	BitflagsEnum: Enum;
	static Load(ResourceName: string): K2Node_BitmaskLiteral;
	static Find(Outer: UObject, ResourceName: string): K2Node_BitmaskLiteral;
	static GetDefaultObject(): K2Node_BitmaskLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BitmaskLiteral;
	static C(Other: UObject | any): K2Node_BitmaskLiteral;
}

declare type ESelfContextInfo = 'Unspecified' | 'NotSelfContext' | 'ESelfContextInfo_MAX';
declare var ESelfContextInfo : { Unspecified:'Unspecified',NotSelfContext:'NotSelfContext',ESelfContextInfo_MAX:'ESelfContextInfo_MAX', };
declare class K2Node_Variable extends K2Node { 
	VariableReference: MemberReference;
	SelfContextInfo: ESelfContextInfo;
	VariableSourceClass: UnrealEngineClass;
	VariableName: string;
	bSelfContext: boolean;
	static Load(ResourceName: string): K2Node_Variable;
	static Find(Outer: UObject, ResourceName: string): K2Node_Variable;
	static GetDefaultObject(): K2Node_Variable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Variable;
	static C(Other: UObject | any): K2Node_Variable;
}

declare class K2Node_StructOperation extends K2Node_Variable { 
	StructType: ScriptStruct;
	static Load(ResourceName: string): K2Node_StructOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructOperation;
	static GetDefaultObject(): K2Node_StructOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructOperation;
	static C(Other: UObject | any): K2Node_StructOperation;
}

declare class K2Node_StructMemberGet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): K2Node_StructMemberGet;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructMemberGet;
	static GetDefaultObject(): K2Node_StructMemberGet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberGet;
	static C(Other: UObject | any): K2Node_StructMemberGet;
}

declare class K2Node_BreakStruct extends K2Node_StructMemberGet { 
	bMadeAfterOverridePinRemoval: boolean;
	static Load(ResourceName: string): K2Node_BreakStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_BreakStruct;
	static GetDefaultObject(): K2Node_BreakStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BreakStruct;
	static C(Other: UObject | any): K2Node_BreakStruct;
}

declare class K2Node_CallArrayFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallArrayFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallArrayFunction;
	static GetDefaultObject(): K2Node_CallArrayFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallArrayFunction;
	static C(Other: UObject | any): K2Node_CallArrayFunction;
}

declare class K2Node_CallDataTableFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallDataTableFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallDataTableFunction;
	static GetDefaultObject(): K2Node_CallDataTableFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDataTableFunction;
	static C(Other: UObject | any): K2Node_CallDataTableFunction;
}

declare class K2Node_CallDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_CallDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallDelegate;
	static GetDefaultObject(): K2Node_CallDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDelegate;
	static C(Other: UObject | any): K2Node_CallDelegate;
}

declare class K2Node_CallFunctionOnMember extends K2Node_CallFunction { 
	MemberVariableToCallOn: MemberReference;
	static Load(ResourceName: string): K2Node_CallFunctionOnMember;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallFunctionOnMember;
	static GetDefaultObject(): K2Node_CallFunctionOnMember;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunctionOnMember;
	static C(Other: UObject | any): K2Node_CallFunctionOnMember;
}

declare class K2Node_CallMaterialParameterCollectionFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static GetDefaultObject(): K2Node_CallMaterialParameterCollectionFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallMaterialParameterCollectionFunction;
	static C(Other: UObject | any): K2Node_CallMaterialParameterCollectionFunction;
}

declare class K2Node_CallParentFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallParentFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallParentFunction;
	static GetDefaultObject(): K2Node_CallParentFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallParentFunction;
	static C(Other: UObject | any): K2Node_CallParentFunction;
}

declare class K2Node_CastByteToEnum extends K2Node { 
	Enum: Enum;
	bSafe: boolean;
	static Load(ResourceName: string): K2Node_CastByteToEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_CastByteToEnum;
	static GetDefaultObject(): K2Node_CastByteToEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CastByteToEnum;
	static C(Other: UObject | any): K2Node_CastByteToEnum;
}

declare class K2Node_DynamicCast extends K2Node { 
	TargetType: UnrealEngineClass;
	bIsPureCast: boolean;
	static Load(ResourceName: string): K2Node_DynamicCast;
	static Find(Outer: UObject, ResourceName: string): K2Node_DynamicCast;
	static GetDefaultObject(): K2Node_DynamicCast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DynamicCast;
	static C(Other: UObject | any): K2Node_DynamicCast;
}

declare class K2Node_ClassDynamicCast extends K2Node_DynamicCast { 
	static Load(ResourceName: string): K2Node_ClassDynamicCast;
	static Find(Outer: UObject, ResourceName: string): K2Node_ClassDynamicCast;
	static GetDefaultObject(): K2Node_ClassDynamicCast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClassDynamicCast;
	static C(Other: UObject | any): K2Node_ClassDynamicCast;
}

declare class K2Node_ClearDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_ClearDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_ClearDelegate;
	static GetDefaultObject(): K2Node_ClearDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClearDelegate;
	static C(Other: UObject | any): K2Node_ClearDelegate;
}

declare class K2Node_CommutativeAssociativeBinaryOperator extends K2Node_CallFunction { 
	NumAdditionalInputs: number;
	static Load(ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static Find(Outer: UObject, ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static GetDefaultObject(): K2Node_CommutativeAssociativeBinaryOperator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CommutativeAssociativeBinaryOperator;
	static C(Other: UObject | any): K2Node_CommutativeAssociativeBinaryOperator;
}

declare class K2Node_ComponentBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	ComponentPropertyName: string;
	DelegatePropertyDisplayName: string;
	static Load(ResourceName: string): K2Node_ComponentBoundEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_ComponentBoundEvent;
	static GetDefaultObject(): K2Node_ComponentBoundEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ComponentBoundEvent;
	static C(Other: UObject | any): K2Node_ComponentBoundEvent;
}

declare class K2Node_Tunnel extends K2Node_EditablePinBase { 
	OutputSourceNode: K2Node_Tunnel;
	InputSinkNode: K2Node_Tunnel;
	bCanHaveInputs: boolean;
	bCanHaveOutputs: boolean;
	MetaData: KismetUserDeclaredFunctionMetadata;
	static Load(ResourceName: string): K2Node_Tunnel;
	static Find(Outer: UObject, ResourceName: string): K2Node_Tunnel;
	static GetDefaultObject(): K2Node_Tunnel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Tunnel;
	static C(Other: UObject | any): K2Node_Tunnel;
}

declare class K2Node_Composite extends K2Node_Tunnel { 
	BoundGraph: EdGraph;
	static Load(ResourceName: string): K2Node_Composite;
	static Find(Outer: UObject, ResourceName: string): K2Node_Composite;
	static GetDefaultObject(): K2Node_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Composite;
	static C(Other: UObject | any): K2Node_Composite;
}

declare class K2Node_ConvertAsset extends K2Node { 
	static Load(ResourceName: string): K2Node_ConvertAsset;
	static Find(Outer: UObject, ResourceName: string): K2Node_ConvertAsset;
	static GetDefaultObject(): K2Node_ConvertAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConvertAsset;
	static C(Other: UObject | any): K2Node_ConvertAsset;
}

declare class K2Node_Copy extends K2Node { 
	static Load(ResourceName: string): K2Node_Copy;
	static Find(Outer: UObject, ResourceName: string): K2Node_Copy;
	static GetDefaultObject(): K2Node_Copy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Copy;
	static C(Other: UObject | any): K2Node_Copy;
}

declare class K2Node_CreateDelegate extends K2Node { 
	SelectedFunctionName: string;
	SelectedFunctionGuid: Guid;
	static Load(ResourceName: string): K2Node_CreateDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDelegate;
	static GetDefaultObject(): K2Node_CreateDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDelegate;
	static C(Other: UObject | any): K2Node_CreateDelegate;
}

declare class K2Node_DeadClass extends K2Node { 
	static Load(ResourceName: string): K2Node_DeadClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_DeadClass;
	static GetDefaultObject(): K2Node_DeadClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DeadClass;
	static C(Other: UObject | any): K2Node_DeadClass;
}

declare class K2Node_DelegateSet extends K2Node { 
	DelegatePropertyName: string;
	DelegatePropertyClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_DelegateSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_DelegateSet;
	static GetDefaultObject(): K2Node_DelegateSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DelegateSet;
	static C(Other: UObject | any): K2Node_DelegateSet;
}

declare class K2Node_TemporaryVariable extends K2Node { 
	VariableType: EdGraphPinType;
	bIsPersistent: boolean;
	static Load(ResourceName: string): K2Node_TemporaryVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_TemporaryVariable;
	static GetDefaultObject(): K2Node_TemporaryVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TemporaryVariable;
	static C(Other: UObject | any): K2Node_TemporaryVariable;
}

declare class K2Node_DoOnceMultiInput extends K2Node { 
	NumAdditionalInputs: number;
	DataNode: K2Node_TemporaryVariable;
	static Load(ResourceName: string): K2Node_DoOnceMultiInput;
	static Find(Outer: UObject, ResourceName: string): K2Node_DoOnceMultiInput;
	static GetDefaultObject(): K2Node_DoOnceMultiInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DoOnceMultiInput;
	static C(Other: UObject | any): K2Node_DoOnceMultiInput;
}

declare class K2Node_EaseFunction extends K2Node { 
	EaseFunctionName: string;
	static Load(ResourceName: string): K2Node_EaseFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_EaseFunction;
	static GetDefaultObject(): K2Node_EaseFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EaseFunction;
	static C(Other: UObject | any): K2Node_EaseFunction;
}

declare class K2Node_EditorPropertyAccessBase extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_EditorPropertyAccessBase;
	static Find(Outer: UObject, ResourceName: string): K2Node_EditorPropertyAccessBase;
	static GetDefaultObject(): K2Node_EditorPropertyAccessBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EditorPropertyAccessBase;
	static C(Other: UObject | any): K2Node_EditorPropertyAccessBase;
}

declare class K2Node_GetEditorProperty extends K2Node_EditorPropertyAccessBase { 
	static Load(ResourceName: string): K2Node_GetEditorProperty;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEditorProperty;
	static GetDefaultObject(): K2Node_GetEditorProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEditorProperty;
	static C(Other: UObject | any): K2Node_GetEditorProperty;
}

declare class K2Node_SetEditorProperty extends K2Node_EditorPropertyAccessBase { 
	static Load(ResourceName: string): K2Node_SetEditorProperty;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetEditorProperty;
	static GetDefaultObject(): K2Node_SetEditorProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetEditorProperty;
	static C(Other: UObject | any): K2Node_SetEditorProperty;
}

declare class K2Node_EnumEquality extends K2Node { 
	static Load(ResourceName: string): K2Node_EnumEquality;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumEquality;
	static GetDefaultObject(): K2Node_EnumEquality;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumEquality;
	static C(Other: UObject | any): K2Node_EnumEquality;
}

declare class K2Node_EnumInequality extends K2Node_EnumEquality { 
	static Load(ResourceName: string): K2Node_EnumInequality;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumInequality;
	static GetDefaultObject(): K2Node_EnumInequality;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumInequality;
	static C(Other: UObject | any): K2Node_EnumInequality;
}

declare class K2Node_EnumLiteral extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_EnumLiteral;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumLiteral;
	static GetDefaultObject(): K2Node_EnumLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumLiteral;
	static C(Other: UObject | any): K2Node_EnumLiteral;
}

declare class K2Node_EventNodeInterface extends Interface { 
	static Load(ResourceName: string): K2Node_EventNodeInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_EventNodeInterface;
	static GetDefaultObject(): K2Node_EventNodeInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EventNodeInterface;
	static C(Other: UObject | any): K2Node_EventNodeInterface;
}

declare class K2Node_ExecutionSequence extends K2Node { 
	static Load(ResourceName: string): K2Node_ExecutionSequence;
	static Find(Outer: UObject, ResourceName: string): K2Node_ExecutionSequence;
	static GetDefaultObject(): K2Node_ExecutionSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ExecutionSequence;
	static C(Other: UObject | any): K2Node_ExecutionSequence;
}

declare class K2Node_ExternalGraphInterface extends Interface { 
	static Load(ResourceName: string): K2Node_ExternalGraphInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_ExternalGraphInterface;
	static GetDefaultObject(): K2Node_ExternalGraphInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ExternalGraphInterface;
	static C(Other: UObject | any): K2Node_ExternalGraphInterface;
}

declare class K2Node_ForEachElementInEnum extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_ForEachElementInEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_ForEachElementInEnum;
	static GetDefaultObject(): K2Node_ForEachElementInEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ForEachElementInEnum;
	static C(Other: UObject | any): K2Node_ForEachElementInEnum;
}

declare class K2Node_FormatText extends K2Node { 
	PinNames: string[];
	static Load(ResourceName: string): K2Node_FormatText;
	static Find(Outer: UObject, ResourceName: string): K2Node_FormatText;
	static GetDefaultObject(): K2Node_FormatText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FormatText;
	static C(Other: UObject | any): K2Node_FormatText;
}

declare class K2Node_FunctionTerminator extends K2Node_EditablePinBase { 
	FunctionReference: MemberReference;
	SignatureClass: UnrealEngineClass;
	SignatureName: string;
	static Load(ResourceName: string): K2Node_FunctionTerminator;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionTerminator;
	static GetDefaultObject(): K2Node_FunctionTerminator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionTerminator;
	static C(Other: UObject | any): K2Node_FunctionTerminator;
}

declare class K2Node_FunctionEntry extends K2Node_FunctionTerminator { 
	CustomGeneratedFunctionName: string;
	MetaData: KismetUserDeclaredFunctionMetadata;
	LocalVariables: BPVariableDescription[];
	bEnforceConstCorrectness: boolean;
	ExtraFlags: number;
	static Load(ResourceName: string): K2Node_FunctionEntry;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionEntry;
	static GetDefaultObject(): K2Node_FunctionEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionEntry;
	static C(Other: UObject | any): K2Node_FunctionEntry;
}

declare class K2Node_FunctionResult extends K2Node_FunctionTerminator { 
	static Load(ResourceName: string): K2Node_FunctionResult;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionResult;
	static GetDefaultObject(): K2Node_FunctionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionResult;
	static C(Other: UObject | any): K2Node_FunctionResult;
}

declare class K2Node_GenericCreateObject extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_GenericCreateObject;
	static Find(Outer: UObject, ResourceName: string): K2Node_GenericCreateObject;
	static GetDefaultObject(): K2Node_GenericCreateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GenericCreateObject;
	static C(Other: UObject | any): K2Node_GenericCreateObject;
}

declare class K2Node_GetArrayItem extends K2Node { 
	bReturnByRefDesired: boolean;
	static Load(ResourceName: string): K2Node_GetArrayItem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetArrayItem;
	static GetDefaultObject(): K2Node_GetArrayItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetArrayItem;
	static C(Other: UObject | any): K2Node_GetArrayItem;
}

declare class K2Node_GetClassDefaults extends K2Node { 
	BlueprintSubscribedTo: Blueprint;
	ShowPinForProperties: OptionalPinFromProperty[];
	bExcludeObjectContainers: boolean;
	bExcludeObjectArrays: boolean;
	static Load(ResourceName: string): K2Node_GetClassDefaults;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetClassDefaults;
	static GetDefaultObject(): K2Node_GetClassDefaults;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetClassDefaults;
	static C(Other: UObject | any): K2Node_GetClassDefaults;
}

declare class K2Node_GetDataTableRow extends K2Node { 
	static Load(ResourceName: string): K2Node_GetDataTableRow;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetDataTableRow;
	static GetDefaultObject(): K2Node_GetDataTableRow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetDataTableRow;
	static C(Other: UObject | any): K2Node_GetDataTableRow;
}

declare class K2Node_GetEnumeratorName extends K2Node { 
	static Load(ResourceName: string): K2Node_GetEnumeratorName;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEnumeratorName;
	static GetDefaultObject(): K2Node_GetEnumeratorName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorName;
	static C(Other: UObject | any): K2Node_GetEnumeratorName;
}

declare class K2Node_GetEnumeratorNameAsString extends K2Node_GetEnumeratorName { 
	static Load(ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static GetDefaultObject(): K2Node_GetEnumeratorNameAsString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorNameAsString;
	static C(Other: UObject | any): K2Node_GetEnumeratorNameAsString;
}

declare class K2Node_GetInputAxisKeyValue extends K2Node_CallFunction { 
	InputAxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_GetInputAxisKeyValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputAxisKeyValue;
	static GetDefaultObject(): K2Node_GetInputAxisKeyValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisKeyValue;
	static C(Other: UObject | any): K2Node_GetInputAxisKeyValue;
}

declare class K2Node_GetInputAxisValue extends K2Node_CallFunction { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_GetInputAxisValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputAxisValue;
	static GetDefaultObject(): K2Node_GetInputAxisValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisValue;
	static C(Other: UObject | any): K2Node_GetInputAxisValue;
}

declare class K2Node_GetInputVectorAxisValue extends K2Node_GetInputAxisKeyValue { 
	static Load(ResourceName: string): K2Node_GetInputVectorAxisValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputVectorAxisValue;
	static GetDefaultObject(): K2Node_GetInputVectorAxisValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputVectorAxisValue;
	static C(Other: UObject | any): K2Node_GetInputVectorAxisValue;
}

declare class K2Node_GetNumEnumEntries extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_GetNumEnumEntries;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetNumEnumEntries;
	static GetDefaultObject(): K2Node_GetNumEnumEntries;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetNumEnumEntries;
	static C(Other: UObject | any): K2Node_GetNumEnumEntries;
}

declare class K2Node_GetSubsystem extends K2Node { 
	CustomClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_GetSubsystem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSubsystem;
	static GetDefaultObject(): K2Node_GetSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSubsystem;
	static C(Other: UObject | any): K2Node_GetSubsystem;
}

declare class K2Node_GetSubsystemFromPC extends K2Node_GetSubsystem { 
	static Load(ResourceName: string): K2Node_GetSubsystemFromPC;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSubsystemFromPC;
	static GetDefaultObject(): K2Node_GetSubsystemFromPC;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSubsystemFromPC;
	static C(Other: UObject | any): K2Node_GetSubsystemFromPC;
}

declare class K2Node_GetEngineSubsystem extends K2Node_GetSubsystem { 
	static Load(ResourceName: string): K2Node_GetEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEngineSubsystem;
	static GetDefaultObject(): K2Node_GetEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEngineSubsystem;
	static C(Other: UObject | any): K2Node_GetEngineSubsystem;
}

declare class K2Node_GetEditorSubsystem extends K2Node_GetSubsystem { 
	static Load(ResourceName: string): K2Node_GetEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEditorSubsystem;
	static GetDefaultObject(): K2Node_GetEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEditorSubsystem;
	static C(Other: UObject | any): K2Node_GetEditorSubsystem;
}

declare class K2Node_IfThenElse extends K2Node { 
	static Load(ResourceName: string): K2Node_IfThenElse;
	static Find(Outer: UObject, ResourceName: string): K2Node_IfThenElse;
	static GetDefaultObject(): K2Node_IfThenElse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_IfThenElse;
	static C(Other: UObject | any): K2Node_IfThenElse;
}

declare class K2Node_InputAction extends K2Node { 
	InputActionName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAction;
	static GetDefaultObject(): K2Node_InputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAction;
	static C(Other: UObject | any): K2Node_InputAction;
}

declare class K2Node_InputActionEvent extends K2Node_Event { 
	InputActionName: string;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputActionEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputActionEvent;
	static GetDefaultObject(): K2Node_InputActionEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputActionEvent;
	static C(Other: UObject | any): K2Node_InputActionEvent;
}

declare class K2Node_InputAxisEvent extends K2Node_Event { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAxisEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAxisEvent;
	static GetDefaultObject(): K2Node_InputAxisEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisEvent;
	static C(Other: UObject | any): K2Node_InputAxisEvent;
}

declare class K2Node_InputAxisKeyEvent extends K2Node_Event { 
	AxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAxisKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAxisKeyEvent;
	static GetDefaultObject(): K2Node_InputAxisKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisKeyEvent;
	static C(Other: UObject | any): K2Node_InputAxisKeyEvent;
}

declare class K2Node_InputKey extends K2Node { 
	InputKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	bControl: boolean;
	bAlt: boolean;
	bShift: boolean;
	bCommand: boolean;
	static Load(ResourceName: string): K2Node_InputKey;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputKey;
	static GetDefaultObject(): K2Node_InputKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKey;
	static C(Other: UObject | any): K2Node_InputKey;
}

declare class InputChord { 
	Key: Key;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
	clone() : InputChord;
	static C(Other: UObject | any): InputChord;
	EqualEqual_InputChordInputChord(B: InputChord): boolean;
	InputChord_GetDisplayName(): string;
	static EqualEqual_InputChordInputChord(A: InputChord,B: InputChord): boolean;
	static InputChord_GetDisplayName(Key: InputChord): string;
}

declare class K2Node_InputKeyEvent extends K2Node_Event { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputKeyEvent;
	static GetDefaultObject(): K2Node_InputKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKeyEvent;
	static C(Other: UObject | any): K2Node_InputKeyEvent;
}

declare class K2Node_InputTouch extends K2Node { 
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputTouch;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputTouch;
	static GetDefaultObject(): K2Node_InputTouch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouch;
	static C(Other: UObject | any): K2Node_InputTouch;
}

declare class K2Node_InputTouchEvent extends K2Node_Event { 
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputTouchEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputTouchEvent;
	static GetDefaultObject(): K2Node_InputTouchEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouchEvent;
	static C(Other: UObject | any): K2Node_InputTouchEvent;
}

declare class K2Node_InputVectorAxisEvent extends K2Node_InputAxisKeyEvent { 
	static Load(ResourceName: string): K2Node_InputVectorAxisEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputVectorAxisEvent;
	static GetDefaultObject(): K2Node_InputVectorAxisEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputVectorAxisEvent;
	static C(Other: UObject | any): K2Node_InputVectorAxisEvent;
}

declare class K2Node_Knot extends K2Node { 
	static Load(ResourceName: string): K2Node_Knot;
	static Find(Outer: UObject, ResourceName: string): K2Node_Knot;
	static GetDefaultObject(): K2Node_Knot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Knot;
	static C(Other: UObject | any): K2Node_Knot;
}

declare class K2Node_Literal extends K2Node { 
	ObjectRef: UObject;
	static Load(ResourceName: string): K2Node_Literal;
	static Find(Outer: UObject, ResourceName: string): K2Node_Literal;
	static GetDefaultObject(): K2Node_Literal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Literal;
	static C(Other: UObject | any): K2Node_Literal;
}

declare class K2Node_LoadAsset extends K2Node { 
	static Load(ResourceName: string): K2Node_LoadAsset;
	static Find(Outer: UObject, ResourceName: string): K2Node_LoadAsset;
	static GetDefaultObject(): K2Node_LoadAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAsset;
	static C(Other: UObject | any): K2Node_LoadAsset;
}

declare class K2Node_LoadAssetClass extends K2Node_LoadAsset { 
	static Load(ResourceName: string): K2Node_LoadAssetClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_LoadAssetClass;
	static GetDefaultObject(): K2Node_LoadAssetClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAssetClass;
	static C(Other: UObject | any): K2Node_LoadAssetClass;
}

declare class K2Node_LocalVariable extends K2Node_TemporaryVariable { 
	CustomVariableName: string;
	VariableTooltip: string;
	static Load(ResourceName: string): K2Node_LocalVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_LocalVariable;
	static GetDefaultObject(): K2Node_LocalVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LocalVariable;
	static C(Other: UObject | any): K2Node_LocalVariable;
}

declare class GraphReference { 
	MacroGraph: EdGraph;
	GraphBlueprint: Blueprint;
	GraphGuid: Guid;
	clone() : GraphReference;
	static C(Other: UObject | any): GraphReference;
}

declare class K2Node_MacroInstance extends K2Node_Tunnel { 
	MacroGraph: EdGraph;
	MacroGraphReference: GraphReference;
	ResolvedWildcardType: EdGraphPinType;
	static Load(ResourceName: string): K2Node_MacroInstance;
	static Find(Outer: UObject, ResourceName: string): K2Node_MacroInstance;
	static GetDefaultObject(): K2Node_MacroInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MacroInstance;
	static C(Other: UObject | any): K2Node_MacroInstance;
}

declare class K2Node_MakeContainer extends K2Node { 
	NumInputs: number;
	static Load(ResourceName: string): K2Node_MakeContainer;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeContainer;
	static GetDefaultObject(): K2Node_MakeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeContainer;
	static C(Other: UObject | any): K2Node_MakeContainer;
}

declare class K2Node_MakeArray extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeArray;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeArray;
	static GetDefaultObject(): K2Node_MakeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeArray;
	static C(Other: UObject | any): K2Node_MakeArray;
}

declare class K2Node_MakeMap extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeMap;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeMap;
	static GetDefaultObject(): K2Node_MakeMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeMap;
	static C(Other: UObject | any): K2Node_MakeMap;
}

declare class K2Node_MakeSet extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeSet;
	static GetDefaultObject(): K2Node_MakeSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeSet;
	static C(Other: UObject | any): K2Node_MakeSet;
}

declare class K2Node_StructMemberSet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): K2Node_StructMemberSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructMemberSet;
	static GetDefaultObject(): K2Node_StructMemberSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberSet;
	static C(Other: UObject | any): K2Node_StructMemberSet;
}

declare class K2Node_MakeStruct extends K2Node_StructMemberSet { 
	bMadeAfterOverridePinRemoval: boolean;
	static Load(ResourceName: string): K2Node_MakeStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeStruct;
	static GetDefaultObject(): K2Node_MakeStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeStruct;
	static C(Other: UObject | any): K2Node_MakeStruct;
}

declare class K2Node_MakeVariable extends K2Node { 
	VariableType: BPVariableDescription;
	static Load(ResourceName: string): K2Node_MakeVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeVariable;
	static GetDefaultObject(): K2Node_MakeVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeVariable;
	static C(Other: UObject | any): K2Node_MakeVariable;
}

declare class K2Node_MathExpression extends K2Node_Composite { 
	Expression: string;
	bMadeAfterRotChange: boolean;
	static Load(ResourceName: string): K2Node_MathExpression;
	static Find(Outer: UObject, ResourceName: string): K2Node_MathExpression;
	static GetDefaultObject(): K2Node_MathExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MathExpression;
	static C(Other: UObject | any): K2Node_MathExpression;
}

declare class InterpFilter extends UObject { 
	Caption: string;
	static Load(ResourceName: string): InterpFilter;
	static Find(Outer: UObject, ResourceName: string): InterpFilter;
	static GetDefaultObject(): InterpFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter;
	static C(Other: UObject | any): InterpFilter;
}

declare class InterpGroupDirector extends InterpGroup { 
	static Load(ResourceName: string): InterpGroupDirector;
	static Find(Outer: UObject, ResourceName: string): InterpGroupDirector;
	static GetDefaultObject(): InterpGroupDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupDirector;
	static C(Other: UObject | any): InterpGroupDirector;
}

declare class InterpData extends UObject { 
	InterpLength: number;
	PathBuildTime: number;
	InterpGroups: InterpGroup[];
	CurveEdSetup: InterpCurveEdSetup;
	InterpFilters: InterpFilter[];
	SelectedFilter: InterpFilter;
	DefaultFilters: InterpFilter[];
	EdSectionStart: number;
	EdSectionEnd: number;
	bShouldBakeAndPrune: boolean;
	CachedDirectorGroup: InterpGroupDirector;
	AllEventNames: string[];
	static Load(ResourceName: string): InterpData;
	static Find(Outer: UObject, ResourceName: string): InterpData;
	static GetDefaultObject(): InterpData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpData;
	static C(Other: UObject | any): InterpData;
}

declare class InterpGroupActorInfo { 
	ObjectName: string;
	Actors: Actor[];
	clone() : InterpGroupActorInfo;
	static C(Other: UObject | any): InterpGroupActorInfo;
}

declare class CameraCutInfo { 
	Location: Vector;
	Timestamp: number;
	clone() : CameraCutInfo;
	static C(Other: UObject | any): CameraCutInfo;
}

declare class MatineeActor extends Actor { 
	MatineeData: InterpData;
	MatineeControllerName: string;
	PlayRate: number;
	bPlayOnLevelLoad: boolean;
	bForceStartPos: boolean;
	ForceStartPosition: number;
	bLooping: boolean;
	bRewindOnPlay: boolean;
	bNoResetOnRewind: boolean;
	bRewindIfAlreadyPlaying: boolean;
	bDisableRadioFilter: boolean;
	bClientSideOnly: boolean;
	bSkipUpdateIfNotVisible: boolean;
	bIsSkippable: boolean;
	PreferredSplitScreenNum: number;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	GroupActorInfos: InterpGroupActorInfo[];
	bShouldShowGore: boolean;
	GroupInst: InterpGroupInst[];
	CameraCuts: CameraCutInfo[];
	SpriteComponent: BillboardComponent;
	bIsBeingEdited: boolean;
	bIsScrubbing: boolean;
	bIsPlaying: boolean;
	bReversePlayback: boolean;
	bPaused: boolean;
	bPendingStop: boolean;
	InterpPosition: number;
	ReplicationForceIsPlaying: number;
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	static GetDefaultObject(): MatineeActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActor;
	Stop(): void;
	SetPosition(NewPosition: number,bJump: boolean): void;
	SetLoopingState(bNewLooping: boolean): void;
	Reverse(): void;
	Play(): void;
	Pause(): void;
	EnableGroupByName(GroupName: string,bEnable: boolean): void;
	ChangePlaybackDirection(): void;
	static C(Other: UObject | any): MatineeActor;
}

declare class K2Node_MatineeController extends K2Node { 
	MatineeActor: MatineeActor;
	static Load(ResourceName: string): K2Node_MatineeController;
	static Find(Outer: UObject, ResourceName: string): K2Node_MatineeController;
	static GetDefaultObject(): K2Node_MatineeController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MatineeController;
	static C(Other: UObject | any): K2Node_MatineeController;
}

declare class K2Node_Message extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_Message;
	static Find(Outer: UObject, ResourceName: string): K2Node_Message;
	static GetDefaultObject(): K2Node_Message;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Message;
	static C(Other: UObject | any): K2Node_Message;
}

declare class K2Node_MultiGate extends K2Node_ExecutionSequence { 
	DataNode: K2Node_TemporaryVariable;
	static Load(ResourceName: string): K2Node_MultiGate;
	static Find(Outer: UObject, ResourceName: string): K2Node_MultiGate;
	static GetDefaultObject(): K2Node_MultiGate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MultiGate;
	static C(Other: UObject | any): K2Node_MultiGate;
}

declare class K2Node_PromotableOperator extends K2Node_CallFunction { 
	NumAdditionalInputs: number;
	static Load(ResourceName: string): K2Node_PromotableOperator;
	static Find(Outer: UObject, ResourceName: string): K2Node_PromotableOperator;
	static GetDefaultObject(): K2Node_PromotableOperator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PromotableOperator;
	static C(Other: UObject | any): K2Node_PromotableOperator;
}

declare class K2Node_PureAssignmentStatement extends K2Node { 
	static Load(ResourceName: string): K2Node_PureAssignmentStatement;
	static Find(Outer: UObject, ResourceName: string): K2Node_PureAssignmentStatement;
	static GetDefaultObject(): K2Node_PureAssignmentStatement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PureAssignmentStatement;
	static C(Other: UObject | any): K2Node_PureAssignmentStatement;
}

declare class K2Node_RemoveDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_RemoveDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_RemoveDelegate;
	static GetDefaultObject(): K2Node_RemoveDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_RemoveDelegate;
	static C(Other: UObject | any): K2Node_RemoveDelegate;
}

declare class K2Node_Select extends K2Node { 
	NumOptionPins: number;
	IndexPinType: EdGraphPinType;
	Enum: Enum;
	EnumEntries: string[];
	EnumEntryFriendlyNames: string[];
	bReconstructNode: boolean;
	static Load(ResourceName: string): K2Node_Select;
	static Find(Outer: UObject, ResourceName: string): K2Node_Select;
	static GetDefaultObject(): K2Node_Select;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Select;
	static C(Other: UObject | any): K2Node_Select;
}

declare class K2Node_Self extends K2Node { 
	static Load(ResourceName: string): K2Node_Self;
	static Find(Outer: UObject, ResourceName: string): K2Node_Self;
	static GetDefaultObject(): K2Node_Self;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Self;
	static C(Other: UObject | any): K2Node_Self;
}

declare class K2Node_SetFieldsInStruct extends K2Node_MakeStruct { 
	static Load(ResourceName: string): K2Node_SetFieldsInStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetFieldsInStruct;
	static GetDefaultObject(): K2Node_SetFieldsInStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetFieldsInStruct;
	static C(Other: UObject | any): K2Node_SetFieldsInStruct;
}

declare class K2Node_SetVariableOnPersistentFrame extends K2Node { 
	static Load(ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static GetDefaultObject(): K2Node_SetVariableOnPersistentFrame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetVariableOnPersistentFrame;
	static C(Other: UObject | any): K2Node_SetVariableOnPersistentFrame;
}

declare class K2Node_SpawnActor extends K2Node { 
	static Load(ResourceName: string): K2Node_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): K2Node_SpawnActor;
	static GetDefaultObject(): K2Node_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActor;
	static C(Other: UObject | any): K2Node_SpawnActor;
}

declare class K2Node_SpawnActorFromClass extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_SpawnActorFromClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_SpawnActorFromClass;
	static GetDefaultObject(): K2Node_SpawnActorFromClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActorFromClass;
	static C(Other: UObject | any): K2Node_SpawnActorFromClass;
}

declare class K2Node_Switch extends K2Node { 
	bHasDefaultPin: boolean;
	FunctionName: string;
	FunctionClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_Switch;
	static Find(Outer: UObject, ResourceName: string): K2Node_Switch;
	static GetDefaultObject(): K2Node_Switch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Switch;
	static C(Other: UObject | any): K2Node_Switch;
}

declare class K2Node_SwitchEnum extends K2Node_Switch { 
	Enum: Enum;
	EnumEntries: string[];
	EnumFriendlyNames: string[];
	static Load(ResourceName: string): K2Node_SwitchEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchEnum;
	static GetDefaultObject(): K2Node_SwitchEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchEnum;
	static C(Other: UObject | any): K2Node_SwitchEnum;
}

declare class K2Node_SwitchInteger extends K2Node_Switch { 
	StartIndex: number;
	static Load(ResourceName: string): K2Node_SwitchInteger;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchInteger;
	static GetDefaultObject(): K2Node_SwitchInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchInteger;
	static C(Other: UObject | any): K2Node_SwitchInteger;
}

declare class K2Node_SwitchName extends K2Node_Switch { 
	PinNames: string[];
	static Load(ResourceName: string): K2Node_SwitchName;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchName;
	static GetDefaultObject(): K2Node_SwitchName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchName;
	static C(Other: UObject | any): K2Node_SwitchName;
}

declare class K2Node_SwitchString extends K2Node_Switch { 
	PinNames: string[];
	bIsCaseSensitive: boolean;
	static Load(ResourceName: string): K2Node_SwitchString;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchString;
	static GetDefaultObject(): K2Node_SwitchString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchString;
	static C(Other: UObject | any): K2Node_SwitchString;
}

declare class K2Node_Timeline extends K2Node { 
	TimelineName: string;
	bAutoPlay: boolean;
	TimelineGuid: Guid;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): K2Node_Timeline;
	static Find(Outer: UObject, ResourceName: string): K2Node_Timeline;
	static GetDefaultObject(): K2Node_Timeline;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Timeline;
	static C(Other: UObject | any): K2Node_Timeline;
}

declare type ETunnelBoundaryType = 'Unknown' | 'EntrySite' | 'InputSite' | 'OutputSite' | 'ETunnelBoundaryType_MAX';
declare var ETunnelBoundaryType : { Unknown:'Unknown',EntrySite:'EntrySite',InputSite:'InputSite',OutputSite:'OutputSite',ETunnelBoundaryType_MAX:'ETunnelBoundaryType_MAX', };
declare class K2Node_TunnelBoundary extends K2Node { 
	BaseName: string;
	TunnelBoundaryType: ETunnelBoundaryType;
	static Load(ResourceName: string): K2Node_TunnelBoundary;
	static Find(Outer: UObject, ResourceName: string): K2Node_TunnelBoundary;
	static GetDefaultObject(): K2Node_TunnelBoundary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TunnelBoundary;
	static C(Other: UObject | any): K2Node_TunnelBoundary;
}

declare class K2Node_VariableGet extends K2Node_Variable { 
	bIsPureGet: boolean;
	static Load(ResourceName: string): K2Node_VariableGet;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableGet;
	static GetDefaultObject(): K2Node_VariableGet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableGet;
	static C(Other: UObject | any): K2Node_VariableGet;
}

declare class K2Node_VariableSet extends K2Node_Variable { 
	static Load(ResourceName: string): K2Node_VariableSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableSet;
	static GetDefaultObject(): K2Node_VariableSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSet;
	static C(Other: UObject | any): K2Node_VariableSet;
}

declare class K2Node_VariableSetRef extends K2Node { 
	static Load(ResourceName: string): K2Node_VariableSetRef;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableSetRef;
	static GetDefaultObject(): K2Node_VariableSetRef;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSetRef;
	static C(Other: UObject | any): K2Node_VariableSetRef;
}

declare class NodeDependingOnEnumInterface extends Interface { 
	static Load(ResourceName: string): NodeDependingOnEnumInterface;
	static Find(Outer: UObject, ResourceName: string): NodeDependingOnEnumInterface;
	static GetDefaultObject(): NodeDependingOnEnumInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeDependingOnEnumInterface;
	static C(Other: UObject | any): NodeDependingOnEnumInterface;
}

declare class PinTypeSelectorFilter extends UObject { 
	FilterClass: Class;
	static Load(ResourceName: string): PinTypeSelectorFilter;
	static Find(Outer: UObject, ResourceName: string): PinTypeSelectorFilter;
	static GetDefaultObject(): PinTypeSelectorFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PinTypeSelectorFilter;
	static C(Other: UObject | any): PinTypeSelectorFilter;
}

declare class SourceCodeAccessSettings extends UObject { 
	PreferredAccessor: string;
	static Load(ResourceName: string): SourceCodeAccessSettings;
	static Find(Outer: UObject, ResourceName: string): SourceCodeAccessSettings;
	static GetDefaultObject(): SourceCodeAccessSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceCodeAccessSettings;
	static C(Other: UObject | any): SourceCodeAccessSettings;
}

declare type EBlueprintPinStyleType = 'BPST_Original' | 'BPST_VariantA' | 'BPST_MAX';
declare var EBlueprintPinStyleType : { BPST_Original:'BPST_Original',BPST_VariantA:'BPST_VariantA',BPST_MAX:'BPST_MAX', };
declare type EGraphPanningMouseButton = 'Right' | 'Middle' | 'Both' | 'EGraphPanningMouseButton_MAX';
declare var EGraphPanningMouseButton : { Right:'Right',Middle:'Middle',Both:'Both',EGraphPanningMouseButton_MAX:'EGraphPanningMouseButton_MAX', };
declare type ECommentBoxMode = 'GroupMovement' | 'NoGroupMovement' | 'ECommentBoxMode_MAX';
declare var ECommentBoxMode : { GroupMovement:'GroupMovement',NoGroupMovement:'NoGroupMovement',ECommentBoxMode_MAX:'ECommentBoxMode_MAX', };
declare class GraphEditorSettings extends UObject { 
	DataPinStyle: EBlueprintPinStyleType;
	PanningMouseButton: EGraphPanningMouseButton;
	PaddingAbovePin: number;
	PaddingBelowPin: number;
	PaddingRightOfInput: number;
	PaddingLeftOfOutput: number;
	PaddingTowardsNodeEdge: number;
	bTreatSplinesLikePins: boolean;
	SplineHoverTolerance: number;
	SplineCloseTolerance: number;
	ForwardSplineHorizontalDeltaRange: number;
	ForwardSplineVerticalDeltaRange: number;
	ForwardSplineTangentFromHorizontalDelta: Vector2D;
	ForwardSplineTangentFromVerticalDelta: Vector2D;
	BackwardSplineHorizontalDeltaRange: number;
	BackwardSplineVerticalDeltaRange: number;
	BackwardSplineTangentFromHorizontalDelta: Vector2D;
	BackwardSplineTangentFromVerticalDelta: Vector2D;
	DefaultPinTypeColor: LinearColor;
	ExecutionPinTypeColor: LinearColor;
	BooleanPinTypeColor: LinearColor;
	BytePinTypeColor: LinearColor;
	ClassPinTypeColor: LinearColor;
	IntPinTypeColor: LinearColor;
	Int64PinTypeColor: LinearColor;
	FloatPinTypeColor: LinearColor;
	DoublePinTypeColor: LinearColor;
	RealPinTypeColor: LinearColor;
	NamePinTypeColor: LinearColor;
	SoftObjectPinTypeColor: LinearColor;
	SoftClassPinTypeColor: LinearColor;
	DelegatePinTypeColor: LinearColor;
	ObjectPinTypeColor: LinearColor;
	InterfacePinTypeColor: LinearColor;
	StringPinTypeColor: LinearColor;
	TextPinTypeColor: LinearColor;
	StructPinTypeColor: LinearColor;
	WildcardPinTypeColor: LinearColor;
	VectorPinTypeColor: LinearColor;
	RotatorPinTypeColor: LinearColor;
	TransformPinTypeColor: LinearColor;
	IndexPinTypeColor: LinearColor;
	EventNodeTitleColor: LinearColor;
	FunctionCallNodeTitleColor: LinearColor;
	PureFunctionCallNodeTitleColor: LinearColor;
	ParentFunctionCallNodeTitleColor: LinearColor;
	FunctionTerminatorNodeTitleColor: LinearColor;
	ExecBranchNodeTitleColor: LinearColor;
	ExecSequenceNodeTitleColor: LinearColor;
	ResultNodeTitleColor: LinearColor;
	DefaultCommentNodeTitleColor: LinearColor;
	PreviewNodeTitleColor: LinearColor;
	DefaultDataWireThickness: number;
	DefaultExecutionWireThickness: number;
	TraceAttackColor: LinearColor;
	TraceAttackWireThickness: number;
	TraceAttackHoldPeriod: number;
	TraceDecayPeriod: number;
	TraceDecayExponent: number;
	TraceSustainColor: LinearColor;
	TraceSustainWireThickness: number;
	TraceSustainHoldPeriod: number;
	TraceReleaseColor: LinearColor;
	TraceReleaseWireThickness: number;
	TraceReleasePeriod: number;
	TraceReleaseExponent: number;
	TracePositionBonusPeriod: number;
	TracePositionExponent: number;
	PaddingAutoCollateIncrement: number;
	bOpenCreateMenuOnBlankGraphAreas: boolean;
	DefaultCommentNodeMoveMode: ECommentBoxMode;
	bShowCommentBubbleWhenZoomedOut: boolean;
	static Load(ResourceName: string): GraphEditorSettings;
	static Find(Outer: UObject, ResourceName: string): GraphEditorSettings;
	static GetDefaultObject(): GraphEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GraphEditorSettings;
	static C(Other: UObject | any): GraphEditorSettings;
}

declare type ELocalizationTargetConflictStatus = 'Unknown' | 'ConflictsPresent' | 'Clear' | 'ELocalizationTargetConflictStatus_MAX';
declare var ELocalizationTargetConflictStatus : { Unknown:'Unknown',ConflictsPresent:'ConflictsPresent',Clear:'Clear',ELocalizationTargetConflictStatus_MAX:'ELocalizationTargetConflictStatus_MAX', };
declare type ELocalizationGatherPathRoot = 'Auto' | 'Engine' | 'Project' | 'ELocalizationGatherPathRoot_MAX';
declare var ELocalizationGatherPathRoot : { Auto:'Auto',Engine:'Engine',Project:'Project',ELocalizationGatherPathRoot_MAX:'ELocalizationGatherPathRoot_MAX', };
declare class GatherTextSearchDirectory { 
	PathRoot: ELocalizationGatherPathRoot;
	Path: string;
	clone() : GatherTextSearchDirectory;
	static C(Other: UObject | any): GatherTextSearchDirectory;
}

declare class GatherTextExcludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextExcludePath;
	static C(Other: UObject | any): GatherTextExcludePath;
}

declare class GatherTextFileExtension { 
	Pattern: string;
	clone() : GatherTextFileExtension;
	static C(Other: UObject | any): GatherTextFileExtension;
}

declare class GatherTextFromTextFilesConfiguration { 
	IsEnabled: boolean;
	SearchDirectories: GatherTextSearchDirectory[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromTextFilesConfiguration;
	static C(Other: UObject | any): GatherTextFromTextFilesConfiguration;
}

declare class GatherTextIncludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextIncludePath;
	static C(Other: UObject | any): GatherTextIncludePath;
}

declare class GatherTextFromPackagesConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	Collections: string[];
	ExcludeClasses: SoftClassPath[];
	ShouldExcludeDerivedClasses: boolean;
	ShouldGatherFromEditorOnlyData: boolean;
	SkipGatherCache: boolean;
	clone() : GatherTextFromPackagesConfiguration;
	static C(Other: UObject | any): GatherTextFromPackagesConfiguration;
}

declare class MetaDataKeyName { 
	Name: string;
	clone() : MetaDataKeyName;
	static C(Other: UObject | any): MetaDataKeyName;
}

declare class MetaDataTextKeyPattern { 
	Pattern: string;
	clone() : MetaDataTextKeyPattern;
	static C(Other: UObject | any): MetaDataTextKeyPattern;
}

declare class MetaDataKeyGatherSpecification { 
	MetaDataKey: MetaDataKeyName;
	TextNamespace: string;
	TextKeyPattern: MetaDataTextKeyPattern;
	clone() : MetaDataKeyGatherSpecification;
	static C(Other: UObject | any): MetaDataKeyGatherSpecification;
}

declare class GatherTextFromMetaDataConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	KeySpecifications: MetaDataKeyGatherSpecification[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromMetaDataConfiguration;
	static C(Other: UObject | any): GatherTextFromMetaDataConfiguration;
}

declare type ELocalizedTextCollapseMode = 'IdenticalTextIdAndSource' | 'IdenticalPackageIdTextIdAndSource' | 'IdenticalNamespaceAndSource' | 'ELocalizedTextCollapseMode_MAX';
declare var ELocalizedTextCollapseMode : { IdenticalTextIdAndSource:'IdenticalTextIdAndSource',IdenticalPackageIdTextIdAndSource:'IdenticalPackageIdTextIdAndSource',IdenticalNamespaceAndSource:'IdenticalNamespaceAndSource',ELocalizedTextCollapseMode_MAX:'ELocalizedTextCollapseMode_MAX', };
declare type EPortableObjectFormat = 'Unreal' | 'Crowdin' | 'EPortableObjectFormat_MAX';
declare var EPortableObjectFormat : { Unreal:'Unreal',Crowdin:'Crowdin',EPortableObjectFormat_MAX:'EPortableObjectFormat_MAX', };
declare class LocalizationExportingSettings { 
	CollapseMode: ELocalizedTextCollapseMode;
	POFormat: EPortableObjectFormat;
	ShouldPersistCommentsOnExport: boolean;
	ShouldAddSourceLocationsAsComments: boolean;
	clone() : LocalizationExportingSettings;
	static C(Other: UObject | any): LocalizationExportingSettings;
}

declare class LocalizationCompilationSettings { 
	SkipSourceCheck: boolean;
	ValidateFormatPatterns: boolean;
	ValidateSafeWhitespace: boolean;
	clone() : LocalizationCompilationSettings;
	static C(Other: UObject | any): LocalizationCompilationSettings;
}

declare class LocalizationImportDialogueSettings { 
	RawAudioPath: DirectoryPath;
	ImportedDialogueFolder: string;
	bImportNativeAsSource: boolean;
	clone() : LocalizationImportDialogueSettings;
	static C(Other: UObject | any): LocalizationImportDialogueSettings;
}

declare class CultureStatistics { 
	CultureName: string;
	WordCount: any;
	clone() : CultureStatistics;
	static C(Other: UObject | any): CultureStatistics;
}

declare class LocalizationTargetSettings { 
	Name: string;
	Guid: Guid;
	ConflictStatus: ELocalizationTargetConflictStatus;
	TargetDependencies: Guid[];
	AdditionalManifestDependencies: FilePath[];
	RequiredModuleNames: string[];
	GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
	GatherFromPackages: GatherTextFromPackagesConfiguration;
	GatherFromMetaData: GatherTextFromMetaDataConfiguration;
	ExportSettings: LocalizationExportingSettings;
	CompileSettings: LocalizationCompilationSettings;
	ImportDialogueSettings: LocalizationImportDialogueSettings;
	NativeCultureIndex: number;
	SupportedCulturesStatistics: CultureStatistics[];
	clone() : LocalizationTargetSettings;
	static C(Other: UObject | any): LocalizationTargetSettings;
}

declare class LocalizationTarget extends UObject { 
	Settings: LocalizationTargetSettings;
	static Load(ResourceName: string): LocalizationTarget;
	static Find(Outer: UObject, ResourceName: string): LocalizationTarget;
	static GetDefaultObject(): LocalizationTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTarget;
	static C(Other: UObject | any): LocalizationTarget;
}

declare class LocalizationTargetSet extends UObject { 
	TargetObjects: LocalizationTarget[];
	static Load(ResourceName: string): LocalizationTargetSet;
	static Find(Outer: UObject, ResourceName: string): LocalizationTargetSet;
	static GetDefaultObject(): LocalizationTargetSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTargetSet;
	static C(Other: UObject | any): LocalizationTargetSet;
}

declare class LocalizationSettings extends UObject { 
	EngineTargetSet: LocalizationTargetSet;
	EngineTargetsSettings: LocalizationTargetSettings[];
	GameTargetSet: LocalizationTargetSet;
	GameTargetsSettings: LocalizationTargetSettings[];
	static Load(ResourceName: string): LocalizationSettings;
	static Find(Outer: UObject, ResourceName: string): LocalizationSettings;
	static GetDefaultObject(): LocalizationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationSettings;
	static C(Other: UObject | any): LocalizationSettings;
}

declare class InternationalizationExportSettings extends UObject { 
	CulturesToGenerate: string[];
	CommandletClass: string;
	SourcePath: string;
	DestinationPath: string;
	PortableObjectName: string;
	ManifestName: string;
	ArchiveName: string;
	bExportLoc: boolean;
	bImportLoc: boolean;
	bUseCultureDirectory: boolean;
	static Load(ResourceName: string): InternationalizationExportSettings;
	static Find(Outer: UObject, ResourceName: string): InternationalizationExportSettings;
	static GetDefaultObject(): InternationalizationExportSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationExportSettings;
	static C(Other: UObject | any): InternationalizationExportSettings;
}

declare class TranslationPickerSettings extends UObject { 
	bSubmitTranslationPickerChangesToLocalizationService: boolean;
	static Load(ResourceName: string): TranslationPickerSettings;
	static Find(Outer: UObject, ResourceName: string): TranslationPickerSettings;
	static GetDefaultObject(): TranslationPickerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationPickerSettings;
	static C(Other: UObject | any): TranslationPickerSettings;
}

declare class DateTime { 
	clone() : DateTime;
	static C(Other: UObject | any): DateTime;
	AsDate_DateTime(): string;
	AsDateTime_DateTime(): string;
	AsTime_DateTime(): string;
	AsTimeZoneDate_DateTime(InTimeZone: string): string;
	AsTimeZoneDateTime_DateTime(InTimeZone: string): string;
	AsTimeZoneTime_DateTime(InTimeZone: string): string;
	Add_DateTimeDateTime(B: DateTime): DateTime;
	Add_DateTimeTimespan(B: Timespan): DateTime;
	BreakDateTime(Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	EqualEqual_DateTimeDateTime(B: DateTime): boolean;
	GetDate(): DateTime;
	GetDay(): number;
	GetDayOfYear(): number;
	GetHour(): number;
	GetHour12(): number;
	GetMillisecond(): number;
	GetMinute(): number;
	GetMonth(): number;
	GetSecond(): number;
	GetTimeOfDay(): Timespan;
	GetYear(): number;
	Greater_DateTimeDateTime(B: DateTime): boolean;
	GreaterEqual_DateTimeDateTime(B: DateTime): boolean;
	IsAfternoon(): boolean;
	IsMorning(): boolean;
	Less_DateTimeDateTime(B: DateTime): boolean;
	LessEqual_DateTimeDateTime(B: DateTime): boolean;
	NotEqual_DateTimeDateTime(B: DateTime): boolean;
	Subtract_DateTimeDateTime(B: DateTime): Timespan;
	Subtract_DateTimeTimespan(B: Timespan): DateTime;
	ScheduleLocalNotificationAtTime(LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	ScheduleLocalNotificationBadgeAtTime(LocalTime: boolean,ActivationEvent: string): number;
	static AsDate_DateTime(InDateTime: DateTime): string;
	static AsDateTime_DateTime(In: DateTime): string;
	static AsTime_DateTime(In: DateTime): string;
	static AsTimeZoneDate_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneDateTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static Add_DateTimeDateTime(A: DateTime,B: DateTime): DateTime;
	static Add_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static BreakDateTime(InDateTime: DateTime,Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	static EqualEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GetDate(A: DateTime): DateTime;
	static GetDay(A: DateTime): number;
	static GetDayOfYear(A: DateTime): number;
	static GetHour(A: DateTime): number;
	static GetHour12(A: DateTime): number;
	static GetMillisecond(A: DateTime): number;
	static GetMinute(A: DateTime): number;
	static GetMonth(A: DateTime): number;
	static GetSecond(A: DateTime): number;
	static GetTimeOfDay(A: DateTime): Timespan;
	static GetYear(A: DateTime): number;
	static Greater_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GreaterEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static IsAfternoon(A: DateTime): boolean;
	static IsMorning(A: DateTime): boolean;
	static Less_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static LessEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static NotEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static Subtract_DateTimeDateTime(A: DateTime,B: DateTime): Timespan;
	static Subtract_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static ScheduleLocalNotificationAtTime(FireDateTime: DateTime,LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	static ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime,LocalTime: boolean,ActivationEvent: string): number;
	static DateTimeMaxValue(): DateTime;
	static DateTimeMinValue(): DateTime;
	static MakeDateTime(Year: number,Month: number,Day: number,Hour: number,Minute: number,Second: number,Millisecond: number): DateTime;
	static Now(): DateTime;
	static Today(): DateTime;
	static UtcNow(): DateTime;
}

declare class TranslationChange { 
	Version: string;
	DateAndTime: DateTime;
	Source: string;
	Translation: string;
	clone() : TranslationChange;
	static C(Other: UObject | any): TranslationChange;
}

declare class TranslationContextInfo { 
	Key: string;
	Context: string;
	Changes: TranslationChange[];
	clone() : TranslationContextInfo;
	static C(Other: UObject | any): TranslationContextInfo;
}

declare class TranslationUnit extends UObject { 
	Namespace: string;
	Key: string;
	Source: string;
	Translation: string;
	Contexts: TranslationContextInfo[];
	HasBeenReviewed: boolean;
	TranslationBeforeImport: string;
	LocresPath: string;
	static Load(ResourceName: string): TranslationUnit;
	static Find(Outer: UObject, ResourceName: string): TranslationUnit;
	static GetDefaultObject(): TranslationUnit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationUnit;
	static C(Other: UObject | any): TranslationUnit;
}

declare class CookerStats extends UObject { 
	Assets: any[];
	SizeBefore: number;
	SizeAfter: number;
	Path: string;
	static Load(ResourceName: string): CookerStats;
	static Find(Outer: UObject, ResourceName: string): CookerStats;
	static GetDefaultObject(): CookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerStats;
	static C(Other: UObject | any): CookerStats;
}

declare class LightingBuildInfo extends UObject { 
	UObject: any;
	LightingTime: number;
	UnmappedTexelsPercentage: number;
	UnmappedTexelsMemory: number;
	TotalTexelMemory: number;
	LevelName: string;
	static Load(ResourceName: string): LightingBuildInfo;
	static Find(Outer: UObject, ResourceName: string): LightingBuildInfo;
	static GetDefaultObject(): LightingBuildInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightingBuildInfo;
	static C(Other: UObject | any): LightingBuildInfo;
}

declare class PrimitiveStats extends UObject { 
	UObject: any;
	Actors: any[];
	Type: string;
	Count: number;
	Sections: number;
	HWInstances: number;
	InstSections: number;
	Triangles: number;
	InstTriangles: number;
	ResourceSize: number;
	VertexColorMem: number;
	InstVertexColorMem: number;
	LightsLM: number;
	LightsOther: number;
	LightsTotal: number;
	ObjLightCost: number;
	LightMapData: number;
	LMSMResolution: number;
	RadiusMin: number;
	RadiusMax: number;
	RadiusAvg: number;
	static Load(ResourceName: string): PrimitiveStats;
	static Find(Outer: UObject, ResourceName: string): PrimitiveStats;
	static GetDefaultObject(): PrimitiveStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveStats;
	static C(Other: UObject | any): PrimitiveStats;
}

declare class ShaderCookerStats extends UObject { 
	Name: string;
	Platform: string;
	Category: string;
	Compiled: number;
	Cooked: number;
	Permutations: number;
	CompileTime: number;
	Path: string;
	static Load(ResourceName: string): ShaderCookerStats;
	static Find(Outer: UObject, ResourceName: string): ShaderCookerStats;
	static GetDefaultObject(): ShaderCookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderCookerStats;
	static C(Other: UObject | any): ShaderCookerStats;
}

declare class StaticMeshLightingInfo extends UObject { 
	StaticMeshActor: any;
	StaticMesh: any;
	LevelName: string;
	TextureMapping: string;
	bTextureMapping: boolean;
	bHasLightmapTexCoords: boolean;
	StaticLightingResolution: number;
	TextureLightMapMemoryUsage: number;
	VertexLightMapMemoryUsage: number;
	LightMapLightCount: number;
	TextureShadowMapMemoryUsage: number;
	VertexShadowMapMemoryUsage: number;
	ShadowMapLightCount: number;
	LightmapTextureNames: string[];
	static Load(ResourceName: string): StaticMeshLightingInfo;
	static Find(Outer: UObject, ResourceName: string): StaticMeshLightingInfo;
	static GetDefaultObject(): StaticMeshLightingInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshLightingInfo;
	static C(Other: UObject | any): StaticMeshLightingInfo;
}

declare class TextureStats extends UObject { 
	Texture: any;
	Actors: any[];
	Type: string;
	Virtual: string;
	MaxDim: Vector2D;
	CurrentDim: Vector2D;
	Format: EPixelFormat;
	Group: TextureGroup;
	LODBias: number;
	CurrentKB: number;
	FullyLoadedKB: number;
	NumUses: number;
	LastTimeRendered: number;
	Path: string;
	static Load(ResourceName: string): TextureStats;
	static Find(Outer: UObject, ResourceName: string): TextureStats;
	static GetDefaultObject(): TextureStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureStats;
	static C(Other: UObject | any): TextureStats;
}

declare class Commandlet extends UObject { 
	HelpDescription: string;
	HelpUsage: string;
	HelpWebLink: string;
	HelpParamNames: string[];
	HelpParamDescriptions: string[];
	IsServer: boolean;
	IsClient: boolean;
	IsEditor: boolean;
	LogToConsole: boolean;
	ShowErrorCount: boolean;
	ShowProgress: boolean;
	static Load(ResourceName: string): Commandlet;
	static Find(Outer: UObject, ResourceName: string): Commandlet;
	static GetDefaultObject(): Commandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Commandlet;
	static C(Other: UObject | any): Commandlet;
}

declare class CheckAndroidDeviceProfileCommandlet extends Commandlet { 
	static Load(ResourceName: string): CheckAndroidDeviceProfileCommandlet;
	static Find(Outer: UObject, ResourceName: string): CheckAndroidDeviceProfileCommandlet;
	static GetDefaultObject(): CheckAndroidDeviceProfileCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckAndroidDeviceProfileCommandlet;
	static C(Other: UObject | any): CheckAndroidDeviceProfileCommandlet;
}

declare class EditorConfigBase extends UObject { 
	static Load(ResourceName: string): EditorConfigBase;
	static Find(Outer: UObject, ResourceName: string): EditorConfigBase;
	static GetDefaultObject(): EditorConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigBase;
	static C(Other: UObject | any): EditorConfigBase;
}

declare class EditorConfigSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): EditorConfigSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorConfigSubsystem;
	static GetDefaultObject(): EditorConfigSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigSubsystem;
	static C(Other: UObject | any): EditorConfigSubsystem;
}

declare class EditorConfigTestStruct { 
	BoolProperty: boolean;
	IntProperty: number;
	StringProperty: string;
	FloatProperty: number;
	ArrayProperty: string[];
	clone() : EditorConfigTestStruct;
	static C(Other: UObject | any): EditorConfigTestStruct;
}

declare class EditorConfigTestObject extends UObject { 
	UObject: UObject;
	SoftObjectPath: SoftObjectPath;
	struct: EditorConfigTestStruct;
	Number: number;
	static Load(ResourceName: string): EditorConfigTestObject;
	static Find(Outer: UObject, ResourceName: string): EditorConfigTestObject;
	static GetDefaultObject(): EditorConfigTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigTestObject;
	static C(Other: UObject | any): EditorConfigTestObject;
}

declare class EditorMetadataOverrides extends EditorSubsystem { 
	static Load(ResourceName: string): EditorMetadataOverrides;
	static Find(Outer: UObject, ResourceName: string): EditorMetadataOverrides;
	static GetDefaultObject(): EditorMetadataOverrides;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorMetadataOverrides;
	static C(Other: UObject | any): EditorMetadataOverrides;
}

declare class ActorBrowsingModeSettings extends UObject { 
	bHideTemporaryActors: boolean;
	bShowOnlyActorsInCurrentLevel: boolean;
	bShowOnlySelectedActors: boolean;
	bHideActorComponents: boolean;
	bHideLevelInstanceHierarchy: boolean;
	bHideUnloadedActors: boolean;
	static Load(ResourceName: string): ActorBrowsingModeSettings;
	static Find(Outer: UObject, ResourceName: string): ActorBrowsingModeSettings;
	static GetDefaultObject(): ActorBrowsingModeSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorBrowsingModeSettings;
	static C(Other: UObject | any): ActorBrowsingModeSettings;
}

declare class OutlinerConfig extends EditorConfigBase { 
	Outliners: any;
	static Load(ResourceName: string): OutlinerConfig;
	static Find(Outer: UObject, ResourceName: string): OutlinerConfig;
	static GetDefaultObject(): OutlinerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OutlinerConfig;
	static C(Other: UObject | any): OutlinerConfig;
}

declare class SceneOutlinerMenuContext extends UObject { 
	static Load(ResourceName: string): SceneOutlinerMenuContext;
	static Find(Outer: UObject, ResourceName: string): SceneOutlinerMenuContext;
	static GetDefaultObject(): SceneOutlinerMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneOutlinerMenuContext;
	static C(Other: UObject | any): SceneOutlinerMenuContext;
}

declare class CameraRig_Crane extends Actor { 
	CranePitch: number;
	CraneYaw: number;
	CraneArmLength: number;
	bLockMountPitch: boolean;
	bLockMountYaw: boolean;
	TransformComponent: SceneComponent;
	CraneYawControl: SceneComponent;
	CranePitchControl: SceneComponent;
	CraneCameraMount: SceneComponent;
	PreviewMesh_CraneArm: StaticMeshComponent;
	PreviewMesh_CraneBase: StaticMeshComponent;
	PreviewMesh_CraneMount: StaticMeshComponent;
	PreviewMesh_CraneCounterWeight: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Crane;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Crane;
	static C(Other: UObject | any): CameraRig_Crane;
}

declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointQuat;
	static C(Other: UObject | any): InterpCurvePointQuat;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveQuat;
	static C(Other: UObject | any): InterpCurveQuat;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointFloat;
	static C(Other: UObject | any): InterpCurvePointFloat;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveFloat;
	static C(Other: UObject | any): InterpCurveFloat;
}

declare class SplineMetadata extends UObject { 
	static Load(ResourceName: string): SplineMetadata;
	static Find(Outer: UObject, ResourceName: string): SplineMetadata;
	static GetDefaultObject(): SplineMetadata;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadata;
	static C(Other: UObject | any): SplineMetadata;
}

declare class SplineCurves { 
	position: InterpCurveVector;
	Rotation: InterpCurveQuat;
	Scale: InterpCurveVector;
	ReparamTable: InterpCurveFloat;
	MetaData: SplineMetadata;
	Version: any;
	clone() : SplineCurves;
	static C(Other: UObject | any): SplineCurves;
}

declare type ESplineCoordinateSpace = 'Local' | 'World' | 'ESplineCoordinateSpace_MAX';
declare var ESplineCoordinateSpace : { Local:'Local',World:'World',ESplineCoordinateSpace_MAX:'ESplineCoordinateSpace_MAX', };
declare type ESplinePointType = 'Linear' | 'Curve' | 'Constant' | 'CurveClamped' | 'CurveCustomTangent' | 'ESplinePointType_MAX';
declare var ESplinePointType : { Linear:'Linear',Curve:'Curve',Constant:'Constant',CurveClamped:'CurveClamped',CurveCustomTangent:'CurveCustomTangent',ESplinePointType_MAX:'ESplinePointType_MAX', };
declare class SplinePoint { 
	InputKey: number;
	position: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	Rotation: Rotator;
	Scale: Vector;
	Type: ESplinePointType;
	clone() : SplinePoint;
	static C(Other: UObject | any): SplinePoint;
}

declare class SplineComponent extends PrimitiveComponent { 
	SplineCurves: SplineCurves;
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bModifiedByConstructionScript: boolean;
	bInputSplinePointsToConstructionScript: boolean;
	bDrawDebug: boolean;
	bClosedLoop: boolean;
	bLoopPositionOverride: boolean;
	LoopPosition: number;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	EditorTangentColor: LinearColor;
	bAllowDiscontinuousSpline: boolean;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	static Load(ResourceName: string): SplineComponent;
	static Find(Outer: UObject, ResourceName: string): SplineComponent;
	static GetDefaultObject(): SplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	UpdateSpline(): void;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUpVectorAtSplinePoint(PointIndex: number,InUpVector: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentsAtSplinePoint(PointIndex: number,InArriveTangent: Vector,InLeaveTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetTangentColor(TangentColor: LinearColor): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType,bUpdateSpline: boolean): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetScaleAtSplinePoint(PointIndex: number,InScaleVector: Vector,bUpdateSpline: boolean): void;
	SetRotationAtSplinePoint(PointIndex: number,InRotation: Rotator,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetDrawDebug(bShow: boolean): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoopAtPosition(bInClosedLoop: boolean,Key: number,bUpdateSpline: boolean): void;
	SetClosedLoop(bInClosedLoop: boolean,bUpdateSpline: boolean): void;
	RemoveSplinePoint(index: number,bUpdateSpline: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetVectorPropertyAtSplinePoint(index: number,PropertyName: string): Vector;
	GetVectorPropertyAtSplineInputKey(InKey: number,PropertyName: string): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtSplineInputKey(InKey: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetNumberOfSplineSegments(): number;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetLeaveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetFloatPropertyAtSplinePoint(index: number,PropertyName: string): number;
	GetFloatPropertyAtSplineInputKey(InKey: number,PropertyName: string): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDistanceAlongSplineAtSplineInputKey(InKey: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetArriveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindUpVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindTransformClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	FindTangentClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
	FindRotationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	FindRollClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): number;
	FindRightVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindLocationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
	FindDirectionClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	DivideSplineIntoPolylineRecursive(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineToPolyLine(CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineSegmentToPolyLine(SplinePointStartIndex: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ClearSplinePoints(bUpdateSpline: boolean): void;
	AddSplineWorldPoint(position: Vector): void;
	AddSplinePointAtIndex(position: Vector,index: number,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplinePoint(position: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplineLocalPoint(position: Vector): void;
	AddPoints(Points: SplinePoint[],bUpdateSpline: boolean): void;
	AddPoint(Point: SplinePoint,bUpdateSpline: boolean): void;
	static C(Other: UObject | any): SplineComponent;
}

declare class SplineMeshParams { 
	StartPos: Vector;
	StartTangent: Vector;
	StartScale: Vector2D;
	StartRoll: number;
	StartOffset: Vector2D;
	EndPos: Vector;
	EndScale: Vector2D;
	EndTangent: Vector;
	EndRoll: number;
	EndOffset: Vector2D;
	clone() : SplineMeshParams;
	static C(Other: UObject | any): SplineMeshParams;
}

declare type ESplineMeshAxis = 'X' | 'Y' | 'Z' | 'ESplineMeshAxis_MAX';
declare var ESplineMeshAxis : { X:'X',Y:'Y',Z:'Z',ESplineMeshAxis_MAX:'ESplineMeshAxis_MAX', };
declare class SplineMeshComponent extends StaticMeshComponent { 
	SplineParams: SplineMeshParams;
	SplineUpDir: Vector;
	SplineBoundaryMin: number;
	CachedMeshBodySetupGuid: Guid;
	BodySetup: BodySetup;
	SplineBoundaryMax: number;
	bAllowSplineEditingPerInstance: boolean;
	bSmoothInterpRollScale: boolean;
	bMeshDirty: boolean;
	ForwardAxis: ESplineMeshAxis;
	VirtualTextureMainPassMaxDrawDistance: number;
	bSelected: boolean;
	static Load(ResourceName: string): SplineMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SplineMeshComponent;
	static GetDefaultObject(): SplineMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshComponent;
	UpdateMesh(): void;
	SetStartTangent(StartTangent: Vector,bUpdateMesh: boolean): void;
	SetStartScale(StartScale: Vector2D,bUpdateMesh: boolean): void;
	SetStartRoll(StartRoll: number,bUpdateMesh: boolean): void;
	SetStartPosition(StartPos: Vector,bUpdateMesh: boolean): void;
	SetStartOffset(StartOffset: Vector2D,bUpdateMesh: boolean): void;
	SetStartAndEnd(StartPos: Vector,StartTangent: Vector,EndPos: Vector,EndTangent: Vector,bUpdateMesh: boolean): void;
	SetSplineUpDir(InSplineUpDir: Vector,bUpdateMesh: boolean): void;
	SetForwardAxis(InForwardAxis: ESplineMeshAxis,bUpdateMesh: boolean): void;
	SetEndTangent(EndTangent: Vector,bUpdateMesh: boolean): void;
	SetEndScale(EndScale: Vector2D,bUpdateMesh: boolean): void;
	SetEndRoll(EndRoll: number,bUpdateMesh: boolean): void;
	SetEndPosition(EndPos: Vector,bUpdateMesh: boolean): void;
	SetEndOffset(EndOffset: Vector2D,bUpdateMesh: boolean): void;
	SetBoundaryMin(InBoundaryMin: number,bUpdateMesh: boolean): void;
	SetBoundaryMax(InBoundaryMax: number,bUpdateMesh: boolean): void;
	GetStartTangent(): Vector;
	GetStartScale(): Vector2D;
	GetStartRoll(): number;
	GetStartPosition(): Vector;
	GetStartOffset(): Vector2D;
	GetSplineUpDir(): Vector;
	GetForwardAxis(): ESplineMeshAxis;
	GetEndTangent(): Vector;
	GetEndScale(): Vector2D;
	GetEndRoll(): number;
	GetEndPosition(): Vector;
	GetEndOffset(): Vector2D;
	GetBoundaryMin(): number;
	GetBoundaryMax(): number;
	static C(Other: UObject | any): SplineMeshComponent;
}

declare class CameraRig_Rail extends Actor { 
	CurrentPositionOnRail: number;
	bLockOrientationToRail: boolean;
	bShowRailVisualization: boolean;
	PreviewMeshScale: number;
	TransformComponent: SceneComponent;
	RailSplineComponent: SplineComponent;
	RailCameraMount: SceneComponent;
	PreviewMesh_Rail: SplineMeshComponent;
	PreviewRailMeshSegments: SplineMeshComponent[];
	PreviewRailStaticMesh: StaticMesh;
	PreviewMesh_Mount: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Rail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Rail;
	GetRailSplineComponent(): SplineComponent;
	static C(Other: UObject | any): CameraRig_Rail;
}

declare class CameraLookatTrackingSettings { 
	bEnableLookAtTracking: boolean;
	bDrawDebugLookAtTrackingPosition: boolean;
	LookAtTrackingInterpSpeed: number;
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bAllowRoll: boolean;
	clone() : CameraLookatTrackingSettings;
	static C(Other: UObject | any): CameraLookatTrackingSettings;
}

declare class NamedFilmbackPreset { 
	Name: string;
	FilmbackSettings: CameraFilmbackSettings;
	clone() : NamedFilmbackPreset;
	static C(Other: UObject | any): NamedFilmbackPreset;
}

declare class NamedLensPreset { 
	Name: string;
	LensSettings: CameraLensSettings;
	clone() : NamedLensPreset;
	static C(Other: UObject | any): NamedLensPreset;
}

declare class CineCameraComponent extends CameraComponent { 
	FilmbackSettings: CameraFilmbackSettings;
	Filmback: CameraFilmbackSettings;
	LensSettings: CameraLensSettings;
	FocusSettings: CameraFocusSettings;
	CurrentFocalLength: number;
	CurrentAperture: number;
	CurrentFocusDistance: number;
	CurrentHorizontalFOV: number;
	FocusPlaneVisualizationMesh: StaticMesh;
	FocusPlaneVisualizationMaterial: Material;
	DebugFocusPlaneComponent: StaticMeshComponent;
	DebugFocusPlaneMID: MaterialInstanceDynamic;
	FilmbackPresets: NamedFilmbackPreset[];
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPresetName: string;
	DefaultFilmbackPreset: string;
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	static Load(ResourceName: string): CineCameraComponent;
	static Find(Outer: UObject, ResourceName: string): CineCameraComponent;
	static GetDefaultObject(): CineCameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraComponent;
	SetLensPresetByName(InPresetName: string): void;
	SetFilmbackPresetByName(InPresetName: string): void;
	SetCurrentFocalLength(InFocalLength: number): void;
	GetVerticalFieldOfView(): number;
	static GetLensPresetsCopy(): NamedLensPreset[];
	GetLensPresetName(): string;
	GetHorizontalFieldOfView(): number;
	static GetFilmbackPresetsCopy(): NamedFilmbackPreset[];
	GetFilmbackPresetName(): string;
	GetDefaultFilmbackPresetName(): string;
	static C(Other: UObject | any): CineCameraComponent;
}

declare class CineCameraActor extends CameraActor { 
	LookatTrackingSettings: CameraLookatTrackingSettings;
	static GetDefaultObject(): CineCameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraActor;
	GetCineCameraComponent(): CineCameraComponent;
	static C(Other: UObject | any): CineCameraActor;
}

declare class DataLayerEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): DataLayerEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): DataLayerEditorSubsystem;
	static GetDefaultObject(): DataLayerEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerEditorSubsystem;
	UpdateAllViewVisibility(DataLayerThatChanged: DataLayer): void;
	UpdateAllActorsVisibility(bNotifySelectionChange: boolean,bRedrawViewports: boolean): boolean;
	UpdateActorVisibility(Actor: Actor,bOutSelectionChanged?: boolean,bOutActorModified?: boolean,bNotifySelectionChange?: boolean,bRedrawViewports?: boolean): {bOutSelectionChanged: boolean, bOutActorModified: boolean, $: boolean};
	UpdateActorAllViewsVisibility(Actor: Actor): void;
	ToggleDataLayerVisibility(DataLayer: DataLayer): void;
	ToggleDataLayersVisibility(DataLayers: DataLayer[]): void;
	ToggleDataLayersIsLoadedInEditor(DataLayers: DataLayer[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsLoadedInEditor(DataLayer: DataLayer,bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsFromUserChange: boolean): boolean;
	SetParentDataLayer(DataLayer: DataLayer,ParentDataLayer: DataLayer): boolean;
	SetDataLayerVisibility(DataLayer: DataLayer,bIsVisible: boolean): void;
	SetDataLayersVisibility(DataLayers: DataLayer[],bIsVisible: boolean): void;
	SetDataLayersIsLoadedInEditor(DataLayers: DataLayer[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsLoadedInEditor(DataLayer: DataLayer,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SelectActorsInDataLayers(DataLayers: DataLayer[],bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	SelectActorsInDataLayer(DataLayer: DataLayer,bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	RenameDataLayer(DataLayer: DataLayer,NewDataLayerLabel: string): boolean;
	RemoveSelectedActorsFromDataLayers(DataLayers: DataLayer[]): boolean;
	RemoveSelectedActorsFromDataLayer(DataLayer: DataLayer): boolean;
	RemoveActorsFromDataLayers(Actors: Actor[],DataLayers: DataLayer[]): boolean;
	RemoveActorsFromDataLayer(Actors: Actor[],DataLayer: DataLayer): boolean;
	RemoveActorsFromAllDataLayers(Actors: Actor[]): boolean;
	RemoveActorFromDataLayers(Actor: Actor,DataLayers: DataLayer[]): boolean;
	RemoveActorFromDataLayer(Actor: Actor,DataLayerToRemove: DataLayer): boolean;
	RemoveActorFromAllDataLayers(Actor: Actor): boolean;
	MakeAllDataLayersVisible(): void;
	IsActorValidForDataLayer(Actor: Actor): boolean;
	GetDataLayerFromLabel(DataLayerLabel: string): DataLayer;
	GetDataLayer(ActorDataLayer: ActorDataLayer): DataLayer;
	GetActorsFromDataLayers(DataLayers: DataLayer[]): Actor[];
	GetActorsFromDataLayer(DataLayer: DataLayer): Actor[];
	DeleteDataLayers(DataLayersToDelete: DataLayer[]): void;
	DeleteDataLayer(DataLayerToDelete: DataLayer): void;
	CreateDataLayer(): DataLayer;
	AppendActorsFromDataLayers(DataLayers: DataLayer[],InOutActors?: Actor[]): {InOutActors: Actor[]};
	AppendActorsFromDataLayer(DataLayer: DataLayer,InOutActors?: Actor[]): {InOutActors: Actor[]};
	AddSelectedActorsToDataLayers(DataLayers: DataLayer[]): boolean;
	AddSelectedActorsToDataLayer(DataLayer: DataLayer): boolean;
	AddActorToDataLayers(Actor: Actor,DataLayers: DataLayer[]): boolean;
	AddActorToDataLayer(Actor: Actor,DataLayer: DataLayer): boolean;
	AddActorsToDataLayers(Actors: Actor[],DataLayers: DataLayer[]): boolean;
	AddActorsToDataLayer(Actors: Actor[],DataLayer: DataLayer): boolean;
	static C(Other: UObject | any): DataLayerEditorSubsystem;
}

declare class JsonUtilitiesDummyObject extends UObject { 
	static Load(ResourceName: string): JsonUtilitiesDummyObject;
	static Find(Outer: UObject, ResourceName: string): JsonUtilitiesDummyObject;
	static GetDefaultObject(): JsonUtilitiesDummyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonUtilitiesDummyObject;
	static C(Other: UObject | any): JsonUtilitiesDummyObject;
}

declare class LiveLinkRole extends UObject { 
	static Load(ResourceName: string): LiveLinkRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkRole;
	static GetDefaultObject(): LiveLinkRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkRole;
	static C(Other: UObject | any): LiveLinkRole;
}

declare class LiveLinkBasicRole extends LiveLinkRole { 
	static Load(ResourceName: string): LiveLinkBasicRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkBasicRole;
	static GetDefaultObject(): LiveLinkBasicRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkBasicRole;
	static C(Other: UObject | any): LiveLinkBasicRole;
}

declare class LiveLinkAnimationRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkAnimationRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkAnimationRole;
	static GetDefaultObject(): LiveLinkAnimationRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkAnimationRole;
	static C(Other: UObject | any): LiveLinkAnimationRole;
}

declare class LiveLinkTransformRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkTransformRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkTransformRole;
	static GetDefaultObject(): LiveLinkTransformRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkTransformRole;
	static C(Other: UObject | any): LiveLinkTransformRole;
}

declare class LiveLinkCameraRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkCameraRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCameraRole;
	static GetDefaultObject(): LiveLinkCameraRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCameraRole;
	static C(Other: UObject | any): LiveLinkCameraRole;
}

declare class LiveLinkController extends UObject { 
	static Load(ResourceName: string): LiveLinkController;
	static Find(Outer: UObject, ResourceName: string): LiveLinkController;
	static GetDefaultObject(): LiveLinkController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkController;
	static C(Other: UObject | any): LiveLinkController;
}

declare type ELiveLinkSourceMode = 'Latest' | 'EngineTime' | 'Timecode' | 'ELiveLinkSourceMode_MAX';
declare var ELiveLinkSourceMode : { Latest:'Latest',EngineTime:'EngineTime',Timecode:'Timecode',ELiveLinkSourceMode_MAX:'ELiveLinkSourceMode_MAX', };
declare class LiveLinkSourceBufferManagementSettings { 
	bValidEngineTimeEnabled: boolean;
	ValidEngineTime: number;
	EngineTimeOffset: number;
	EngineTimeClockOffset: any;
	SmoothEngineTimeOffset: any;
	TimecodeFrameRate: FrameRate;
	bGenerateSubFrame: boolean;
	DetectedFrameRate: FrameRate;
	bUseTimecodeSmoothLatest: boolean;
	SourceTimecodeFrameRate: FrameRate;
	bValidTimecodeFrameEnabled: boolean;
	ValidTimecodeFrame: number;
	TimecodeFrameOffset: number;
	TimecodeClockOffset: any;
	LatestOffset: number;
	MaxNumberOfFrameToBuffered: number;
	bKeepAtLeastOneFrame: boolean;
	clone() : LiveLinkSourceBufferManagementSettings;
	static C(Other: UObject | any): LiveLinkSourceBufferManagementSettings;
}

declare class LiveLinkSourceFactory extends UObject { 
	static Load(ResourceName: string): LiveLinkSourceFactory;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceFactory;
	static GetDefaultObject(): LiveLinkSourceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceFactory;
	static C(Other: UObject | any): LiveLinkSourceFactory;
}

declare class LiveLinkSubjectName { 
	Name: string;
	clone() : LiveLinkSubjectName;
	static C(Other: UObject | any): LiveLinkSubjectName;
}

declare class LiveLinkSourceDebugInfo { 
	SubjectName: LiveLinkSubjectName;
	SnapshotIndex: number;
	NumberOfBufferAtSnapshot: number;
	clone() : LiveLinkSourceDebugInfo;
	static C(Other: UObject | any): LiveLinkSourceDebugInfo;
}

declare class LiveLinkSourceSettings extends UObject { 
	Mode: ELiveLinkSourceMode;
	BufferSettings: LiveLinkSourceBufferManagementSettings;
	ConnectionString: string;
	Factory: UnrealEngineClass;
	SourceDebugInfos: LiveLinkSourceDebugInfo[];
	static Load(ResourceName: string): LiveLinkSourceSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceSettings;
	static GetDefaultObject(): LiveLinkSourceSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceSettings;
	static C(Other: UObject | any): LiveLinkSourceSettings;
}

declare class LiveLinkCurveConversionSettings { 
	CurveConversionAssetMap: any;
	clone() : LiveLinkCurveConversionSettings;
	static C(Other: UObject | any): LiveLinkCurveConversionSettings;
}

declare class LiveLinkCurveRemapSettings extends LiveLinkSourceSettings { 
	CurveConversionSettings: LiveLinkCurveConversionSettings;
	static Load(ResourceName: string): LiveLinkCurveRemapSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCurveRemapSettings;
	static GetDefaultObject(): LiveLinkCurveRemapSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCurveRemapSettings;
	static C(Other: UObject | any): LiveLinkCurveRemapSettings;
}

declare class LiveLinkFrameInterpolationProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static GetDefaultObject(): LiveLinkFrameInterpolationProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameInterpolationProcessor;
	static C(Other: UObject | any): LiveLinkFrameInterpolationProcessor;
}

declare class LiveLinkFramePreProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFramePreProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFramePreProcessor;
	static GetDefaultObject(): LiveLinkFramePreProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFramePreProcessor;
	static C(Other: UObject | any): LiveLinkFramePreProcessor;
}

declare class LiveLinkFrameTranslator extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameTranslator;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameTranslator;
	static GetDefaultObject(): LiveLinkFrameTranslator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameTranslator;
	static C(Other: UObject | any): LiveLinkFrameTranslator;
}

declare class LiveLinkLightRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkLightRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkLightRole;
	static GetDefaultObject(): LiveLinkLightRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkLightRole;
	static C(Other: UObject | any): LiveLinkLightRole;
}

declare class LiveLinkSubjectSettings extends UObject { 
	PreProcessors: LiveLinkFramePreProcessor[];
	InterpolationProcessor: LiveLinkFrameInterpolationProcessor;
	Translators: LiveLinkFrameTranslator[];
	Role: UnrealEngineClass;
	FrameRate: FrameRate;
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkSubjectSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSubjectSettings;
	static GetDefaultObject(): LiveLinkSubjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSubjectSettings;
	static C(Other: UObject | any): LiveLinkSubjectSettings;
}

declare class LiveLinkVirtualSubject extends UObject { 
	Role: UnrealEngineClass;
	Subjects: LiveLinkSubjectName[];
	FrameTranslators: LiveLinkFrameTranslator[];
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkVirtualSubject;
	static Find(Outer: UObject, ResourceName: string): LiveLinkVirtualSubject;
	static GetDefaultObject(): LiveLinkVirtualSubject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkVirtualSubject;
	static C(Other: UObject | any): LiveLinkVirtualSubject;
}

declare class SequenceRecordingBase extends UObject { 
	static Load(ResourceName: string): SequenceRecordingBase;
	static Find(Outer: UObject, ResourceName: string): SequenceRecordingBase;
	static GetDefaultObject(): SequenceRecordingBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecordingBase;
	static C(Other: UObject | any): SequenceRecordingBase;
}

declare class ActorRecordingSettings { 
	Settings: UObject[];
	clone() : ActorRecordingSettings;
	static C(Other: UObject | any): ActorRecordingSettings;
}

declare class AnimationRecordingSettings { 
	bRecordInWorldSpace: boolean;
	bRemoveRootAnimation: boolean;
	bAutoSaveAsset: boolean;
	SampleFrameRate: FrameRate;
	Length: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	bRecordTransforms: boolean;
	bRecordMorphTargets: boolean;
	bRecordAttributeCurves: boolean;
	bRecordMaterialCurves: boolean;
	clone() : AnimationRecordingSettings;
	static C(Other: UObject | any): AnimationRecordingSettings;
}

declare class ActorRecording extends SequenceRecordingBase { 
	ActorSettings: ActorRecordingSettings;
	bActive: boolean;
	bCreateLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	TargetName: string;
	TakeNumber: any;
	bSpecifyTargetAnimation: boolean;
	TargetAnimation: AnimSequence;
	AnimationSettings: AnimationRecordingSettings;
	bRecordToPossessable: boolean;
	ActorToRecord: Actor;
	static Load(ResourceName: string): ActorRecording;
	static Find(Outer: UObject, ResourceName: string): ActorRecording;
	static GetDefaultObject(): ActorRecording;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorRecording;
	static C(Other: UObject | any): ActorRecording;
}

declare class AnimationRecordingParameters extends UObject { 
	SampleFrameRate: FrameRate;
	bEndAfterDuration: boolean;
	MaximumDurationSeconds: number;
	SampleRate: number;
	static Load(ResourceName: string): AnimationRecordingParameters;
	static Find(Outer: UObject, ResourceName: string): AnimationRecordingParameters;
	static GetDefaultObject(): AnimationRecordingParameters;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationRecordingParameters;
	static C(Other: UObject | any): AnimationRecordingParameters;
}

declare class MovieScene3DTransformSectionRecorderSettings extends UObject { 
	bRecordTransforms: boolean;
	static Load(ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static GetDefaultObject(): MovieScene3DTransformSectionRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionRecorderSettings;
	static C(Other: UObject | any): MovieScene3DTransformSectionRecorderSettings;
}

declare class SequenceRecorderActorGroup extends UObject { 
	GroupName: string;
	SequenceName: string;
	SequenceRecordingBasePath: DirectoryPath;
	bSpecifyTargetLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	bDuplicateTargetLevelSequence: boolean;
	bRecordTargetLevelSequenceLength: boolean;
	RecordedActors: ActorRecording[];
	static Load(ResourceName: string): SequenceRecorderActorGroup;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderActorGroup;
	static GetDefaultObject(): SequenceRecorderActorGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderActorGroup;
	static C(Other: UObject | any): SequenceRecorderActorGroup;
}

declare class SequenceRecorderGroup extends Actor { 
	ActorGroups: SequenceRecorderActorGroup[];
	static GetDefaultObject(): SequenceRecorderGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderGroup;
	static C(Other: UObject | any): SequenceRecorderGroup;
}

declare class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceRecorderBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderBlueprintLibrary;
	static GetDefaultObject(): SequenceRecorderBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderBlueprintLibrary;
	static StopRecordingSequence(): void;
	static StartRecordingSequence(ActorsToRecord: Actor[]): void;
	static IsRecordingSequence(): boolean;
	static C(Other: UObject | any): SequenceRecorderBlueprintLibrary;
}

declare type EAudioRecordingMode = 'None' | 'AudioTrack' | 'EAudioRecordingMode_MAX';
declare var EAudioRecordingMode : { None:'None',AudioTrack:'AudioTrack',EAudioRecordingMode_MAX:'EAudioRecordingMode_MAX', };
declare class SequenceRecorderActorFilter { 
	ActorClassesToRecord: UnrealEngineClass[];
	clone() : SequenceRecorderActorFilter;
	static C(Other: UObject | any): SequenceRecorderActorFilter;
}

declare class PropertiesToRecordForClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForClass;
	static C(Other: UObject | any): PropertiesToRecordForClass;
}

declare class PropertiesToRecordForActorClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForActorClass;
	static C(Other: UObject | any): PropertiesToRecordForActorClass;
}

declare class SettingsForActorClass { 
	Class: UnrealEngineClass;
	bRecordToPossessable: boolean;
	clone() : SettingsForActorClass;
	static C(Other: UObject | any): SettingsForActorClass;
}

declare class SequenceRecorderSettings extends UObject { 
	bCreateLevelSequence: boolean;
	bImmersiveMode: boolean;
	SequenceLength: number;
	RecordingDelay: number;
	bAllowLooping: boolean;
	GlobalTimeDilation: number;
	bIgnoreTimeDilation: boolean;
	AnimationSubDirectory: string;
	RecordAudio: EAudioRecordingMode;
	AudioGain: number;
	bSplitAudioChannelsIntoSeparateTracks: boolean;
	bReplaceRecordedAudio: boolean;
	AudioTrackName: string;
	AudioSubDirectory: string;
	bRecordNearbySpawnedActors: boolean;
	NearbyActorRecordingProximity: number;
	bRecordWorldSettingsActor: boolean;
	bReduceKeys: boolean;
	bAutoSaveAsset: boolean;
	ActorFilter: SequenceRecorderActorFilter;
	LevelSequenceActorsToTrigger: any[];
	DefaultAnimationSettings: AnimationRecordingSettings;
	bRecordSequencerSpawnedActors: boolean;
	ClassesAndPropertiesToRecord: PropertiesToRecordForClass[];
	ActorsAndPropertiesToRecord: PropertiesToRecordForActorClass[];
	PerActorSettings: SettingsForActorClass[];
	static Load(ResourceName: string): SequenceRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderSettings;
	static GetDefaultObject(): SequenceRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderSettings;
	static C(Other: UObject | any): SequenceRecorderSettings;
}

declare type EMovieSceneCaptureProtocolState = 'Idle' | 'Initialized' | 'Capturing' | 'Finalizing' | 'EMovieSceneCaptureProtocolState_MAX';
declare var EMovieSceneCaptureProtocolState : { Idle:'Idle',Initialized:'Initialized',Capturing:'Capturing',Finalizing:'Finalizing',EMovieSceneCaptureProtocolState_MAX:'EMovieSceneCaptureProtocolState_MAX', };
declare class MovieSceneCaptureProtocolBase extends UObject { 
	State: EMovieSceneCaptureProtocolState;
	static Load(ResourceName: string): MovieSceneCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureProtocolBase;
	IsCapturing(): boolean;
	GetState(): EMovieSceneCaptureProtocolState;
	static C(Other: UObject | any): MovieSceneCaptureProtocolBase;
}

declare class MovieSceneAudioCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneAudioCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneAudioCaptureProtocolBase;
}

declare class NullAudioCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	static Load(ResourceName: string): NullAudioCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): NullAudioCaptureProtocol;
	static GetDefaultObject(): NullAudioCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullAudioCaptureProtocol;
	static C(Other: UObject | any): NullAudioCaptureProtocol;
}

declare class MasterAudioSubmixCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	Filename: string;
	static Load(ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static GetDefaultObject(): MasterAudioSubmixCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MasterAudioSubmixCaptureProtocol;
	static C(Other: UObject | any): MasterAudioSubmixCaptureProtocol;
}

declare class MovieSceneImageCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneImageCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneImageCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneImageCaptureProtocolBase;
}

declare class CompositionGraphCapturePasses { 
	Value: string[];
	clone() : CompositionGraphCapturePasses;
	static C(Other: UObject | any): CompositionGraphCapturePasses;
}

declare type EHDRCaptureGamut = 'HCGM_Rec709' | 'HCGM_P3DCI' | 'HCGM_Rec2020' | 'HCGM_ACES' | 'HCGM_ACEScg' | 'HCGM_Linear' | 'HCGM_MAX';
declare var EHDRCaptureGamut : { HCGM_Rec709:'HCGM_Rec709',HCGM_P3DCI:'HCGM_P3DCI',HCGM_Rec2020:'HCGM_Rec2020',HCGM_ACES:'HCGM_ACES',HCGM_ACEScg:'HCGM_ACEScg',HCGM_Linear:'HCGM_Linear',HCGM_MAX:'HCGM_MAX', };
declare class CompositionGraphCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	IncludeRenderPasses: CompositionGraphCapturePasses;
	bCaptureFramesInHDR: boolean;
	HDRCompressionQuality: number;
	CaptureGamut: EHDRCaptureGamut;
	PostProcessingMaterial: SoftObjectPath;
	bDisableScreenPercentage: boolean;
	PostProcessingMaterialPtr: MaterialInterface;
	static Load(ResourceName: string): CompositionGraphCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): CompositionGraphCaptureProtocol;
	static GetDefaultObject(): CompositionGraphCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositionGraphCaptureProtocol;
	static C(Other: UObject | any): CompositionGraphCaptureProtocol;
}

declare class FrameGrabberProtocol extends MovieSceneImageCaptureProtocolBase { 
	static Load(ResourceName: string): FrameGrabberProtocol;
	static Find(Outer: UObject, ResourceName: string): FrameGrabberProtocol;
	static GetDefaultObject(): FrameGrabberProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FrameGrabberProtocol;
	static C(Other: UObject | any): FrameGrabberProtocol;
}

declare class ImageSequenceProtocol extends FrameGrabberProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol;
	static GetDefaultObject(): ImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol;
	static C(Other: UObject | any): ImageSequenceProtocol;
}

declare class CompressedImageSequenceProtocol extends ImageSequenceProtocol { 
	CompressionQuality: number;
	static Load(ResourceName: string): CompressedImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): CompressedImageSequenceProtocol;
	static GetDefaultObject(): CompressedImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompressedImageSequenceProtocol;
	static C(Other: UObject | any): CompressedImageSequenceProtocol;
}

declare class ImageSequenceProtocol_BMP extends ImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_BMP;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_BMP;
	static GetDefaultObject(): ImageSequenceProtocol_BMP;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_BMP;
	static C(Other: UObject | any): ImageSequenceProtocol_BMP;
}

declare class ImageSequenceProtocol_PNG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_PNG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_PNG;
	static GetDefaultObject(): ImageSequenceProtocol_PNG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_PNG;
	static C(Other: UObject | any): ImageSequenceProtocol_PNG;
}

declare class ImageSequenceProtocol_JPG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_JPG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_JPG;
	static GetDefaultObject(): ImageSequenceProtocol_JPG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_JPG;
	static C(Other: UObject | any): ImageSequenceProtocol_JPG;
}

declare class ImageSequenceProtocol_EXR extends ImageSequenceProtocol { 
	bCompressed: boolean;
	CaptureGamut: EHDRCaptureGamut;
	static Load(ResourceName: string): ImageSequenceProtocol_EXR;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_EXR;
	static GetDefaultObject(): ImageSequenceProtocol_EXR;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_EXR;
	static C(Other: UObject | any): ImageSequenceProtocol_EXR;
}

declare class MovieSceneCaptureInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneCaptureInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureInterface;
	static GetDefaultObject(): MovieSceneCaptureInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureInterface;
	static C(Other: UObject | any): MovieSceneCaptureInterface;
}

declare class CaptureResolution { 
	ResX: number;
	ResY: number;
	clone() : CaptureResolution;
	static C(Other: UObject | any): CaptureResolution;
}

declare class MovieSceneCaptureSettings { 
	OutputDirectory: DirectoryPath;
	GameModeOverride: UnrealEngineClass;
	OutputFormat: string;
	bOverwriteExisting: boolean;
	bUseRelativeFrameNumbers: boolean;
	HandleFrames: number;
	MovieExtension: string;
	ZeroPadFrameNumbers: number;
	FrameRate: FrameRate;
	bUseCustomFrameRate: boolean;
	CustomFrameRate: FrameRate;
	Resolution: CaptureResolution;
	bEnableTextureStreaming: boolean;
	bCinematicEngineScalability: boolean;
	bCinematicMode: boolean;
	bAllowMovement: boolean;
	bAllowTurning: boolean;
	bShowPlayer: boolean;
	bShowHUD: boolean;
	bUsePathTracer: boolean;
	PathTracerSamplePerPixel: number;
	clone() : MovieSceneCaptureSettings;
	static C(Other: UObject | any): MovieSceneCaptureSettings;
}

declare class MovieSceneCapture extends UObject { 
	ImageCaptureProtocolType: SoftClassPath;
	AudioCaptureProtocolType: SoftClassPath;
	ImageCaptureProtocol: MovieSceneImageCaptureProtocolBase;
	AudioCaptureProtocol: MovieSceneAudioCaptureProtocolBase;
	Settings: MovieSceneCaptureSettings;
	bUseSeparateProcess: boolean;
	bCloseEditorWhenCaptureStarts: boolean;
	AdditionalCommandLineArguments: string;
	InheritedCommandLineArguments: string;
	static Load(ResourceName: string): MovieSceneCapture;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCapture;
	static GetDefaultObject(): MovieSceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCapture;
	SetImageCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	SetAudioCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	GetImageCaptureProtocol(): MovieSceneCaptureProtocolBase;
	GetAudioCaptureProtocol(): MovieSceneCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCapture;
	RenderMovie(OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
	static RenderMovie(InCaptureSettings: MovieSceneCapture,OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
}

declare class LevelCapture extends MovieSceneCapture { 
	bAutoStartCapture: boolean;
	PrerequisiteActorId: Guid;
	static Load(ResourceName: string): LevelCapture;
	static Find(Outer: UObject, ResourceName: string): LevelCapture;
	static GetDefaultObject(): LevelCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelCapture;
	static C(Other: UObject | any): LevelCapture;
}

declare class MovieSceneCaptureEnvironment extends UObject { 
	static Load(ResourceName: string): MovieSceneCaptureEnvironment;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureEnvironment;
	static GetDefaultObject(): MovieSceneCaptureEnvironment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureEnvironment;
	static IsCaptureInProgress(): boolean;
	static GetCaptureFrameNumber(): number;
	static GetCaptureElapsedTime(): number;
	static FindImageCaptureProtocol(): MovieSceneImageCaptureProtocolBase;
	static FindAudioCaptureProtocol(): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCaptureEnvironment;
}

declare class CapturedPixelsID { 
	Identifiers: any;
	clone() : CapturedPixelsID;
	static C(Other: UObject | any): CapturedPixelsID;
}

declare class CapturedPixels { 
	clone() : CapturedPixels;
	static C(Other: UObject | any): CapturedPixels;
}

declare class FrameMetrics { 
	TotalElapsedTime: number;
	FrameDelta: number;
	FrameNumber: number;
	NumDroppedFrames: number;
	clone() : FrameMetrics;
	static C(Other: UObject | any): FrameMetrics;
}

declare class UserDefinedCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	World: World;
	static Load(ResourceName: string): UserDefinedCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedCaptureProtocol;
	static GetDefaultObject(): UserDefinedCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedCaptureProtocol;
	StopCapturingFinalPixels(): void;
	StartCapturingFinalPixels(StreamID: CapturedPixelsID): void;
	ResolveBuffer(Buffer: Texture,BufferID: CapturedPixelsID): void;
	OnWarmUp(): void;
	OnTick(): void;
	OnStartCapture(): void;
	OnSetup(): boolean;
	OnPreTick(): void;
	OnPixelsReceived(Pixels: CapturedPixels,ID: CapturedPixelsID,FrameMetrics: FrameMetrics): void;
	OnPauseCapture(): void;
	OnFinalize(): void;
	OnCaptureFrame(): void;
	OnCanFinalize(): boolean;
	OnBeginFinalize(): void;
	GetCurrentFrameMetrics(): FrameMetrics;
	GenerateFilename(InFrameMetrics: FrameMetrics): string;
	static C(Other: UObject | any): UserDefinedCaptureProtocol;
}

declare class UserDefinedImageCaptureProtocol extends UserDefinedCaptureProtocol { 
	Format: EDesiredImageFormat;
	bEnableCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): UserDefinedImageCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedImageCaptureProtocol;
	static GetDefaultObject(): UserDefinedImageCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedImageCaptureProtocol;
	WriteImageToDisk(PixelData: CapturedPixels,StreamID: CapturedPixelsID,FrameMetrics: FrameMetrics,bCopyImageData: boolean): void;
	GenerateFilenameForCurrentFrame(): string;
	GenerateFilenameForBuffer(Buffer: Texture,StreamID: CapturedPixelsID): string;
	static C(Other: UObject | any): UserDefinedImageCaptureProtocol;
}

declare class VideoCaptureProtocol extends FrameGrabberProtocol { 
	bUseCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): VideoCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): VideoCaptureProtocol;
	static GetDefaultObject(): VideoCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VideoCaptureProtocol;
	static C(Other: UObject | any): VideoCaptureProtocol;
}

declare class LevelSequenceBurnInInitSettings extends UObject { 
	static Load(ResourceName: string): LevelSequenceBurnInInitSettings;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInInitSettings;
	static GetDefaultObject(): LevelSequenceBurnInInitSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInInitSettings;
	static C(Other: UObject | any): LevelSequenceBurnInInitSettings;
}

declare class LevelSequenceBurnInOptions extends UObject { 
	bUseBurnIn: boolean;
	BurnInClass: SoftClassPath;
	Settings: LevelSequenceBurnInInitSettings;
	static Load(ResourceName: string): LevelSequenceBurnInOptions;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInOptions;
	static GetDefaultObject(): LevelSequenceBurnInOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInOptions;
	SetBurnIn(InBurnInClass: SoftClassPath): void;
	static C(Other: UObject | any): LevelSequenceBurnInOptions;
}

declare class AutomatedLevelSequenceCapture extends MovieSceneCapture { 
	LevelSequenceAsset: SoftObjectPath;
	ShotName: string;
	bUseCustomStartFrame: boolean;
	CustomStartFrame: FrameNumber;
	bUseCustomEndFrame: boolean;
	CustomEndFrame: FrameNumber;
	WarmUpFrameCount: number;
	DelayBeforeWarmUp: number;
	DelayBeforeShotWarmUp: number;
	DelayEveryFrame: number;
	BurnInOptions: LevelSequenceBurnInOptions;
	bWriteEditDecisionList: boolean;
	bWriteFinalCutProXML: boolean;
	LevelSequenceActor: any;
	static Load(ResourceName: string): AutomatedLevelSequenceCapture;
	static Find(Outer: UObject, ResourceName: string): AutomatedLevelSequenceCapture;
	static GetDefaultObject(): AutomatedLevelSequenceCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedLevelSequenceCapture;
	static C(Other: UObject | any): AutomatedLevelSequenceCapture;
}

declare class BoolChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	bValue: boolean;
	static Load(ResourceName: string): BoolChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): BoolChannelKeyProxy;
	static GetDefaultObject(): BoolChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolChannelKeyProxy;
	static C(Other: UObject | any): BoolChannelKeyProxy;
}

declare class MovieSceneDoubleValue { 
	Value: any;
	Tangent: MovieSceneTangentData;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	PaddingByte: number;
	clone() : MovieSceneDoubleValue;
	static C(Other: UObject | any): MovieSceneDoubleValue;
}

declare class DoubleChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneDoubleValue;
	static Load(ResourceName: string): DoubleChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): DoubleChannelKeyProxy;
	static GetDefaultObject(): DoubleChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleChannelKeyProxy;
	static C(Other: UObject | any): DoubleChannelKeyProxy;
}

declare class FloatChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneFloatValue;
	static Load(ResourceName: string): FloatChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): FloatChannelKeyProxy;
	static GetDefaultObject(): FloatChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatChannelKeyProxy;
	static C(Other: UObject | any): FloatChannelKeyProxy;
}

declare class IntegerChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: number;
	static Load(ResourceName: string): IntegerChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): IntegerChannelKeyProxy;
	static GetDefaultObject(): IntegerChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntegerChannelKeyProxy;
	static C(Other: UObject | any): IntegerChannelKeyProxy;
}

declare class K2Node_GetSequenceBinding extends K2Node { 
	SourceSequence: SoftObjectPath;
	Binding: MovieSceneObjectBindingID;
	static Load(ResourceName: string): K2Node_GetSequenceBinding;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSequenceBinding;
	static GetDefaultObject(): K2Node_GetSequenceBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSequenceBinding;
	static C(Other: UObject | any): K2Node_GetSequenceBinding;
}

declare class MovieSceneEventBlueprintExtension extends BlueprintExtension { 
	EventSections: any[];
	static Load(ResourceName: string): MovieSceneEventBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEventBlueprintExtension;
	static GetDefaultObject(): MovieSceneEventBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventBlueprintExtension;
	static C(Other: UObject | any): MovieSceneEventBlueprintExtension;
}

declare class MovieSceneToolsPropertyTrackSettings { 
	ComponentName: string;
	PropertyName: string;
	clone() : MovieSceneToolsPropertyTrackSettings;
	static C(Other: UObject | any): MovieSceneToolsPropertyTrackSettings;
}

declare type EMovieSceneToolsPropertyTrackType = 'FloatTrack' | 'DoubleTrack' | 'EMovieSceneToolsPropertyTrackType_MAX';
declare var EMovieSceneToolsPropertyTrackType : { FloatTrack:'FloatTrack',DoubleTrack:'DoubleTrack',EMovieSceneToolsPropertyTrackType_MAX:'EMovieSceneToolsPropertyTrackType_MAX', };
declare class MovieSceneToolsFbxSettings { 
	FbxPropertyName: string;
	PropertyPath: MovieSceneToolsPropertyTrackSettings;
	PropertyType: EMovieSceneToolsPropertyTrackType;
	clone() : MovieSceneToolsFbxSettings;
	static C(Other: UObject | any): MovieSceneToolsFbxSettings;
}

declare class MovieSceneToolsProjectSettings extends UObject { 
	DefaultStartTime: number;
	DefaultDuration: number;
	ShotDirectory: string;
	ShotPrefix: string;
	FirstShotNumber: any;
	ShotIncrement: any;
	ShotNumDigits: any;
	TakeNumDigits: any;
	FirstTakeNumber: any;
	TakeSeparator: string;
	SubSequenceSeparator: string;
	FbxSettings: MovieSceneToolsFbxSettings[];
	static Load(ResourceName: string): MovieSceneToolsProjectSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneToolsProjectSettings;
	static GetDefaultObject(): MovieSceneToolsProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneToolsProjectSettings;
	static C(Other: UObject | any): MovieSceneToolsProjectSettings;
}

declare type EThumbnailQuality = 'Draft' | 'Normal' | 'Best' | 'EThumbnailQuality_MAX';
declare var EThumbnailQuality : { Draft:'Draft',Normal:'Normal',Best:'Best',EThumbnailQuality_MAX:'EThumbnailQuality_MAX', };
declare class MovieSceneUserThumbnailSettings extends UObject { 
	bDrawThumbnails: boolean;
	bDrawSingleThumbnails: boolean;
	ThumbnailSize: IntPoint;
	Quality: EThumbnailQuality;
	static Load(ResourceName: string): MovieSceneUserThumbnailSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserThumbnailSettings;
	static GetDefaultObject(): MovieSceneUserThumbnailSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserThumbnailSettings;
	static C(Other: UObject | any): MovieSceneUserThumbnailSettings;
}

declare class EditorWorldExtensionActorData { 
	Actor: Actor;
	bValidForPIE: boolean;
	clone() : EditorWorldExtensionActorData;
	static C(Other: UObject | any): EditorWorldExtensionActorData;
}

declare class EditorWorldExtension extends UObject { 
	ExtensionActors: EditorWorldExtensionActorData[];
	static Load(ResourceName: string): EditorWorldExtension;
	static Find(Outer: UObject, ResourceName: string): EditorWorldExtension;
	static GetDefaultObject(): EditorWorldExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorWorldExtension;
	static C(Other: UObject | any): EditorWorldExtension;
}

declare type EHitResultGizmoFilterMode = 'All' | 'NoGizmos' | 'GizmosOnly' | 'EHitResultGizmoFilterMode_MAX';
declare var EHitResultGizmoFilterMode : { All:'All',NoGizmos:'NoGizmos',GizmosOnly:'GizmosOnly',EHitResultGizmoFilterMode_MAX:'EHitResultGizmoFilterMode_MAX', };
declare type EViewportInteractionDraggingMode = 'Nothing' | 'TransformablesWithGizmo' | 'TransformablesAtLaserImpact' | 'AssistingDrag' | 'TransformablesFreely' | 'World' | 'Interactable' | 'Material' | 'EViewportInteractionDraggingMode_MAX';
declare var EViewportInteractionDraggingMode : { Nothing:'Nothing',TransformablesWithGizmo:'TransformablesWithGizmo',TransformablesAtLaserImpact:'TransformablesAtLaserImpact',AssistingDrag:'AssistingDrag',TransformablesFreely:'TransformablesFreely',World:'World',Interactable:'Interactable',Material:'Material',EViewportInteractionDraggingMode_MAX:'EViewportInteractionDraggingMode_MAX', };
declare class ViewportActionKeyInput { 
	ActionType: string;
	Event: EInputEvent;
	bIsInputCaptured: boolean;
	clone() : ViewportActionKeyInput;
	static C(Other: UObject | any): ViewportActionKeyInput;
}

declare class ViewportInteractor extends UObject { 
	KeyToActionMap: any;
	WorldInteraction: ViewportWorldInteraction;
	OtherInteractor: ViewportInteractor;
	static Load(ResourceName: string): ViewportInteractor;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractor;
	static GetDefaultObject(): ViewportInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractor;
	Tick(DeltaTime: number): void;
	Shutdown(): void;
	SetHitResultGizmoFilterMode(newFilter: EHitResultGizmoFilterMode): void;
	SetDraggingMode(NewDraggingMode: EViewportInteractionDraggingMode): void;
	SetCanCarry(bInCanCarry: boolean): void;
	IsHoveringOverGizmo(): boolean;
	HandleInputKey_BP(Action: ViewportActionKeyInput,Key: Key,Event: EInputEvent,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	HandleInputAxis_BP(Action: ViewportActionKeyInput,Key: Key,Delta: number,DeltaTime: number,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	GetWorldInteraction(): ViewportWorldInteraction;
	GetTransformAndForwardVector(OutHandTransform?: Transform,OutForwardVector?: Vector): {OutHandTransform: Transform, OutForwardVector: Vector, $: boolean};
	GetTransform(): Transform;
	GetRoomSpaceTransform(): Transform;
	GetOtherInteractor(): ViewportInteractor;
	GetLastTransform(): Transform;
	GetLastRoomSpaceTransform(): Transform;
	GetLaserPointer(LaserPointerStart?: Vector,LaserPointerEnd?: Vector,bEvenIfBlocked?: boolean,LaserLengthOverride?: number): {LaserPointerStart: Vector, LaserPointerEnd: Vector, $: boolean};
	GetHoverLocation(): Vector;
	GetHitResultGizmoFilterMode(): EHitResultGizmoFilterMode;
	GetDraggingMode(): EViewportInteractionDraggingMode;
	CanCarry(): boolean;
	static C(Other: UObject | any): ViewportInteractor;
}

declare class GizmoHandle { 
	clone() : GizmoHandle;
	static C(Other: UObject | any): GizmoHandle;
}

declare class ViewportDragOperation extends UObject { 
	static Load(ResourceName: string): ViewportDragOperation;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperation;
	static GetDefaultObject(): ViewportDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperation;
	static C(Other: UObject | any): ViewportDragOperation;
}

declare class ViewportDragOperationComponent extends ActorComponent { 
	DragOperation: ViewportDragOperation;
	DragOperationSubclass: UnrealEngineClass;
	static Load(ResourceName: string): ViewportDragOperationComponent;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperationComponent;
	static GetDefaultObject(): ViewportDragOperationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperationComponent;
	static C(Other: UObject | any): ViewportDragOperationComponent;
}

declare class GizmoHandleGroup extends SceneComponent { 
	GizmoMaterial: MaterialInterface;
	TranslucentGizmoMaterial: MaterialInterface;
	Handles: GizmoHandle[];
	OwningTransformGizmoActor: BaseTransformGizmo;
	DragOperationComponent: ViewportDragOperationComponent;
	static Load(ResourceName: string): GizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleGroup;
	static GetDefaultObject(): GizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleGroup;
	static C(Other: UObject | any): GizmoHandleGroup;
}

declare class BaseTransformGizmo extends Actor { 
	SceneComponent: SceneComponent;
	AllHandleGroups: GizmoHandleGroup[];
	WorldInteraction: ViewportWorldInteraction;
	static GetDefaultObject(): BaseTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseTransformGizmo;
	static C(Other: UObject | any): BaseTransformGizmo;
}

declare class MouseCursorInteractor extends ViewportInteractor { 
	static Load(ResourceName: string): MouseCursorInteractor;
	static Find(Outer: UObject, ResourceName: string): MouseCursorInteractor;
	static GetDefaultObject(): MouseCursorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorInteractor;
	static C(Other: UObject | any): MouseCursorInteractor;
}

declare class ViewportInteractionAssetContainer extends DataAsset { 
	GizmoHandleSelectedSound: SoundBase;
	GizmoHandleDropSound: SoundBase;
	SelectionChangeSound: SoundBase;
	SelectionDropSound: SoundBase;
	SelectionStartDragSound: SoundBase;
	GridSnapSound: SoundBase;
	ActorSnapSound: SoundBase;
	UndoSound: SoundBase;
	RedoSound: SoundBase;
	GridMesh: StaticMesh;
	TranslationHandleMesh: StaticMesh;
	UniformScaleHandleMesh: StaticMesh;
	ScaleHandleMesh: StaticMesh;
	PlaneTranslationHandleMesh: StaticMesh;
	RotationHandleMesh: StaticMesh;
	RotationHandleSelectedMesh: StaticMesh;
	StartRotationIndicatorMesh: StaticMesh;
	CurrentRotationIndicatorMesh: StaticMesh;
	FreeRotationHandleMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	TransformGizmoMaterial: MaterialInterface;
	TranslucentTransformGizmoMaterial: MaterialInterface;
	static Load(ResourceName: string): ViewportInteractionAssetContainer;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractionAssetContainer;
	static GetDefaultObject(): ViewportInteractionAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractionAssetContainer;
	static C(Other: UObject | any): ViewportInteractionAssetContainer;
}

declare class ViewportWorldInteraction extends EditorWorldExtension { 
	Interactors: ViewportInteractor[];
	ViewportTransformer: ViewportTransformer;
	TransformGizmoActor: BaseTransformGizmo;
	SnapGridActor: Actor;
	SnapGridMeshComponent: StaticMeshComponent;
	SnapGridMID: MaterialInstanceDynamic;
	DefaultMouseCursorInteractor: MouseCursorInteractor;
	ActorsToExcludeFromHitTest: any[];
	AssetContainer: ViewportInteractionAssetContainer;
	static Load(ResourceName: string): ViewportWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteraction;
	static GetDefaultObject(): ViewportWorldInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteraction;
	SetWorldToMetersScale(NewWorldToMetersScale: number,bCompensateRoomWorldScale: boolean): void;
	SetRoomTransformForNextFrame(NewRoomTransform: Transform): void;
	SetHeadTransform(NewHeadTransform: Transform): void;
	RemoveInteractor(Interactor: ViewportInteractor): void;
	GetWorldScaleFactor(): number;
	GetTransformGizmoActor(): BaseTransformGizmo;
	GetRoomTransform(): Transform;
	GetRoomSpaceHeadTransform(): Transform;
	GetInteractors(): ViewportInteractor[];
	GetHeadTransform(): Transform;
	AddInteractor(Interactor: ViewportInteractor): void;
	AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: Actor): void;
	static C(Other: UObject | any): ViewportWorldInteraction;
}

declare class ViewportTransformer extends UObject { 
	ViewportWorldInteraction: ViewportWorldInteraction;
	static Load(ResourceName: string): ViewportTransformer;
	static Find(Outer: UObject, ResourceName: string): ViewportTransformer;
	static GetDefaultObject(): ViewportTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportTransformer;
	Shutdown(): void;
	ShouldCenterTransformGizmoPivot(): boolean;
	OnStopDragging(Interactor: ViewportInteractor): void;
	OnStartDragging(Interactor: ViewportInteractor): void;
	Init(InitViewportWorldInteraction: ViewportWorldInteraction): void;
	CanAlignToActors(): boolean;
	static C(Other: UObject | any): ViewportTransformer;
}

declare class ActorTransformer extends ViewportTransformer { 
	static Load(ResourceName: string): ActorTransformer;
	static Find(Outer: UObject, ResourceName: string): ActorTransformer;
	static GetDefaultObject(): ActorTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorTransformer;
	static C(Other: UObject | any): ActorTransformer;
}

declare class ViewportInteractableInterface extends Interface { 
	static Load(ResourceName: string): ViewportInteractableInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractableInterface;
	static GetDefaultObject(): ViewportInteractableInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractableInterface;
	static C(Other: UObject | any): ViewportInteractableInterface;
}

declare class TranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): TranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): TranslationDragOperation;
	static GetDefaultObject(): TranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationDragOperation;
	static C(Other: UObject | any): TranslationDragOperation;
}

declare class PlaneTranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): PlaneTranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): PlaneTranslationDragOperation;
	static GetDefaultObject(): PlaneTranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneTranslationDragOperation;
	static C(Other: UObject | any): PlaneTranslationDragOperation;
}

declare class RotateOnAngleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): RotateOnAngleDragOperation;
	static Find(Outer: UObject, ResourceName: string): RotateOnAngleDragOperation;
	static GetDefaultObject(): RotateOnAngleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotateOnAngleDragOperation;
	static C(Other: UObject | any): RotateOnAngleDragOperation;
}

declare class ScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): ScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): ScaleDragOperation;
	static GetDefaultObject(): ScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleDragOperation;
	static C(Other: UObject | any): ScaleDragOperation;
}

declare class UniformScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): UniformScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): UniformScaleDragOperation;
	static GetDefaultObject(): UniformScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleDragOperation;
	static C(Other: UObject | any): UniformScaleDragOperation;
}

declare class AxisGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): AxisGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): AxisGizmoHandleGroup;
	static GetDefaultObject(): AxisGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisGizmoHandleGroup;
	static C(Other: UObject | any): AxisGizmoHandleGroup;
}

declare class GizmoHandleMeshComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): GizmoHandleMeshComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleMeshComponent;
	static GetDefaultObject(): GizmoHandleMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleMeshComponent;
	static C(Other: UObject | any): GizmoHandleMeshComponent;
}

declare class UniformScaleGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): UniformScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): UniformScaleGizmoHandleGroup;
	static GetDefaultObject(): UniformScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleGizmoHandleGroup;
	static C(Other: UObject | any): UniformScaleGizmoHandleGroup;
}

declare class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotTranslationGizmoHandleGroup;
}

declare class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotScaleGizmoHandleGroup;
	static GetDefaultObject(): PivotScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotScaleGizmoHandleGroup;
	static C(Other: UObject | any): PivotScaleGizmoHandleGroup;
}

declare class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotPlaneTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotPlaneTranslationGizmoHandleGroup;
}

declare class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	RootFullRotationHandleComponent: SceneComponent;
	FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
	StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootStartRotationIdicatorComponent: SceneComponent;
	DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootDeltaRotationIndicatorComponent: SceneComponent;
	static Load(ResourceName: string): PivotRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotRotationGizmoHandleGroup;
	static GetDefaultObject(): PivotRotationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotRotationGizmoHandleGroup;
	static C(Other: UObject | any): PivotRotationGizmoHandleGroup;
}

declare class StretchGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): StretchGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleGroup;
	static GetDefaultObject(): StretchGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleGroup;
	static C(Other: UObject | any): StretchGizmoHandleGroup;
}

declare class PivotTransformGizmo extends BaseTransformGizmo { 
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
	ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
	PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
	RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	LastDraggingHandle: ActorComponent;
	static GetDefaultObject(): PivotTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTransformGizmo;
	static C(Other: UObject | any): PivotTransformGizmo;
}

declare class VISettings extends UObject { 
	bScaleWorldFromFloor: boolean;
	bScaleWorldWithDynamicPivot: boolean;
	bAllowSimultaneousWorldScalingAndRotation: boolean;
	static Load(ResourceName: string): VISettings;
	static Find(Outer: UObject, ResourceName: string): VISettings;
	static GetDefaultObject(): VISettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VISettings;
	static C(Other: UObject | any): VISettings;
}

declare class StretchGizmoHandleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): StretchGizmoHandleDragOperation;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleDragOperation;
	static GetDefaultObject(): StretchGizmoHandleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleDragOperation;
	static C(Other: UObject | any): StretchGizmoHandleDragOperation;
}

declare class MotionTrailToolOptions extends UObject { 
	bShowTrails: boolean;
	TrailColor: LinearColor;
	bShowFullTrail: boolean;
	TrailThickness: number;
	FramesBefore: number;
	FramesAfter: number;
	EvalsPerFrame: number;
	bShowKeys: boolean;
	bShowFrameNumber: boolean;
	KeyColor: LinearColor;
	KeySize: any;
	bShowMarks: boolean;
	MarkColor: LinearColor;
	MarkSize: any;
	bLockMarksToFrames: boolean;
	SecondsPerMark: any;
	static Load(ResourceName: string): MotionTrailToolOptions;
	static Find(Outer: UObject, ResourceName: string): MotionTrailToolOptions;
	static GetDefaultObject(): MotionTrailToolOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrailToolOptions;
	static C(Other: UObject | any): MotionTrailToolOptions;
}

declare class MovieSceneCopyableBinding extends UObject { 
	SpawnableObjectTemplate: UObject;
	Tracks: MovieSceneTrack[];
	Binding: MovieSceneBinding;
	Spawnable: MovieSceneSpawnable;
	Possessable: MovieScenePossessable;
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableBinding;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableBinding;
	static GetDefaultObject(): MovieSceneCopyableBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableBinding;
	static C(Other: UObject | any): MovieSceneCopyableBinding;
}

declare class MovieSceneCopyableTrack extends UObject { 
	Track: MovieSceneTrack;
	bIsAMasterTrack: boolean;
	bIsACameraCutTrack: boolean;
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableTrack;
	static GetDefaultObject(): MovieSceneCopyableTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableTrack;
	static C(Other: UObject | any): MovieSceneCopyableTrack;
}

declare class Exporter extends UObject { 
	SupportedClass: UnrealEngineClass;
	ExportRootScope: UObject;
	FormatExtension: string[];
	FormatDescription: string[];
	PreferredFormatIndex: number;
	TextIndent: number;
	bText: boolean;
	bSelectedOnly: boolean;
	bForceFileOperations: boolean;
	ExportTask: AssetExportTask;
	static Load(ResourceName: string): Exporter;
	static Find(Outer: UObject, ResourceName: string): Exporter;
	static GetDefaultObject(): Exporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Exporter;
	ScriptRunAssetExportTask(Task: AssetExportTask): boolean;
	static RunAssetExportTasks(ExportTasks: AssetExportTask[]): boolean;
	static RunAssetExportTask(Task: AssetExportTask): boolean;
	static C(Other: UObject | any): Exporter;
}

declare class AssetExportTask extends UObject { 
	UObject: UObject;
	Exporter: Exporter;
	Filename: string;
	bSelected: boolean;
	bReplaceIdentical: boolean;
	bPrompt: boolean;
	bAutomated: boolean;
	bUseFileArchive: boolean;
	bWriteEmptyFiles: boolean;
	IgnoreObjectList: UObject[];
	Options: UObject;
	Errors: string[];
	static Load(ResourceName: string): AssetExportTask;
	static Find(Outer: UObject, ResourceName: string): AssetExportTask;
	static GetDefaultObject(): AssetExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetExportTask;
	static C(Other: UObject | any): AssetExportTask;
}

declare class SequencerExportTask extends AssetExportTask { 
	SequencerContext: UObject;
	static Load(ResourceName: string): SequencerExportTask;
	static Find(Outer: UObject, ResourceName: string): SequencerExportTask;
	static GetDefaultObject(): SequencerExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerExportTask;
	static C(Other: UObject | any): SequencerExportTask;
}

declare class MovieSceneDoubleChannel extends MovieSceneChannel { 
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	Times: FrameNumber[];
	Values: MovieSceneDoubleValue[];
	DefaultValue: any;
	bHasDefaultValue: boolean;
	KeyHandles: MovieSceneKeyHandleMap;
	TickResolution: FrameRate;
	bShowCurve: boolean;
	clone() : MovieSceneDoubleChannel;
	static C(Other: UObject | any): MovieSceneDoubleChannel;
}

declare type EShow3DTrajectory = 'EST_OnlyWhenSelected' | 'EST_Always' | 'EST_Never' | 'EST_MAX';
declare var EShow3DTrajectory : { EST_OnlyWhenSelected:'EST_OnlyWhenSelected',EST_Always:'EST_Always',EST_Never:'EST_Never',EST_MAX:'EST_MAX', };
declare class MovieScene3DTransformSection extends MovieSceneSection { 
	TransformMask: MovieSceneTransformMask;
	Translation: MovieSceneDoubleChannel;
	Rotation: MovieSceneDoubleChannel;
	Scale: MovieSceneDoubleChannel;
	ManualWeight: MovieSceneFloatChannel;
	bUseQuaternionInterpolation: boolean;
	Show3DTrajectory: EShow3DTrajectory;
	static Load(ResourceName: string): MovieScene3DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSection;
	static GetDefaultObject(): MovieScene3DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSection;
	static C(Other: UObject | any): MovieScene3DTransformSection;
}

declare class SequencerKeyActor extends Actor { 
	KeyMeshComponent: StaticMeshComponent;
	AssociatedActor: Actor;
	TrackSection: MovieScene3DTransformSection;
	KeyTime: number;
	static GetDefaultObject(): SequencerKeyActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerKeyActor;
	static C(Other: UObject | any): SequencerKeyActor;
}

declare class MovieSceneKeyStructType extends ScriptStruct { 
	SourceTimesProperty: any;
	SourceValuesProperty: any;
	DestTimeProperty: any;
	DestValueProperty: any;
	static Load(ResourceName: string): MovieSceneKeyStructType;
	static Find(Outer: UObject, ResourceName: string): MovieSceneKeyStructType;
	static GetDefaultObject(): MovieSceneKeyStructType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneKeyStructType;
	static C(Other: UObject | any): MovieSceneKeyStructType;
}

declare class SequencerMeshTrail extends Actor { 
	static GetDefaultObject(): SequencerMeshTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerMeshTrail;
	static C(Other: UObject | any): SequencerMeshTrail;
}

declare class SequencerSettingsContainer extends UObject { 
	static Load(ResourceName: string): SequencerSettingsContainer;
	static Find(Outer: UObject, ResourceName: string): SequencerSettingsContainer;
	static GetDefaultObject(): SequencerSettingsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettingsContainer;
	static C(Other: UObject | any): SequencerSettingsContainer;
}

declare type EAutoChangeMode = 'AutoKey' | 'AutoTrack' | 'All' | 'None' | 'EAutoChangeMode_MAX';
declare var EAutoChangeMode : { AutoKey:'AutoKey',AutoTrack:'AutoTrack',All:'All',None:'None',EAutoChangeMode_MAX:'EAutoChangeMode_MAX', };
declare type EAllowEditsMode = 'AllEdits' | 'AllowSequencerEditsOnly' | 'AllowLevelEditsOnly' | 'EAllowEditsMode_MAX';
declare var EAllowEditsMode : { AllEdits:'AllEdits',AllowSequencerEditsOnly:'AllowSequencerEditsOnly',AllowLevelEditsOnly:'AllowLevelEditsOnly',EAllowEditsMode_MAX:'EAllowEditsMode_MAX', };
declare type EKeyGroupMode = 'KeyChanged' | 'KeyGroup' | 'KeyAll' | 'EKeyGroupMode_MAX';
declare var EKeyGroupMode : { KeyChanged:'KeyChanged',KeyGroup:'KeyGroup',KeyAll:'KeyAll',EKeyGroupMode_MAX:'EKeyGroupMode_MAX', };
declare type EMovieSceneKeyInterpolation = 'Auto' | 'User' | 'Break' | 'Linear' | 'Constant' | 'EMovieSceneKeyInterpolation_MAX';
declare var EMovieSceneKeyInterpolation : { Auto:'Auto',User:'User',Break:'Break',Linear:'Linear',Constant:'Constant',EMovieSceneKeyInterpolation_MAX:'EMovieSceneKeyInterpolation_MAX', };
declare type ESequencerSpawnPosition = 'SSP_Origin' | 'SSP_PlaceInFrontOfCamera' | 'SSP_MAX';
declare var ESequencerSpawnPosition : { SSP_Origin:'SSP_Origin',SSP_PlaceInFrontOfCamera:'SSP_PlaceInFrontOfCamera',SSP_MAX:'SSP_MAX', };
declare type ESequencerZoomPosition = 'SZP_CurrentTime' | 'SZP_MousePosition' | 'SZP_MAX';
declare var ESequencerZoomPosition : { SZP_CurrentTime:'SZP_CurrentTime',SZP_MousePosition:'SZP_MousePosition',SZP_MAX:'SZP_MAX', };
declare type ESequencerLoopMode = 'SLM_NoLoop' | 'SLM_Loop' | 'SLM_LoopSelectionRange' | 'SLM_MAX';
declare var ESequencerLoopMode : { SLM_NoLoop:'SLM_NoLoop',SLM_Loop:'SLM_Loop',SLM_LoopSelectionRange:'SLM_LoopSelectionRange',SLM_MAX:'SLM_MAX', };
declare type EFrameNumberDisplayFormats = 'NonDropFrameTimecode' | 'DropFrameTimecode' | 'Seconds' | 'Frames' | 'MAX_Count' | 'EFrameNumberDisplayFormats_MAX';
declare var EFrameNumberDisplayFormats : { NonDropFrameTimecode:'NonDropFrameTimecode',DropFrameTimecode:'DropFrameTimecode',Seconds:'Seconds',Frames:'Frames',MAX_Count:'MAX_Count',EFrameNumberDisplayFormats_MAX:'EFrameNumberDisplayFormats_MAX', };
declare class SequencerSettings extends UObject { 
	AutoChangeMode: EAutoChangeMode;
	AllowEditsMode: EAllowEditsMode;
	KeyGroupMode: EKeyGroupMode;
	KeyInterpolation: EMovieSceneKeyInterpolation;
	bAutoSetTrackDefaults: boolean;
	SpawnPosition: ESequencerSpawnPosition;
	bCreateSpawnableCameras: boolean;
	bShowRangeSlider: boolean;
	bIsSnapEnabled: boolean;
	bSnapKeyTimesToInterval: boolean;
	bSnapKeyTimesToKeys: boolean;
	bSnapSectionTimesToInterval: boolean;
	bSnapSectionTimesToSections: boolean;
	bSnapKeysAndSectionsToPlayRange: boolean;
	bSnapPlayTimeToKeys: boolean;
	bSnapPlayTimeToSections: boolean;
	bSnapPlayTimeToMarkers: boolean;
	bSnapPlayTimeToInterval: boolean;
	bSnapPlayTimeToPressedKey: boolean;
	bSnapPlayTimeToDraggedKey: boolean;
	bSnapCurveValueToInterval: boolean;
	bShowSelectedNodesOnly: boolean;
	bRewindOnRecord: boolean;
	ZoomPosition: ESequencerZoomPosition;
	bAutoScrollEnabled: boolean;
	bLinkCurveEditorTimeRange: boolean;
	bSynchronizeCurveEditorSelection: boolean;
	bIsolateCurveEditorToSelection: boolean;
	LoopMode: ESequencerLoopMode;
	bKeepCursorInPlayRangeWhileScrubbing: boolean;
	bKeepPlayRangeInSectionBounds: boolean;
	ZeroPadFrames: number;
	JumpFrameIncrement: FrameNumber;
	bShowCombinedKeyframes: boolean;
	bInfiniteKeyAreas: boolean;
	bShowChannelColors: boolean;
	KeyAreaCurveExtents: string;
	KeyAreaHeightWithCurves: number;
	ReduceKeysTolerance: number;
	bDeleteKeysWhenTrimming: boolean;
	bDisableSectionsAfterBaking: boolean;
	bCleanPlaybackMode: boolean;
	bActivateRealtimeViewports: boolean;
	bEvaluateSubSequencesInIsolation: boolean;
	bRerunConstructionScripts: boolean;
	bShowDebugVisualization: boolean;
	bVisualizePreAndPostRoll: boolean;
	bCompileDirectorOnEvaluate: boolean;
	TrajectoryPathCap: any;
	FrameNumberDisplayFormat: EFrameNumberDisplayFormats;
	MovieRendererName: string;
	static Load(ResourceName: string): SequencerSettings;
	static Find(Outer: UObject, ResourceName: string): SequencerSettings;
	static GetDefaultObject(): SequencerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettings;
	static C(Other: UObject | any): SequencerSettings;
}

declare class SequencerTrackFilterExtension extends UObject { 
	static Load(ResourceName: string): SequencerTrackFilterExtension;
	static Find(Outer: UObject, ResourceName: string): SequencerTrackFilterExtension;
	static GetDefaultObject(): SequencerTrackFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerTrackFilterExtension;
	static C(Other: UObject | any): SequencerTrackFilterExtension;
}

declare class PixelInspectorView extends UObject { 
	FinalColor: LinearColor;
	SceneColor: LinearColor;
	PreExposure: number;
	Luminance: number;
	HdrColor: LinearColor;
	Normal: Vector;
	PerObjectGBufferData: number;
	Metallic: number;
	Specular: number;
	Roughness: number;
	MaterialShadingModel: EMaterialShadingModel;
	SelectiveOutputMask: number;
	BaseColor: LinearColor;
	IndirectIrradiance: number;
	AmbientOcclusion: number;
	SubsurfaceColor: LinearColor;
	SubsurfaceProfile: Vector;
	Opacity: number;
	ClearCoat: number;
	ClearCoatRoughness: number;
	WorldNormal: Vector;
	BackLit: number;
	Cloth: number;
	EyeTangent: Vector;
	IrisMask: number;
	IrisDistance: number;
	static Load(ResourceName: string): PixelInspectorView;
	static Find(Outer: UObject, ResourceName: string): PixelInspectorView;
	static GetDefaultObject(): PixelInspectorView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PixelInspectorView;
	static C(Other: UObject | any): PixelInspectorView;
}

declare class SubobjectDataHandle { 
	clone() : SubobjectDataHandle;
	static C(Other: UObject | any): SubobjectDataHandle;
	GetData(OutData?: SubobjectData): {OutData: SubobjectData};
	IsHandleValid(): boolean;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
}

declare class SubobjectData { 
	WeakObjectPtr: any;
	Handle: SubobjectDataHandle;
	ParentObjectHandle: SubobjectDataHandle;
	ChildrenHandles: SubobjectDataHandle[];
	clone() : SubobjectData;
	static C(Other: UObject | any): SubobjectData;
	CanCopy(): boolean;
	CanDelete(): boolean;
	CanDuplicate(): boolean;
	CanEdit(): boolean;
	CanRename(): boolean;
	CanReparent(): boolean;
	GetHandle(OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetObject(bEvenIfPendingKill: boolean): UObject;
	GetVariableName(): string;
	IsActor(): boolean;
	IsAttachedTo(InHandle: SubobjectDataHandle): boolean;
	IsChildActor(): boolean;
	IsComponent(): boolean;
	IsDefaultSceneRoot(): boolean;
	IsInheritedComponent(): boolean;
	IsInstancedActor(): boolean;
	IsInstancedComponent(): boolean;
	IsNativeComponent(): boolean;
	IsRootActor(): boolean;
	IsRootComponent(): boolean;
	IsSceneComponent(): boolean;
	IsValid(): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanReparent(Data: SubobjectData): boolean;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetVariableName(Data: SubobjectData): string;
	static IsActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsValid(Data: SubobjectData): boolean;
}

declare class SubobjectDataBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static GetDefaultObject(): SubobjectDataBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataBlueprintFunctionLibrary;
	static IsValid(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsActor(Data: SubobjectData): boolean;
	static GetVariableName(Data: SubobjectData): string;
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetDisplayName(Data: SubobjectData): string;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	GetBlueprint(Data: SubobjectData): Blueprint;
	static CanReparent(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static C(Other: UObject | any): SubobjectDataBlueprintFunctionLibrary;
}

declare class ReparentSubobjectParams { 
	NewParentHandle: SubobjectDataHandle;
	BlueprintContext: Blueprint;
	ActorPreviewContext: Actor;
	clone() : ReparentSubobjectParams;
	static C(Other: UObject | any): ReparentSubobjectParams;
}

declare class AddNewSubobjectParams { 
	ParentHandle: SubobjectDataHandle;
	NewClass: UnrealEngineClass;
	BlueprintContext: Blueprint;
	bSkipMarkBlueprintModified: boolean;
	bConformTransformToParent: boolean;
	clone() : AddNewSubobjectParams;
	static C(Other: UObject | any): AddNewSubobjectParams;
}

declare class SubobjectDataSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): SubobjectDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataSubsystem;
	static GetDefaultObject(): SubobjectDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataSubsystem;
	ReparentSubobjects(Params: ReparentSubobjectParams,HandlesToMove: SubobjectDataHandle[]): boolean;
	ReparentSubobject(Params: ReparentSubobjectParams,ToReparentHandle: SubobjectDataHandle): boolean;
	static RenameSubobjectMemberVariable(BPContext: Blueprint,InHandle: SubobjectDataHandle,NewName: string): void;
	RenameSubobject(Handle: SubobjectDataHandle,InNewName: string): boolean;
	MakeNewSceneRoot(Context: SubobjectDataHandle,NewSceneRoot: SubobjectDataHandle,BPContext: Blueprint): boolean;
	K2_GatherSubobjectDataForInstance(Context: Actor,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_GatherSubobjectDataForBlueprint(Context: Blueprint,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_FindSubobjectDataFromHandle(Handle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData, $: boolean};
	K2_DeleteSubobjectsFromInstance(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[]): number;
	K2_DeleteSubobjectFromInstance(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle): number;
	IsValidRename(Handle: SubobjectDataHandle,InNewText: string,OutErrorMessage?: string): {OutErrorMessage: string, $: boolean};
	FindHandleForObject(Context: SubobjectDataHandle,ObjectToFind: UObject,BPContext: Blueprint): SubobjectDataHandle;
	DetachSubobject(OwnerHandle: SubobjectDataHandle,ChildToRemove: SubobjectDataHandle): boolean;
	DeleteSubobjects(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[],BPContext: Blueprint): number;
	DeleteSubobject(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle,BPContext: Blueprint): number;
	static CreateNewCPPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	static CreateNewBPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	CopySubobjects(Handles: SubobjectDataHandle[],BPContext: Blueprint): void;
	ChangeSubobjectClass(Handle: SubobjectDataHandle,NewClass: UnrealEngineClass): boolean;
	CanPasteSubobjects(RootHandle: SubobjectDataHandle,BPContext: Blueprint): boolean;
	CanCopySubobjects(Handles: SubobjectDataHandle[]): boolean;
	AttachSubobject(OwnerHandle: SubobjectDataHandle,ChildToAddHandle: SubobjectDataHandle): boolean;
	AddNewSubobject(Params: AddNewSubobjectParams,FailReason?: string): {FailReason: string, $: SubobjectDataHandle};
	static C(Other: UObject | any): SubobjectDataSubsystem;
}

declare class SubobjectEditorMenuContext extends UObject { 
	static Load(ResourceName: string): SubobjectEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): SubobjectEditorMenuContext;
	static GetDefaultObject(): SubobjectEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectEditorMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): SubobjectEditorMenuContext;
}

declare class LevelEditorMenuContext extends UObject { 
	static Load(ResourceName: string): LevelEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorMenuContext;
	static GetDefaultObject(): LevelEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorMenuContext;
	static C(Other: UObject | any): LevelEditorMenuContext;
}

declare type ELevelEditorMenuContext = 'Viewport' | 'SceneOutliner' | 'MainMenu' | 'ELevelEditorMenuContext_MAX';
declare var ELevelEditorMenuContext : { Viewport:'Viewport',SceneOutliner:'SceneOutliner',MainMenu:'MainMenu',ELevelEditorMenuContext_MAX:'ELevelEditorMenuContext_MAX', };
declare class LevelEditorContextMenuContext extends UObject { 
	ContextType: ELevelEditorMenuContext;
	CurrentSelection: TypedElementSelectionSet;
	CursorWorldLocation: Vector;
	SelectedComponents: ActorComponent[];
	HitProxyActor: Actor;
	static Load(ResourceName: string): LevelEditorContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorContextMenuContext;
	static GetDefaultObject(): LevelEditorContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorContextMenuContext;
	GetScriptHitProxyElement(): ScriptTypedElementHandle;
	static C(Other: UObject | any): LevelEditorContextMenuContext;
}

declare class LevelViewportToolBarContext extends UObject { 
	static Load(ResourceName: string): LevelViewportToolBarContext;
	static Find(Outer: UObject, ResourceName: string): LevelViewportToolBarContext;
	static GetDefaultObject(): LevelViewportToolBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelViewportToolBarContext;
	static C(Other: UObject | any): LevelViewportToolBarContext;
}

declare class QuickActionMenuContext extends UObject { 
	CurrentSelection: TypedElementSelectionSet;
	static Load(ResourceName: string): QuickActionMenuContext;
	static Find(Outer: UObject, ResourceName: string): QuickActionMenuContext;
	static GetDefaultObject(): QuickActionMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuickActionMenuContext;
	static C(Other: UObject | any): QuickActionMenuContext;
}

declare class LevelEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LevelEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorSubsystem;
	static GetDefaultObject(): LevelEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorSubsystem;
	SetCurrentLevelByName(LevelName: string): boolean;
	SetAllowsCinematicControl(bAllow: boolean,ViewportConfigKey: string): void;
	SaveCurrentLevel(): boolean;
	SaveAllDirtyLevels(): boolean;
	PilotLevelActor(ActorToPilot: Actor,ViewportConfigKey: string): void;
	NewLevelFromTemplate(AssetPath: string,TemplateAssetPath: string): boolean;
	NewLevel(AssetPath: string): boolean;
	LoadLevel(AssetPath: string): boolean;
	IsInPlayInEditor(): boolean;
	GetViewportConfigKeys(): string[];
	GetSelectionSet(): TypedElementSelectionSet;
	GetCurrentLevel(): Level;
	GetAllowsCinematicControl(ViewportConfigKey: string): boolean;
	GetActiveViewportConfigKey(): string;
	EjectPilotLevelActor(ViewportConfigKey: string): void;
	EditorSetGameView(bGameView: boolean,ViewportConfigKey: string): void;
	EditorRequestEndPlay(): void;
	EditorPlaySimulate(): void;
	EditorInvalidateViewports(): void;
	EditorGetGameView(ViewportConfigKey: string): boolean;
	static C(Other: UObject | any): LevelEditorSubsystem;
}

declare class LightEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LightEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LightEditorSubsystem;
	static GetDefaultObject(): LightEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightEditorSubsystem;
	static C(Other: UObject | any): LightEditorSubsystem;
}

declare class LevelEditorUISubsystem extends AssetEditorUISubsystem { 
	static Load(ResourceName: string): LevelEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorUISubsystem;
	static GetDefaultObject(): LevelEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorUISubsystem;
	static C(Other: UObject | any): LevelEditorUISubsystem;
}

declare class UndoHistorySettings extends UObject { 
	bShowTransactionDetails: boolean;
	static Load(ResourceName: string): UndoHistorySettings;
	static Find(Outer: UObject, ResourceName: string): UndoHistorySettings;
	static GetDefaultObject(): UndoHistorySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UndoHistorySettings;
	static C(Other: UObject | any): UndoHistorySettings;
}

declare type EInterchangeNodeContainerType = 'NodeContainerType_None' | 'NodeContainerType_TranslatedScene' | 'NodeContainerType_TranslatedAsset' | 'NodeContainerType_FactoryData' | 'NodeContainerType_MAX';
declare var EInterchangeNodeContainerType : { NodeContainerType_None:'NodeContainerType_None',NodeContainerType_TranslatedScene:'NodeContainerType_TranslatedScene',NodeContainerType_TranslatedAsset:'NodeContainerType_TranslatedAsset',NodeContainerType_FactoryData:'NodeContainerType_FactoryData',NodeContainerType_MAX:'NodeContainerType_MAX', };
declare class InterchangeBaseNode extends UObject { 
	ReferenceObject: SoftObjectPath;
	static Load(ResourceName: string): InterchangeBaseNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNode;
	static GetDefaultObject(): InterchangeBaseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNode;
	SetParentUid(ParentUid: string): boolean;
	SetEnabled(bIsEnabled: boolean): boolean;
	SetDisplayLabel(DisplayName: string): boolean;
	SetAssetName(AssetName: string): boolean;
	RemoveTargetNodeUid(AssetUid: string): boolean;
	RemoveFactoryDependencyUid(DependencyUid: string): boolean;
	RemoveAttribute(NodeAttributeKey: string): boolean;
	IsEnabled(): boolean;
	InitializeNode(UniqueId: string,DisplayLabel: string,NodeContainerType: EInterchangeNodeContainerType): void;
	GetUniqueID(): string;
	GetTargetNodeUids(OutTargetAssets?: string[]): {OutTargetAssets: string[]};
	GetTargetNodeCount(): number;
	GetStringAttribute(NodeAttributeKey: string,OutValue?: string): {OutValue: string, $: boolean};
	GetParentUid(): string;
	GetNodeContainerType(): EInterchangeNodeContainerType;
	GetInt32Attribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetFloatAttribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetFactoryDependency(index: number,OutDependency?: string): {OutDependency: string};
	GetFactoryDependenciesCount(): number;
	GetFactoryDependencies(OutDependencies?: string[]): {OutDependencies: string[]};
	GetDisplayLabel(): string;
	GetBooleanAttribute(NodeAttributeKey: string,OutValue?: boolean): {OutValue: boolean, $: boolean};
	GetAssetName(): string;
	AddTargetNodeUid(AssetUid: string): boolean;
	AddStringAttribute(NodeAttributeKey: string,Value: string): boolean;
	AddInt32Attribute(NodeAttributeKey: string,Value: number): boolean;
	AddFloatAttribute(NodeAttributeKey: string,Value: number): boolean;
	AddFactoryDependencyUid(DependencyUid: string): boolean;
	AddBooleanAttribute(NodeAttributeKey: string,Value: boolean): boolean;
	static C(Other: UObject | any): InterchangeBaseNode;
}

declare class InterchangeBaseNodeContainer extends UObject { 
	Nodes: any;
	static Load(ResourceName: string): InterchangeBaseNodeContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNodeContainer;
	static GetDefaultObject(): InterchangeBaseNodeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNodeContainer;
	SetNodeParentUid(NodeUniqueID: string,NewParentNodeUid: string): boolean;
	SaveToFile(Filename: string): void;
	LoadFromFile(Filename: string): void;
	IsNodeUidValid(NodeUniqueID: string): boolean;
	GetRoots(RootNodes?: string[]): {RootNodes: string[]};
	GetNodes(ClassNode: UnrealEngineClass,OutNodes?: string[]): {OutNodes: string[]};
	GetNodeChildrenUids(NodeUniqueID: string): string[];
	GetNodeChildrenCount(NodeUniqueID: string): number;
	GetNodeChildren(NodeUniqueID: string,ChildIndex: number): InterchangeBaseNode;
	GetNode(NodeUniqueID: string): InterchangeBaseNode;
	AddNode(UNode: InterchangeBaseNode): string;
	static C(Other: UObject | any): InterchangeBaseNodeContainer;
}

declare class InterchangeResult extends UObject { 
	SourceAssetName: string;
	DestinationAssetName: string;
	AssetType: UnrealEngineClass;
	InterchangeKey: string;
	static Load(ResourceName: string): InterchangeResult;
	static Find(Outer: UObject, ResourceName: string): InterchangeResult;
	static GetDefaultObject(): InterchangeResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResult;
	static C(Other: UObject | any): InterchangeResult;
}

declare class InterchangeResultsContainer extends UObject { 
	Results: InterchangeResult[];
	static Load(ResourceName: string): InterchangeResultsContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultsContainer;
	static GetDefaultObject(): InterchangeResultsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultsContainer;
	static C(Other: UObject | any): InterchangeResultsContainer;
}

declare class InterchangeFactoryBase extends UObject { 
	Results: InterchangeResultsContainer;
	static Load(ResourceName: string): InterchangeFactoryBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeFactoryBase;
	static GetDefaultObject(): InterchangeFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFactoryBase;
	GetFactoryClass(): UnrealEngineClass;
	static C(Other: UObject | any): InterchangeFactoryBase;
}

declare class InterchangeSourceData extends UObject { 
	Filename: string;
	static Load(ResourceName: string): InterchangeSourceData;
	static Find(Outer: UObject, ResourceName: string): InterchangeSourceData;
	static GetDefaultObject(): InterchangeSourceData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeSourceData;
	SetFilename(InFilename: string): boolean;
	GetFilename(): string;
	static C(Other: UObject | any): InterchangeSourceData;
}

declare type EInterchangePipelineTask = 'PreFactoryImport' | 'PostFactoryImport' | 'Export' | 'EInterchangePipelineTask_MAX';
declare var EInterchangePipelineTask : { PreFactoryImport:'PreFactoryImport',PostFactoryImport:'PostFactoryImport',Export:'Export',EInterchangePipelineTask_MAX:'EInterchangePipelineTask_MAX', };
declare class InterchangePipelineBase extends UObject { 
	Results: InterchangeResultsContainer;
	static Load(ResourceName: string): InterchangePipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineBase;
	static GetDefaultObject(): InterchangePipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineBase;
	ScriptedExecutePreImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,SourceDatas: InterchangeSourceData[]): boolean;
	ScriptedExecutePostImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,NodeKey: string,CreatedAsset: UObject,bIsAReimport: boolean): boolean;
	ScriptedExecuteExportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer): boolean;
	ScriptedCanExecuteOnAnyThread(PipelineTask: EInterchangePipelineTask): boolean;
	static C(Other: UObject | any): InterchangePipelineBase;
}

declare class InterchangeResultSuccess extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultSuccess;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultSuccess;
	static GetDefaultObject(): InterchangeResultSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultSuccess;
	static C(Other: UObject | any): InterchangeResultSuccess;
}

declare class InterchangeResultWarning extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultWarning;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning;
	static GetDefaultObject(): InterchangeResultWarning;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning;
	static C(Other: UObject | any): InterchangeResultWarning;
}

declare class InterchangeResultError extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultError;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError;
	static GetDefaultObject(): InterchangeResultError;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError;
	static C(Other: UObject | any): InterchangeResultError;
}

declare class InterchangeResultWarning_Generic extends InterchangeResultWarning { 
	text: string;
	static Load(ResourceName: string): InterchangeResultWarning_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning_Generic;
	static GetDefaultObject(): InterchangeResultWarning_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning_Generic;
	static C(Other: UObject | any): InterchangeResultWarning_Generic;
}

declare class InterchangeResultError_Generic extends InterchangeResultError { 
	text: string;
	static Load(ResourceName: string): InterchangeResultError_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError_Generic;
	static GetDefaultObject(): InterchangeResultError_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError_Generic;
	static C(Other: UObject | any): InterchangeResultError_Generic;
}

declare class InterchangeTranslatorBase extends UObject { 
	Results: InterchangeResultsContainer;
	SourceData: InterchangeSourceData;
	static Load(ResourceName: string): InterchangeTranslatorBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeTranslatorBase;
	static GetDefaultObject(): InterchangeTranslatorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeTranslatorBase;
	static C(Other: UObject | any): InterchangeTranslatorBase;
}

declare class InterchangeWriterBase extends UObject { 
	static Load(ResourceName: string): InterchangeWriterBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeWriterBase;
	static GetDefaultObject(): InterchangeWriterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeWriterBase;
	static C(Other: UObject | any): InterchangeWriterBase;
}

declare class InterchangeAssetImportData extends AssetImportData { 
	NodeContainer: InterchangeBaseNodeContainer;
	NodeUniqueID: string;
	Pipelines: InterchangePipelineBase[];
	static Load(ResourceName: string): InterchangeAssetImportData;
	static Find(Outer: UObject, ResourceName: string): InterchangeAssetImportData;
	static GetDefaultObject(): InterchangeAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeAssetImportData;
	ScriptGetFirstFilename(): string;
	ScriptExtractFilenames(): string[];
	ScriptExtractDisplayLabels(): string[];
	static C(Other: UObject | any): InterchangeAssetImportData;
}

declare class ImportAssetParameters { 
	ReimportAsset: UObject;
	bIsAutomated: boolean;
	OverridePipelines: InterchangePipelineBase[];
	OnAssetDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnAssetsImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	OnSceneObjectDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnSceneImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	clone() : ImportAssetParameters;
	static C(Other: UObject | any): ImportAssetParameters;
}

declare class InterchangeManager extends UObject { 
	RegisteredTranslatorsClass: any;
	RegisteredFactoryClasses: any;
	RegisteredWriters: any;
	TextureOnlyTranslatorClass: any;
	static Load(ResourceName: string): InterchangeManager;
	static Find(Outer: UObject, ResourceName: string): InterchangeManager;
	static GetDefaultObject(): InterchangeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeManager;
	ImportScene(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	ImportAsset(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	GetRegisteredFactoryClass(ClassToMake: UnrealEngineClass): UnrealEngineClass;
	static GetInterchangeManagerScripted(): InterchangeManager;
	ExportScene(World: UObject,bIsAutomated: boolean): boolean;
	ExportAsset(Asset: UObject,bIsAutomated: boolean): boolean;
	static CreateSourceData(InFilename: string): InterchangeSourceData;
	static C(Other: UObject | any): InterchangeManager;
}

declare type EInterchangePipelineConfigurationDialogResult = 'Cancel' | 'Import' | 'ImportAll' | 'EInterchangePipelineConfigurationDialogResult_MAX';
declare var EInterchangePipelineConfigurationDialogResult : { Cancel:'Cancel',Import:'Import',ImportAll:'ImportAll',EInterchangePipelineConfigurationDialogResult_MAX:'EInterchangePipelineConfigurationDialogResult_MAX', };
declare class InterchangePipelineConfigurationBase extends UObject { 
	static Load(ResourceName: string): InterchangePipelineConfigurationBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineConfigurationBase;
	static GetDefaultObject(): InterchangePipelineConfigurationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineConfigurationBase;
	ScriptedShowPipelineConfigurationDialog(): EInterchangePipelineConfigurationDialogResult;
	static C(Other: UObject | any): InterchangePipelineConfigurationBase;
}

declare class InterchangeProjectSettings extends DeveloperSettings { 
	PipelineStacks: any;
	DefaultPipelineStack: string;
	PipelineConfigurationDialogClass: Class;
	bShowPipelineStacksConfigurationDialog: boolean;
	bUseInterchangeWhenImportingIntoLevel: boolean;
	DefaultScenePipelineStack: string;
	static Load(ResourceName: string): InterchangeProjectSettings;
	static Find(Outer: UObject, ResourceName: string): InterchangeProjectSettings;
	static GetDefaultObject(): InterchangeProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeProjectSettings;
	static C(Other: UObject | any): InterchangeProjectSettings;
}

declare class PropertyEntry { 
	Property: EMaterialProperty;
	bUseCustomSize: boolean;
	CustomSize: IntPoint;
	bUseConstantValue: boolean;
	ConstantValue: number;
	clone() : PropertyEntry;
	static C(Other: UObject | any): PropertyEntry;
}

declare class MaterialOptions extends UObject { 
	Properties: PropertyEntry[];
	TextureSize: IntPoint;
	LODIndices: number[];
	bUseMeshData: boolean;
	bUseSpecificUVIndex: boolean;
	TextureCoordinateIndex: number;
	static Load(ResourceName: string): MaterialOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialOptions;
	static GetDefaultObject(): MaterialOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialOptions;
	static C(Other: UObject | any): MaterialOptions;
}

declare class AssetBakeOptions extends UObject { 
	static Load(ResourceName: string): AssetBakeOptions;
	static Find(Outer: UObject, ResourceName: string): AssetBakeOptions;
	static GetDefaultObject(): AssetBakeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBakeOptions;
	static C(Other: UObject | any): AssetBakeOptions;
}

declare type EMaterialBakeMethod = 'IndividualMaterial' | 'AtlasMaterial' | 'BinnedMaterial' | 'EMaterialBakeMethod_MAX';
declare var EMaterialBakeMethod : { IndividualMaterial:'IndividualMaterial',AtlasMaterial:'AtlasMaterial',BinnedMaterial:'BinnedMaterial',EMaterialBakeMethod_MAX:'EMaterialBakeMethod_MAX', };
declare class MaterialMergeOptions extends UObject { 
	Method: EMaterialBakeMethod;
	BlendMode: EBlendMode;
	static Load(ResourceName: string): MaterialMergeOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialMergeOptions;
	static GetDefaultObject(): MaterialMergeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialMergeOptions;
	static C(Other: UObject | any): MaterialMergeOptions;
}

declare class PreviewSceneProfile { 
	ProfileName: string;
	bSharedProfile: boolean;
	bUseSkyLighting: boolean;
	DirectionalLightIntensity: number;
	DirectionalLightColor: LinearColor;
	SkyLightIntensity: number;
	bRotateLightingRig: boolean;
	bShowEnvironment: boolean;
	bShowFloor: boolean;
	EnvironmentColor: LinearColor;
	EnvironmentIntensity: number;
	EnvironmentCubeMap: TextureCube;
	EnvironmentCubeMapPath: string;
	bPostProcessingEnabled: boolean;
	PostProcessingSettings: PostProcessSettings;
	LightingRigRotation: number;
	RotationSpeed: number;
	DirectionalLightRotation: Rotator;
	clone() : PreviewSceneProfile;
	static C(Other: UObject | any): PreviewSceneProfile;
}

declare class LocalProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): LocalProfiles;
	static Find(Outer: UObject, ResourceName: string): LocalProfiles;
	static GetDefaultObject(): LocalProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalProfiles;
	static C(Other: UObject | any): LocalProfiles;
}

declare class SharedProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): SharedProfiles;
	static Find(Outer: UObject, ResourceName: string): SharedProfiles;
	static GetDefaultObject(): SharedProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SharedProfiles;
	static C(Other: UObject | any): SharedProfiles;
}

declare class AssetViewerSettings extends UObject { 
	Profiles: PreviewSceneProfile[];
	bFakeConfigValue_HACK: boolean;
	static Load(ResourceName: string): AssetViewerSettings;
	static Find(Outer: UObject, ResourceName: string): AssetViewerSettings;
	static GetDefaultObject(): AssetViewerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetViewerSettings;
	static C(Other: UObject | any): AssetViewerSettings;
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	ParameterStateId: Guid;
	PhysMaterialMask: PhysicalMaterialMask;
	static Load(ResourceName: string): MaterialInstanceConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceConstant;
	static GetDefaultObject(): MaterialInstanceConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValue(ParameterName: string): number;
	static C(Other: UObject | any): MaterialInstanceConstant;
	ClearAllMaterialInstanceParameters(): void;
	GetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	GetMaterialInstanceScalarParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): number;
	GetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	GetMaterialInstanceTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	GetMaterialInstanceVectorParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	SetMaterialInstanceParent(NewParent: MaterialInterface): void;
	SetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceScalarParameterValue(ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceTextureParameterValue(ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceVectorParameterValue(ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	UpdateMaterialInstance(): void;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
}

declare class MaterialEditingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MaterialEditingLibrary;
	static Find(Outer: UObject, ResourceName: string): MaterialEditingLibrary;
	static GetDefaultObject(): MaterialEditingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditingLibrary;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunctionInterface,PreviewMaterial: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static RecompileMaterial(Material: Material): void;
	static LayoutMaterialFunctionExpressions(MaterialFunction: MaterialFunction): void;
	static LayoutMaterialExpressions(Material: Material): void;
	static HasMaterialUsage(Material: Material,Usage: EMaterialUsage): boolean;
	static GetVectorParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetVectorParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetUsedTextures(Material: Material): Texture[];
	static GetTextureParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetTextureParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetStatistics(Material: MaterialInterface): MaterialStatistics;
	static GetStaticSwitchParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetStaticSwitchParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetScalarParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetScalarParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static GetNumMaterialExpressions(Material: Material): number;
	static GetMaterialSelectedNodes(Material: Material): any;
	static GetMaterialPropertyInputNode(Material: Material,Property: EMaterialProperty): MaterialExpression;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialDefaultVectorParameterValue(Material: Material,ParameterName: string): LinearColor;
	static GetMaterialDefaultTextureParameterValue(Material: Material,ParameterName: string): Texture;
	static GetMaterialDefaultStaticSwitchParameterValue(Material: Material,ParameterName: string): boolean;
	static GetMaterialDefaultScalarParameterValue(Material: Material,ParameterName: string): number;
	static GetInputsForMaterialExpression(Material: Material,MaterialExpression: MaterialExpression): MaterialExpression[];
	static GetChildInstances(Parent: MaterialInterface,ChildInstances?: AssetData[]): {ChildInstances: AssetData[]};
	static DuplicateMaterialExpression(Material: Material,MaterialFunction: MaterialFunction,Expression: MaterialExpression): MaterialExpression;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static C(Other: UObject | any): MaterialEditingLibrary;
}

declare class MaterialEditorMenuContext extends UObject { 
	static Load(ResourceName: string): MaterialEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorMenuContext;
	static GetDefaultObject(): MaterialEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorMenuContext;
	static C(Other: UObject | any): MaterialEditorMenuContext;
}

declare type EBackgroundType = 'SolidColor' | 'Checkered' | 'EBackgroundType_MAX';
declare var EBackgroundType : { SolidColor:'SolidColor',Checkered:'Checkered',EBackgroundType_MAX:'EBackgroundType_MAX', };
declare class CheckerboardSettings { 
	ColorOne: Color;
	ColorTwo: Color;
	Size: number;
	clone() : CheckerboardSettings;
	static C(Other: UObject | any): CheckerboardSettings;
}

declare class PreviewBackgroundSettings { 
	bShowBorder: boolean;
	BorderColor: Color;
	BackgroundType: EBackgroundType;
	BackgroundColor: Color;
	Checkerboard: CheckerboardSettings;
	clone() : PreviewBackgroundSettings;
	static C(Other: UObject | any): PreviewBackgroundSettings;
}

declare class MaterialEditorSettings extends UObject { 
	MaliOfflineCompilerPath: FilePath;
	DefaultPreviewWidth: number;
	DefaultPreviewHeight: number;
	PreviewBackground: PreviewBackgroundSettings;
	static Load(ResourceName: string): MaterialEditorSettings;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorSettings;
	static GetDefaultObject(): MaterialEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorSettings;
	static C(Other: UObject | any): MaterialEditorSettings;
}

declare class AdvancedCopyCustomization extends UObject { 
	static Load(ResourceName: string): AdvancedCopyCustomization;
	static Find(Outer: UObject, ResourceName: string): AdvancedCopyCustomization;
	static GetDefaultObject(): AdvancedCopyCustomization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AdvancedCopyCustomization;
	static C(Other: UObject | any): AdvancedCopyCustomization;
}

declare class AssetToolsImpl extends UObject { 
	static Load(ResourceName: string): AssetToolsImpl;
	static Find(Outer: UObject, ResourceName: string): AssetToolsImpl;
	static GetDefaultObject(): AssetToolsImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsImpl;
	static C(Other: UObject | any): AssetToolsImpl;
}

declare class AdvancedCopyMap { 
	ClassToCopy: SoftClassPath;
	AdvancedCopyCustomization: SoftClassPath;
	clone() : AdvancedCopyMap;
	static C(Other: UObject | any): AdvancedCopyMap;
}

declare class AssetToolsSettings extends DeveloperSettings { 
	AdvancedCopyCustomizations: AdvancedCopyMap[];
	static Load(ResourceName: string): AssetToolsSettings;
	static Find(Outer: UObject, ResourceName: string): AssetToolsSettings;
	static GetDefaultObject(): AssetToolsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsSettings;
	static C(Other: UObject | any): AssetToolsSettings;
}

declare class AssetRenameData { 
	Asset: any;
	NewPackagePath: string;
	NewName: string;
	OldObjectPath: SoftObjectPath;
	NewObjectPath: SoftObjectPath;
	bOnlyFixSoftReferences: boolean;
	clone() : AssetRenameData;
	static C(Other: UObject | any): AssetRenameData;
}

declare type EAssetRenameResult = 'Failure' | 'Success' | 'Pending' | 'EAssetRenameResult_MAX';
declare var EAssetRenameResult : { Failure:'Failure',Success:'Success',Pending:'Pending',EAssetRenameResult_MAX:'EAssetRenameResult_MAX', };
declare class AutomatedAssetImportData extends UObject { 
	GroupName: string;
	Filenames: string[];
	DestinationPath: string;
	FactoryName: string;
	bReplaceExisting: boolean;
	bSkipReadOnly: boolean;
	Factory: Factory;
	LevelToLoad: string;
	static Load(ResourceName: string): AutomatedAssetImportData;
	static Find(Outer: UObject, ResourceName: string): AutomatedAssetImportData;
	static GetDefaultObject(): AutomatedAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedAssetImportData;
	static C(Other: UObject | any): AutomatedAssetImportData;
}

declare class Factory extends UObject { 
	bCreateNew: boolean;
	SupportedClass: UnrealEngineClass;
	ContextClass: UnrealEngineClass;
	Formats: string[];
	bEditAfterNew: boolean;
	bEditorImport: boolean;
	bText: boolean;
	ImportPriority: number;
	AutomatedImportData: AutomatedAssetImportData;
	AssetImportTask: AssetImportTask;
	OverwriteYesOrNoToAllState: number;
	static Load(ResourceName: string): Factory;
	static Find(Outer: UObject, ResourceName: string): Factory;
	static GetDefaultObject(): Factory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Factory;
	ScriptFactoryCreateFile(InTask: AssetImportTask): boolean;
	ScriptFactoryCanImport(Filename: string): boolean;
	static C(Other: UObject | any): Factory;
}

declare class AssetImportTask extends UObject { 
	Filename: string;
	DestinationPath: string;
	DestinationName: string;
	bReplaceExisting: boolean;
	bReplaceExistingSettings: boolean;
	bAutomated: boolean;
	bSave: boolean;
	Factory: Factory;
	Options: UObject;
	ImportedObjectPaths: string[];
	Result: UObject[];
	static Load(ResourceName: string): AssetImportTask;
	static Find(Outer: UObject, ResourceName: string): AssetImportTask;
	static GetDefaultObject(): AssetImportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportTask;
	static C(Other: UObject | any): AssetImportTask;
}

declare class AssetTools extends Interface { 
	static Load(ResourceName: string): AssetTools;
	static Find(Outer: UObject, ResourceName: string): AssetTools;
	static GetDefaultObject(): AssetTools;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetTools;
	RenameReferencingSoftObjectPaths(PackagesToCheck: Package[],AssetRedirectorMap: any): void;
	RenameAssetsWithDialog(AssetsAndNames: AssetRenameData[],bAutoCheckout: boolean): EAssetRenameResult;
	RenameAssets(AssetsAndNames: AssetRenameData[]): boolean;
	OpenEditorForAssets(Assets: UObject[]): void;
	ImportAssetTasks(ImportTasks: AssetImportTask[]): void;
	ImportAssetsWithDialog(DestinationPath: string): UObject[];
	ImportAssetsAutomated(ImportData: AutomatedAssetImportData): UObject[];
	FindSoftReferencesToObject(TargetObject: SoftObjectPath,ReferencingObjects?: UObject[]): {ReferencingObjects: UObject[]};
	ExportAssetsWithDialog(AssetsToExport: string[],bPromptForIndividualFilenames: boolean): void;
	ExportAssets(AssetsToExport: string[],ExportPath: string): void;
	DuplicateAssetWithDialogAndTitle(AssetName: string,PackagePath: string,OriginalObject: UObject,DialogTitle: string): UObject;
	DuplicateAssetWithDialog(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	DuplicateAsset(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	CreateUniqueAssetName(InBasePackageName: string,InSuffix: string,OutPackageName?: string,OutAssetName?: string): {OutPackageName: string, OutAssetName: string};
	CreateAssetWithDialog(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string,bCallConfigureProperties: boolean): UObject;
	CreateAsset(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string): UObject;
	static C(Other: UObject | any): AssetTools;
}

declare class AssetToolsHelpers extends UObject { 
	static Load(ResourceName: string): AssetToolsHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetToolsHelpers;
	static GetDefaultObject(): AssetToolsHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsHelpers;
	static C(Other: UObject | any): AssetToolsHelpers;
}

declare class BlueprintEditorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintEditorLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorLibrary;
	static GetDefaultObject(): BlueprintEditorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorLibrary;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static RenameGraph(Graph: EdGraph,NewNameStr: string): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
	static GeneratedClass(BlueprintObj: Blueprint): UnrealEngineClass;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static C(Other: UObject | any): BlueprintEditorLibrary;
}

declare class BlueprintAsyncActionBase extends UObject { 
	static Load(ResourceName: string): BlueprintAsyncActionBase;
	static Find(Outer: UObject, ResourceName: string): BlueprintAsyncActionBase;
	static GetDefaultObject(): BlueprintAsyncActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintAsyncActionBase;
	Activate(): void;
	static C(Other: UObject | any): BlueprintAsyncActionBase;
}

declare class Texture2DDynamic extends Texture { 
	Format: EPixelFormat;
	static Load(ResourceName: string): Texture2DDynamic;
	static Find(Outer: UObject, ResourceName: string): Texture2DDynamic;
	static GetDefaultObject(): Texture2DDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DDynamic;
	static C(Other: UObject | any): Texture2DDynamic;
}

declare class AsyncTaskDownloadImage extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	OnFail: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	static Load(ResourceName: string): AsyncTaskDownloadImage;
	static Find(Outer: UObject, ResourceName: string): AsyncTaskDownloadImage;
	static GetDefaultObject(): AsyncTaskDownloadImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTaskDownloadImage;
	static DownloadImage(URL: string): AsyncTaskDownloadImage;
	static C(Other: UObject | any): AsyncTaskDownloadImage;
}

declare class ContentWidget extends PanelWidget { 
	static Load(ResourceName: string): ContentWidget;
	static Find(Outer: UObject, ResourceName: string): ContentWidget;
	static GetDefaultObject(): ContentWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentWidget;
	SetContent(Content: Widget): PanelSlot;
	GetContentSlot(): PanelSlot;
	GetContent(): Widget;
	static C(Other: UObject | any): ContentWidget;
}

declare class BackgroundBlur extends ContentWidget { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bApplyAlphaToBlur: boolean;
	BlurStrength: number;
	bOverrideAutoRadiusCalculation: boolean;
	BlurRadius: number;
	CornerRadius: Vector4;
	LowQualityFallbackBrush: SlateBrush;
	static Load(ResourceName: string): BackgroundBlur;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlur;
	static GetDefaultObject(): BackgroundBlur;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlur;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetLowQualityFallbackBrush(InBrush: SlateBrush): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetCornerRadius(InCornerRadius: Vector4): void;
	SetBlurStrength(InStrength: number): void;
	SetBlurRadius(InBlurRadius: number): void;
	SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean): void;
	static C(Other: UObject | any): BackgroundBlur;
}

declare class BackgroundBlurSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): BackgroundBlurSlot;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlurSlot;
	static GetDefaultObject(): BackgroundBlurSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlurSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): BackgroundBlurSlot;
}

declare class BoolBinding extends PropertyBinding { 
	static Load(ResourceName: string): BoolBinding;
	static Find(Outer: UObject, ResourceName: string): BoolBinding;
	static GetDefaultObject(): BoolBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolBinding;
	GetValue(): boolean;
	static C(Other: UObject | any): BoolBinding;
}

declare class Border extends ContentWidget { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bShowEffectWhenDisabled: boolean;
	ContentColorAndOpacity: LinearColor;
	ContentColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	Padding: Margin;
	Background: SlateBrush;
	BackgroundDelegate: UnrealEngineDelegate<() => SlateBrush>;
	BrushColor: LinearColor;
	BrushColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	DesiredSizeScale: Vector2D;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseButtonUpEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseMoveEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseDoubleClickEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	Brush: SlateBrushAsset;
	static Load(ResourceName: string): Border;
	static Find(Outer: UObject, ResourceName: string): Border;
	static GetDefaultObject(): Border;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Border;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetDesiredSizeScale(InScale: Vector2D): void;
	SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;
	SetBrushFromTexture(Texture: Texture2D): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrushColor(InBrushColor: LinearColor): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): Border;
}

declare class BrushBinding extends PropertyBinding { 
	static Load(ResourceName: string): BrushBinding;
	static Find(Outer: UObject, ResourceName: string): BrushBinding;
	static GetDefaultObject(): BrushBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBinding;
	GetValue(): SlateBrush;
	static C(Other: UObject | any): BrushBinding;
}

declare type EButtonClickMethod = 'DownAndUp' | 'MouseDown' | 'MouseUp' | 'PreciseClick' | 'EButtonClickMethod_MAX';
declare var EButtonClickMethod : { DownAndUp:'DownAndUp',MouseDown:'MouseDown',MouseUp:'MouseUp',PreciseClick:'PreciseClick',EButtonClickMethod_MAX:'EButtonClickMethod_MAX', };
declare type EButtonTouchMethod = 'DownAndUp' | 'Down' | 'PreciseTap' | 'EButtonTouchMethod_MAX';
declare var EButtonTouchMethod : { DownAndUp:'DownAndUp',Down:'Down',PreciseTap:'PreciseTap',EButtonTouchMethod_MAX:'EButtonTouchMethod_MAX', };
declare type EButtonPressMethod = 'DownAndUp' | 'ButtonPress' | 'ButtonRelease' | 'EButtonPressMethod_MAX';
declare var EButtonPressMethod : { DownAndUp:'DownAndUp',ButtonPress:'ButtonPress',ButtonRelease:'ButtonRelease',EButtonPressMethod_MAX:'EButtonPressMethod_MAX', };
declare class Button extends ContentWidget { 
	Style: SlateWidgetStyleAsset;
	WidgetStyle: ButtonStyle;
	ColorAndOpacity: LinearColor;
	BackgroundColor: LinearColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnClicked: UnrealEngineMulticastDelegate<() => void>;
	OnPressed: UnrealEngineMulticastDelegate<() => void>;
	OnReleased: UnrealEngineMulticastDelegate<() => void>;
	OnHovered: UnrealEngineMulticastDelegate<() => void>;
	OnUnhovered: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): Button;
	static Find(Outer: UObject, ResourceName: string): Button;
	static GetDefaultObject(): Button;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Button;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetStyle(InStyle: ButtonStyle): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetBackgroundColor(InBackgroundColor: LinearColor): void;
	IsPressed(): boolean;
	static C(Other: UObject | any): Button;
}

declare class ButtonSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): ButtonSlot;
	static Find(Outer: UObject, ResourceName: string): ButtonSlot;
	static GetDefaultObject(): ButtonSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): ButtonSlot;
}

declare class CanvasPanel extends PanelWidget { 
	static Load(ResourceName: string): CanvasPanel;
	static Find(Outer: UObject, ResourceName: string): CanvasPanel;
	static GetDefaultObject(): CanvasPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanel;
	AddChildToCanvas(Content: Widget): CanvasPanelSlot;
	static C(Other: UObject | any): CanvasPanel;
}

declare class CheckBox extends ContentWidget { 
	CheckedState: ECheckBoxState;
	CheckedStateDelegate: UnrealEngineDelegate<() => ECheckBoxState>;
	WidgetStyle: CheckBoxStyle;
	Style: SlateWidgetStyleAsset;
	UncheckedImage: SlateBrushAsset;
	UncheckedHoveredImage: SlateBrushAsset;
	UncheckedPressedImage: SlateBrushAsset;
	CheckedImage: SlateBrushAsset;
	CheckedHoveredImage: SlateBrushAsset;
	CheckedPressedImage: SlateBrushAsset;
	UndeterminedImage: SlateBrushAsset;
	UndeterminedHoveredImage: SlateBrushAsset;
	UndeterminedPressedImage: SlateBrushAsset;
	HorizontalAlignment: EHorizontalAlignment;
	Padding: Margin;
	BorderBackgroundColor: SlateColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnCheckStateChanged: UnrealEngineMulticastDelegate<(bIsChecked: boolean) => void>;
	static Load(ResourceName: string): CheckBox;
	static Find(Outer: UObject, ResourceName: string): CheckBox;
	static GetDefaultObject(): CheckBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBox;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetIsChecked(InIsChecked: boolean): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetCheckedState(InCheckedState: ECheckBoxState): void;
	IsPressed(): boolean;
	IsChecked(): boolean;
	GetCheckedState(): ECheckBoxState;
	static C(Other: UObject | any): CheckBox;
}

declare class CheckedStateBinding extends PropertyBinding { 
	static Load(ResourceName: string): CheckedStateBinding;
	static Find(Outer: UObject, ResourceName: string): CheckedStateBinding;
	static GetDefaultObject(): CheckedStateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckedStateBinding;
	GetValue(): ECheckBoxState;
	static C(Other: UObject | any): CheckedStateBinding;
}

declare class CircularThrobber extends Widget { 
	NumberOfPieces: number;
	Period: number;
	Radius: number;
	PieceImage: SlateBrushAsset;
	UImage: SlateBrush;
	bEnableRadius: boolean;
	static Load(ResourceName: string): CircularThrobber;
	static Find(Outer: UObject, ResourceName: string): CircularThrobber;
	static GetDefaultObject(): CircularThrobber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircularThrobber;
	SetRadius(InRadius: number): void;
	SetPeriod(InPeriod: number): void;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	static C(Other: UObject | any): CircularThrobber;
}

declare class ColorBinding extends PropertyBinding { 
	static Load(ResourceName: string): ColorBinding;
	static Find(Outer: UObject, ResourceName: string): ColorBinding;
	static GetDefaultObject(): ColorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ColorBinding;
	GetSlateValue(): SlateColor;
	GetLinearValue(): LinearColor;
	static C(Other: UObject | any): ColorBinding;
}

declare class ComboBox extends Widget { 
	Items: UObject[];
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	bIsFocusable: boolean;
	static Load(ResourceName: string): ComboBox;
	static Find(Outer: UObject, ResourceName: string): ComboBox;
	static GetDefaultObject(): ComboBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBox;
	static C(Other: UObject | any): ComboBox;
}

declare class TableRowStyle extends SlateWidgetStyle { 
	SelectorFocusedBrush: SlateBrush;
	ActiveHoveredBrush: SlateBrush;
	ActiveBrush: SlateBrush;
	InactiveHoveredBrush: SlateBrush;
	InactiveBrush: SlateBrush;
	bUseParentRowBrush: boolean;
	ParentRowBackgroundBrush: SlateBrush;
	ParentRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundBrush: SlateBrush;
	OddRowBackgroundHoveredBrush: SlateBrush;
	OddRowBackgroundBrush: SlateBrush;
	TextColor: SlateColor;
	SelectedTextColor: SlateColor;
	DropIndicator_Above: SlateBrush;
	DropIndicator_Onto: SlateBrush;
	DropIndicator_Below: SlateBrush;
	ActiveHighlightedBrush: SlateBrush;
	InactiveHighlightedBrush: SlateBrush;
	clone() : TableRowStyle;
	static C(Other: UObject | any): TableRowStyle;
}

declare type ESelectInfo = 'OnKeyPress' | 'OnNavigation' | 'OnMouseClick' | 'Direct' | 'ESelectInfo_MAX';
declare var ESelectInfo : { OnKeyPress:'OnKeyPress',OnNavigation:'OnNavigation',OnMouseClick:'OnMouseClick',Direct:'Direct',ESelectInfo_MAX:'ESelectInfo_MAX', };
declare class ComboBoxKey extends Widget { 
	Options: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ForegroundColor: SlateColor;
	ContentPadding: Margin;
	MaxListHeight: number;
	bHasDownArrow: boolean;
	bEnableGamepadNavigationMode: boolean;
	bIsFocusable: boolean;
	OnGenerateContentWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnGenerateItemWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxKey;
	static Find(Outer: UObject, ResourceName: string): ComboBoxKey;
	static GetDefaultObject(): ComboBoxKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxKey;
	SetSelectedOption(Option: string): void;
	RemoveOption(Option: string): boolean;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxKey;
}

declare class ComboBoxString extends Widget { 
	DefaultOptions: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ContentPadding: Margin;
	MaxListHeight: number;
	HasDownArrow: boolean;
	EnableGamepadNavigationMode: boolean;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	bIsFocusable: boolean;
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxString;
	static Find(Outer: UObject, ResourceName: string): ComboBoxString;
	static GetDefaultObject(): ComboBoxString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxString;
	SetSelectedOption(Option: string): void;
	SetSelectedIndex(index: number): void;
	RemoveOption(Option: string): boolean;
	RefreshOptions(): void;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	GetSelectedIndex(): number;
	GetOptionCount(): number;
	GetOptionAtIndex(index: number): string;
	FindOptionIndex(Option: string): number;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxString;
}

declare type EDynamicBoxType = 'Horizontal' | 'Vertical' | 'Wrap' | 'VerticalWrap' | 'Radial' | 'Overlay' | 'EDynamicBoxType_MAX';
declare var EDynamicBoxType : { Horizontal:'Horizontal',Vertical:'Vertical',Wrap:'Wrap',VerticalWrap:'VerticalWrap',Radial:'Radial',Overlay:'Overlay',EDynamicBoxType_MAX:'EDynamicBoxType_MAX', };
declare class RadialBoxSettings { 
	StartingAngle: number;
	bDistributeItemsEvenly: boolean;
	AngleBetweenItems: number;
	SectorCentralAngle: number;
	clone() : RadialBoxSettings;
	static C(Other: UObject | any): RadialBoxSettings;
}

declare class UserWidgetPool { 
	ActiveWidgets: UserWidget[];
	InactiveWidgets: UserWidget[];
	clone() : UserWidgetPool;
	static C(Other: UObject | any): UserWidgetPool;
}

declare class DynamicEntryBoxBase extends Widget { 
	EntryBoxType: EDynamicBoxType;
	EntrySpacing: Vector2D;
	SpacingPattern: Vector2D[];
	EntrySizeRule: SlateChildSize;
	EntryHorizontalAlignment: EHorizontalAlignment;
	EntryVerticalAlignment: EVerticalAlignment;
	MaxElementSize: number;
	RadialBoxSettings: RadialBoxSettings;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): DynamicEntryBoxBase;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBoxBase;
	static GetDefaultObject(): DynamicEntryBoxBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBoxBase;
	SetRadialSettings(InSettings: RadialBoxSettings): void;
	SetEntrySpacing(InEntrySpacing: Vector2D): void;
	GetNumEntries(): number;
	GetAllEntries(): UserWidget[];
	static C(Other: UObject | any): DynamicEntryBoxBase;
}

declare class DynamicEntryBox extends DynamicEntryBoxBase { 
	NumDesignerPreviewEntries: number;
	EntryWidgetClass: UnrealEngineClass;
	static Load(ResourceName: string): DynamicEntryBox;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBox;
	static GetDefaultObject(): DynamicEntryBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBox;
	Reset(bDeleteWidgets: boolean): void;
	RemoveEntry(EntryWidget: UserWidget): void;
	BP_CreateEntryOfClass(EntryClass: UnrealEngineClass): UserWidget;
	BP_CreateEntry(): UserWidget;
	static C(Other: UObject | any): DynamicEntryBox;
}

declare type EVirtualKeyboardType = 'Default' | 'Number' | 'Web' | 'Email' | 'Password' | 'AlphaNumeric' | 'EVirtualKeyboardType_MAX';
declare var EVirtualKeyboardType : { Default:'Default',Number:'Number',Web:'Web',Email:'Email',Password:'Password',AlphaNumeric:'AlphaNumeric',EVirtualKeyboardType_MAX:'EVirtualKeyboardType_MAX', };
declare class VirtualKeyboardOptions { 
	bEnableAutocorrect: boolean;
	clone() : VirtualKeyboardOptions;
	static C(Other: UObject | any): VirtualKeyboardOptions;
}

declare type EVirtualKeyboardTrigger = 'OnFocusByPointer' | 'OnAllFocusEvents' | 'EVirtualKeyboardTrigger_MAX';
declare var EVirtualKeyboardTrigger : { OnFocusByPointer:'OnFocusByPointer',OnAllFocusEvents:'OnAllFocusEvents',EVirtualKeyboardTrigger_MAX:'EVirtualKeyboardTrigger_MAX', };
declare type EVirtualKeyboardDismissAction = 'TextChangeOnDismiss' | 'TextCommitOnAccept' | 'TextCommitOnDismiss' | 'EVirtualKeyboardDismissAction_MAX';
declare var EVirtualKeyboardDismissAction : { TextChangeOnDismiss:'TextChangeOnDismiss',TextCommitOnAccept:'TextCommitOnAccept',TextCommitOnDismiss:'TextCommitOnDismiss',EVirtualKeyboardDismissAction_MAX:'EVirtualKeyboardDismissAction_MAX', };
declare type ETextJustify = 'Left' | 'Center' | 'Right' | 'ETextJustify_MAX';
declare var ETextJustify : { Left:'Left',Center:'Center',Right:'Right',ETextJustify_MAX:'ETextJustify_MAX', };
declare type ETextShapingMethod = 'Auto' | 'KerningOnly' | 'FullShaping' | 'ETextShapingMethod_MAX';
declare var ETextShapingMethod : { Auto:'Auto',KerningOnly:'KerningOnly',FullShaping:'FullShaping',ETextShapingMethod_MAX:'ETextShapingMethod_MAX', };
declare type ETextFlowDirection = 'Auto' | 'LeftToRight' | 'RightToLeft' | 'ETextFlowDirection_MAX';
declare var ETextFlowDirection : { Auto:'Auto',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',ETextFlowDirection_MAX:'ETextFlowDirection_MAX', };
declare class ShapedTextOptions { 
	bOverride_TextShapingMethod: boolean;
	bOverride_TextFlowDirection: boolean;
	TextShapingMethod: ETextShapingMethod;
	TextFlowDirection: ETextFlowDirection;
	clone() : ShapedTextOptions;
	static C(Other: UObject | any): ShapedTextOptions;
}

declare type ETextCommit = 'Default' | 'OnEnter' | 'OnUserMovedFocus' | 'OnCleared' | 'ETextCommit_MAX';
declare var ETextCommit : { Default:'Default',OnEnter:'OnEnter',OnUserMovedFocus:'OnUserMovedFocus',OnCleared:'OnCleared',ETextCommit_MAX:'ETextCommit_MAX', };
declare class EditableText extends Widget { 
	text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextStyle;
	Style: SlateWidgetStyleAsset;
	BackgroundImageSelected: SlateBrushAsset;
	BackgroundImageComposing: SlateBrushAsset;
	CaretImage: SlateBrushAsset;
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): EditableText;
	static Find(Outer: UObject, ResourceName: string): EditableText;
	static GetDefaultObject(): EditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableText;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(InbIsReadyOnly: boolean): void;
	SetIsPassword(InbIsPassword: boolean): void;
	SetHintText(InHintText: string): void;
	GetText(): string;
	static C(Other: UObject | any): EditableText;
}

declare class EditableTextBox extends Widget { 
	text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	Style: SlateWidgetStyleAsset;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	Font: SlateFontInfo;
	ForegroundColor: LinearColor;
	BackgroundColor: LinearColor;
	ReadOnlyForegroundColor: LinearColor;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	Padding: Margin;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): EditableTextBox;
	static Find(Outer: UObject, ResourceName: string): EditableTextBox;
	static GetDefaultObject(): EditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBox;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetIsPassword(bIsPassword: boolean): void;
	SetHintText(InText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	HasError(): boolean;
	GetText(): string;
	ClearError(): void;
	static C(Other: UObject | any): EditableTextBox;
}

declare class ExpandableAreaStyle extends SlateWidgetStyle { 
	CollapsedImage: SlateBrush;
	ExpandedImage: SlateBrush;
	RolloutAnimationSeconds: number;
	clone() : ExpandableAreaStyle;
	static C(Other: UObject | any): ExpandableAreaStyle;
}

declare class ExpandableArea extends Widget { 
	Style: ExpandableAreaStyle;
	BorderBrush: SlateBrush;
	BorderColor: SlateColor;
	bIsExpanded: boolean;
	MaxHeight: number;
	HeaderPadding: Margin;
	AreaPadding: Margin;
	OnExpansionChanged: UnrealEngineMulticastDelegate<(Area: ExpandableArea, bIsExpanded: boolean) => void>;
	HeaderContent: Widget;
	BodyContent: Widget;
	static Load(ResourceName: string): ExpandableArea;
	static Find(Outer: UObject, ResourceName: string): ExpandableArea;
	static GetDefaultObject(): ExpandableArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExpandableArea;
	SetIsExpanded_Animated(IsExpanded: boolean): void;
	SetIsExpanded(IsExpanded: boolean): void;
	GetIsExpanded(): boolean;
	static C(Other: UObject | any): ExpandableArea;
}

declare class FloatBinding extends PropertyBinding { 
	static Load(ResourceName: string): FloatBinding;
	static Find(Outer: UObject, ResourceName: string): FloatBinding;
	static GetDefaultObject(): FloatBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatBinding;
	GetValue(): number;
	static C(Other: UObject | any): FloatBinding;
}

declare class GridPanel extends PanelWidget { 
	ColumnFill: number[];
	RowFill: number[];
	static Load(ResourceName: string): GridPanel;
	static Find(Outer: UObject, ResourceName: string): GridPanel;
	static GetDefaultObject(): GridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPanel;
	SetRowFill(ColumnIndex: number,Coefficient: number): void;
	SetColumnFill(ColumnIndex: number,Coefficient: number): void;
	AddChildToGrid(Content: Widget,InRow: number,InColumn: number): GridSlot;
	static C(Other: UObject | any): GridPanel;
}

declare class HorizontalBox extends PanelWidget { 
	static Load(ResourceName: string): HorizontalBox;
	static Find(Outer: UObject, ResourceName: string): HorizontalBox;
	static GetDefaultObject(): HorizontalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBox;
	AddChildToHorizontalBox(Content: Widget): HorizontalBoxSlot;
	static C(Other: UObject | any): HorizontalBox;
}

declare class UImage extends Widget { 
	UImage: SlateBrushAsset;
	Brush: SlateBrush;
	BrushDelegate: UnrealEngineDelegate<() => SlateBrush>;
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	static Load(ResourceName: string): UImage;
	static Find(Outer: UObject, ResourceName: string): UImage;
	static GetDefaultObject(): UImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UImage;
	SetOpacity(InOpacity: number): void;
	SetDesiredSizeOverride(DesiredSize: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetBrushTintColor(TintColor: SlateColor): void;
	SetBrushResourceObject(ResourceObject: UObject): void;
	SetBrushFromTextureDynamic(Texture: Texture2DDynamic,bMatchSize: boolean): void;
	SetBrushFromTexture(Texture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftTexture(SoftTexture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftMaterial(SoftMaterial: MaterialInterface): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): UImage;
}

declare class InputKeySelector extends Widget { 
	WidgetStyle: ButtonStyle;
	TextStyle: TextBlockStyle;
	SelectedKey: InputChord;
	Font: SlateFontInfo;
	Margin: Margin;
	ColorAndOpacity: LinearColor;
	KeySelectionText: string;
	NoKeySpecifiedText: string;
	bAllowModifierKeys: boolean;
	bAllowGamepadKeys: boolean;
	EscapeKeys: Key[];
	OnKeySelected: UnrealEngineMulticastDelegate<(SelectedKey: InputChord) => void>;
	OnIsSelectingKeyChanged: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): InputKeySelector;
	static Find(Outer: UObject, ResourceName: string): InputKeySelector;
	static GetDefaultObject(): InputKeySelector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputKeySelector;
	SetTextBlockVisibility(InVisibility: ESlateVisibility): void;
	SetSelectedKey(InSelectedKey: InputChord): void;
	SetNoKeySpecifiedText(InNoKeySpecifiedText: string): void;
	SetKeySelectionText(InKeySelectionText: string): void;
	SetEscapeKeys(InKeys: Key[]): void;
	SetAllowModifierKeys(bInAllowModifierKeys: boolean): void;
	SetAllowGamepadKeys(bInAllowGamepadKeys: boolean): void;
	GetIsSelectingKey(): boolean;
	static C(Other: UObject | any): InputKeySelector;
}

declare class Int32Binding extends PropertyBinding { 
	static Load(ResourceName: string): Int32Binding;
	static Find(Outer: UObject, ResourceName: string): Int32Binding;
	static GetDefaultObject(): Int32Binding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int32Binding;
	GetValue(): number;
	static C(Other: UObject | any): Int32Binding;
}

declare class InvalidationBox extends ContentWidget { 
	bCanCache: boolean;
	CacheRelativeTransforms: boolean;
	static Load(ResourceName: string): InvalidationBox;
	static Find(Outer: UObject, ResourceName: string): InvalidationBox;
	static GetDefaultObject(): InvalidationBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InvalidationBox;
	SetCanCache(CanCache: boolean): void;
	InvalidateCache(): void;
	GetCanCache(): boolean;
	static C(Other: UObject | any): InvalidationBox;
}

declare class UserListEntry extends Interface { 
	static Load(ResourceName: string): UserListEntry;
	static Find(Outer: UObject, ResourceName: string): UserListEntry;
	static GetDefaultObject(): UserListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntry;
	BP_OnItemSelectionChanged(bIsSelected: boolean): void;
	BP_OnItemExpansionChanged(bIsExpanded: boolean): void;
	BP_OnEntryReleased(): void;
	static C(Other: UObject | any): UserListEntry;
}

declare class UserListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserListEntryLibrary;
	static GetDefaultObject(): UserListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntryLibrary;
	static C(Other: UObject | any): UserListEntryLibrary;
}

declare class UserObjectListEntry extends UserListEntry { 
	static Load(ResourceName: string): UserObjectListEntry;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntry;
	static GetDefaultObject(): UserObjectListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntry;
	OnListItemObjectSet(ListItemObject: UObject): void;
	static C(Other: UObject | any): UserObjectListEntry;
}

declare class UserObjectListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserObjectListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntryLibrary;
	static GetDefaultObject(): UserObjectListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntryLibrary;
	static C(Other: UObject | any): UserObjectListEntryLibrary;
}

declare class ListViewBase extends Widget { 
	EntryWidgetClass: UnrealEngineClass;
	WheelScrollMultiplier: number;
	bEnableScrollAnimation: boolean;
	AllowOverscroll: boolean;
	bEnableRightClickScrolling: boolean;
	bEnableFixedLineOffset: boolean;
	FixedLineScrollOffset: number;
	bAllowDragging: boolean;
	BP_OnEntryGenerated: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	BP_OnEntryReleased: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	NumDesignerPreviewEntries: number;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): ListViewBase;
	static Find(Outer: UObject, ResourceName: string): ListViewBase;
	static GetDefaultObject(): ListViewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewBase;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollOffset(InScrollOffset: number): void;
	SetScrollbarVisibility(InVisibility: ESlateVisibility): void;
	ScrollToTop(): void;
	ScrollToBottom(): void;
	RequestRefresh(): void;
	RegenerateAllEntries(): void;
	GetScrollOffset(): number;
	GetDisplayedEntryWidgets(): UserWidget[];
	static C(Other: UObject | any): ListViewBase;
}

declare class TableViewStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	clone() : TableViewStyle;
	static C(Other: UObject | any): TableViewStyle;
}

declare type EOrientation = 'Orient_Horizontal' | 'Orient_Vertical' | 'Orient_MAX';
declare var EOrientation : { Orient_Horizontal:'Orient_Horizontal',Orient_Vertical:'Orient_Vertical',Orient_MAX:'Orient_MAX', };
declare type ESelectionMode = 'None' | 'Single' | 'SingleToggle' | 'Multi' | 'ESelectionMode_MAX';
declare var ESelectionMode : { None:'None',Single:'Single',SingleToggle:'SingleToggle',Multi:'Multi',ESelectionMode_MAX:'ESelectionMode_MAX', };
declare type EConsumeMouseWheel = 'WhenScrollingPossible' | 'Always' | 'Never' | 'EConsumeMouseWheel_MAX';
declare var EConsumeMouseWheel : { WhenScrollingPossible:'WhenScrollingPossible',Always:'Always',Never:'Never',EConsumeMouseWheel_MAX:'EConsumeMouseWheel_MAX', };
declare class ListView extends ListViewBase { 
	WidgetStyle: TableViewStyle;
	ScrollBarStyle: ScrollBarStyle;
	Orientation: EOrientation;
	SelectionMode: ESelectionMode;
	ConsumeMouseWheel: EConsumeMouseWheel;
	bClearSelectionOnClick: boolean;
	bIsFocusable: boolean;
	EntrySpacing: number;
	bReturnFocusToSelection: boolean;
	ListItems: UObject[];
	BP_OnEntryInitialized: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	BP_OnItemClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemDoubleClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemIsHoveredChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsHovered: boolean) => void>;
	BP_OnItemSelectionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsSelected: boolean) => void>;
	BP_OnItemScrolledIntoView: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	static Load(ResourceName: string): ListView;
	static Find(Outer: UObject, ResourceName: string): ListView;
	static GetDefaultObject(): ListView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListView;
	SetSelectionMode(SelectionMode: ESelectionMode): void;
	SetSelectedIndex(index: number): void;
	ScrollIndexIntoView(index: number): void;
	RemoveItem(Item: UObject): void;
	OnListItemOuterEndPlayed(ItemOuter: Actor,EndPlayReason: EEndPlayReason): void;
	OnListItemEndPlayed(Item: Actor,EndPlayReason: EEndPlayReason): void;
	NavigateToIndex(index: number): void;
	IsRefreshPending(): boolean;
	GetNumItems(): number;
	GetListItems(): UObject[];
	GetItemAt(index: number): UObject;
	GetIndexForItem(Item: UObject): number;
	ClearListItems(): void;
	BP_SetSelectedItem(Item: UObject): void;
	BP_SetListItems(InListItems: UObject[]): void;
	BP_SetItemSelection(Item: UObject,bSelected: boolean): void;
	BP_ScrollItemIntoView(Item: UObject): void;
	BP_NavigateToItem(Item: UObject): void;
	BP_IsItemVisible(Item: UObject): boolean;
	BP_GetSelectedItems(Items?: UObject[]): {Items: UObject[], $: boolean};
	BP_GetSelectedItem(): UObject;
	BP_GetNumItemsSelected(): number;
	BP_ClearSelection(): void;
	BP_CancelScrollIntoView(): void;
	AddItem(Item: UObject): void;
	static C(Other: UObject | any): ListView;
}

declare class ListViewDesignerPreviewItem extends UObject { 
	static Load(ResourceName: string): ListViewDesignerPreviewItem;
	static Find(Outer: UObject, ResourceName: string): ListViewDesignerPreviewItem;
	static GetDefaultObject(): ListViewDesignerPreviewItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewDesignerPreviewItem;
	static C(Other: UObject | any): ListViewDesignerPreviewItem;
}

declare type EMenuPlacement = 'MenuPlacement_BelowAnchor' | 'MenuPlacement_CenteredBelowAnchor' | 'MenuPlacement_BelowRightAnchor' | 'MenuPlacement_ComboBox' | 'MenuPlacement_ComboBoxRight' | 'MenuPlacement_MenuRight' | 'MenuPlacement_AboveAnchor' | 'MenuPlacement_CenteredAboveAnchor' | 'MenuPlacement_AboveRightAnchor' | 'MenuPlacement_MenuLeft' | 'MenuPlacement_Center' | 'MenuPlacement_RightLeftCenter' | 'MenuPlacement_MatchBottomLeft' | 'MenuPlacement_MAX';
declare var EMenuPlacement : { MenuPlacement_BelowAnchor:'MenuPlacement_BelowAnchor',MenuPlacement_CenteredBelowAnchor:'MenuPlacement_CenteredBelowAnchor',MenuPlacement_BelowRightAnchor:'MenuPlacement_BelowRightAnchor',MenuPlacement_ComboBox:'MenuPlacement_ComboBox',MenuPlacement_ComboBoxRight:'MenuPlacement_ComboBoxRight',MenuPlacement_MenuRight:'MenuPlacement_MenuRight',MenuPlacement_AboveAnchor:'MenuPlacement_AboveAnchor',MenuPlacement_CenteredAboveAnchor:'MenuPlacement_CenteredAboveAnchor',MenuPlacement_AboveRightAnchor:'MenuPlacement_AboveRightAnchor',MenuPlacement_MenuLeft:'MenuPlacement_MenuLeft',MenuPlacement_Center:'MenuPlacement_Center',MenuPlacement_RightLeftCenter:'MenuPlacement_RightLeftCenter',MenuPlacement_MatchBottomLeft:'MenuPlacement_MatchBottomLeft',MenuPlacement_MAX:'MenuPlacement_MAX', };
declare class MenuAnchor extends ContentWidget { 
	MenuClass: UnrealEngineClass;
	OnGetMenuContentEvent: UnrealEngineDelegate<() => Widget>;
	OnGetUserMenuContentEvent: UnrealEngineDelegate<() => UserWidget>;
	PLACEMENT: EMenuPlacement;
	bFitInWindow: boolean;
	ShouldDeferPaintingAfterWindowContent: boolean;
	UseApplicationMenuStack: boolean;
	OnMenuOpenChanged: UnrealEngineMulticastDelegate<(bIsOpen: boolean) => void>;
	static Load(ResourceName: string): MenuAnchor;
	static Find(Outer: UObject, ResourceName: string): MenuAnchor;
	static GetDefaultObject(): MenuAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MenuAnchor;
	ToggleOpen(bFocusOnOpen: boolean): void;
	ShouldOpenDueToClick(): boolean;
	SetPlacement(InPlacement: EMenuPlacement): void;
	Open(bFocusMenu: boolean): void;
	IsOpen(): boolean;
	HasOpenSubMenus(): boolean;
	GetMenuPosition(): Vector2D;
	FitInWindow(bFit: boolean): void;
	Close(): void;
	static C(Other: UObject | any): MenuAnchor;
}

declare class MouseCursorBinding extends PropertyBinding { 
	static Load(ResourceName: string): MouseCursorBinding;
	static Find(Outer: UObject, ResourceName: string): MouseCursorBinding;
	static GetDefaultObject(): MouseCursorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorBinding;
	GetValue(): EMouseCursor;
	static C(Other: UObject | any): MouseCursorBinding;
}

declare class MovieScenePropertyInstantiatorSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static GetDefaultObject(): MovieScenePropertyInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyInstantiatorSystem;
	static C(Other: UObject | any): MovieScenePropertyInstantiatorSystem;
}

declare class MovieScenePropertySystem extends MovieSceneEntitySystem { 
	InstantiatorSystem: MovieScenePropertyInstantiatorSystem;
	static Load(ResourceName: string): MovieScenePropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertySystem;
	static GetDefaultObject(): MovieScenePropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertySystem;
	static C(Other: UObject | any): MovieScenePropertySystem;
}

declare class MovieScene2DTransformPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieScene2DTransformPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformPropertySystem;
	static GetDefaultObject(): MovieScene2DTransformPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformPropertySystem;
	static C(Other: UObject | any): MovieScene2DTransformPropertySystem;
}

declare class MovieScene2DTransformMask { 
	mask: any;
	clone() : MovieScene2DTransformMask;
	static C(Other: UObject | any): MovieScene2DTransformMask;
}

declare class MovieScene2DTransformSection extends MovieSceneSection { 
	TransformMask: MovieScene2DTransformMask;
	Translation: MovieSceneFloatChannel;
	Rotation: MovieSceneFloatChannel;
	Scale: MovieSceneFloatChannel;
	Shear: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieScene2DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformSection;
	static GetDefaultObject(): MovieScene2DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformSection;
	static C(Other: UObject | any): MovieScene2DTransformSection;
}

declare class MovieScenePropertyBinding { 
	PropertyName: string;
	PropertyPath: string;
	bCanUseClassLookup: boolean;
	clone() : MovieScenePropertyBinding;
	static C(Other: UObject | any): MovieScenePropertyBinding;
}

declare class MovieScenePropertyTrack extends MovieSceneNameableTrack { 
	UniqueTrackName: string;
	PropertyName: string;
	PropertyPath: string;
	SectionToKey: MovieSceneSection;
	PropertyBinding: MovieScenePropertyBinding;
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieScenePropertyTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyTrack;
	static GetDefaultObject(): MovieScenePropertyTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyTrack;
	static C(Other: UObject | any): MovieScenePropertyTrack;
	GetPropertyName(): string;
	GetPropertyPath(): string;
	GetUniqueTrackName(): string;
	SetPropertyNameAndPath(InPropertyName: string,InPropertyPath: string): void;
	static GetPropertyName(Track: MovieScenePropertyTrack): string;
	static GetPropertyPath(Track: MovieScenePropertyTrack): string;
	static GetUniqueTrackName(Track: MovieScenePropertyTrack): string;
	static SetPropertyNameAndPath(Track: MovieScenePropertyTrack,InPropertyName: string,InPropertyPath: string): void;
}

declare class MovieScene2DTransformTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieScene2DTransformTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformTrack;
	static GetDefaultObject(): MovieScene2DTransformTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformTrack;
	static C(Other: UObject | any): MovieScene2DTransformTrack;
}

declare class MovieSceneMarginPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieSceneMarginPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginPropertySystem;
	static GetDefaultObject(): MovieSceneMarginPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginPropertySystem;
	static C(Other: UObject | any): MovieSceneMarginPropertySystem;
}

declare class MovieSceneMarginSection extends MovieSceneSection { 
	TopCurve: MovieSceneFloatChannel;
	LeftCurve: MovieSceneFloatChannel;
	RightCurve: MovieSceneFloatChannel;
	BottomCurve: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieSceneMarginSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginSection;
	static GetDefaultObject(): MovieSceneMarginSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginSection;
	static C(Other: UObject | any): MovieSceneMarginSection;
}

declare class MovieSceneMarginTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieSceneMarginTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginTrack;
	static GetDefaultObject(): MovieSceneMarginTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginTrack;
	static C(Other: UObject | any): MovieSceneMarginTrack;
}

declare class MovieSceneMaterialTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMaterialTrack;
	static GetDefaultObject(): MovieSceneMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMaterialTrack;
	static C(Other: UObject | any): MovieSceneMaterialTrack;
}

declare class MovieSceneWidgetMaterialTrack extends MovieSceneMaterialTrack { 
	BrushPropertyNamePath: string[];
	TrackName: string;
	static Load(ResourceName: string): MovieSceneWidgetMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneWidgetMaterialTrack;
	static GetDefaultObject(): MovieSceneWidgetMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneWidgetMaterialTrack;
	static C(Other: UObject | any): MovieSceneWidgetMaterialTrack;
}

declare type ETextWrappingPolicy = 'DefaultWrapping' | 'AllowPerCharacterWrapping' | 'ETextWrappingPolicy_MAX';
declare var ETextWrappingPolicy : { DefaultWrapping:'DefaultWrapping',AllowPerCharacterWrapping:'AllowPerCharacterWrapping',ETextWrappingPolicy_MAX:'ETextWrappingPolicy_MAX', };
declare class TextLayoutWidget extends Widget { 
	ShapedTextOptions: ShapedTextOptions;
	Justification: ETextJustify;
	WrappingPolicy: ETextWrappingPolicy;
	AutoWrapText: boolean;
	WrapTextAt: number;
	Margin: Margin;
	LineHeightPercentage: number;
	static Load(ResourceName: string): TextLayoutWidget;
	static Find(Outer: UObject, ResourceName: string): TextLayoutWidget;
	static GetDefaultObject(): TextLayoutWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextLayoutWidget;
	SetJustification(InJustification: ETextJustify): void;
	static C(Other: UObject | any): TextLayoutWidget;
}

declare class MultiLineEditableText extends TextLayoutWidget { 
	text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	Font: SlateFontInfo;
	SelectAllTextWhenFocused: boolean;
	ClearTextSelectionOnFocusLoss: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): MultiLineEditableText;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableText;
	static GetDefaultObject(): MultiLineEditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableText;
	SetWidgetStyle(InWidgetStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	GetText(): string;
	GetHintText(): string;
	static C(Other: UObject | any): MultiLineEditableText;
}

declare class MultiLineEditableTextBox extends TextLayoutWidget { 
	text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	TextStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Style: SlateWidgetStyleAsset;
	Font: SlateFontInfo;
	ForegroundColor: LinearColor;
	BackgroundColor: LinearColor;
	ReadOnlyForegroundColor: LinearColor;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): MultiLineEditableTextBox;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableTextBox;
	static GetDefaultObject(): MultiLineEditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableTextBox;
	SetTextStyle(InTextStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	GetText(): string;
	GetHintText(): string;
	static C(Other: UObject | any): MultiLineEditableTextBox;
}

declare class NamedSlot extends ContentWidget { 
	static Load(ResourceName: string): NamedSlot;
	static Find(Outer: UObject, ResourceName: string): NamedSlot;
	static GetDefaultObject(): NamedSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlot;
	static C(Other: UObject | any): NamedSlot;
}

declare class NamedSlotInterface extends Interface { 
	static Load(ResourceName: string): NamedSlotInterface;
	static Find(Outer: UObject, ResourceName: string): NamedSlotInterface;
	static GetDefaultObject(): NamedSlotInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlotInterface;
	static C(Other: UObject | any): NamedSlotInterface;
}

declare class NativeWidgetHost extends Widget { 
	static Load(ResourceName: string): NativeWidgetHost;
	static Find(Outer: UObject, ResourceName: string): NativeWidgetHost;
	static GetDefaultObject(): NativeWidgetHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NativeWidgetHost;
	static C(Other: UObject | any): NativeWidgetHost;
	SetContent(SlateWidget: JavascriptSlateWidget): Widget;
	static SetContent(TargetWidget: NativeWidgetHost,SlateWidget: JavascriptSlateWidget): Widget;
}

declare class Overlay extends PanelWidget { 
	static Load(ResourceName: string): Overlay;
	static Find(Outer: UObject, ResourceName: string): Overlay;
	static GetDefaultObject(): Overlay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Overlay;
	AddChildToOverlay(Content: Widget): OverlaySlot;
	static C(Other: UObject | any): Overlay;
}

declare type EProgressBarFillType = 'LeftToRight' | 'RightToLeft' | 'FillFromCenter' | 'FillFromCenterHorizontal' | 'FillFromCenterVertical' | 'TopToBottom' | 'BottomToTop' | 'EProgressBarFillType_MAX';
declare var EProgressBarFillType : { LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',FillFromCenter:'FillFromCenter',FillFromCenterHorizontal:'FillFromCenterHorizontal',FillFromCenterVertical:'FillFromCenterVertical',TopToBottom:'TopToBottom',BottomToTop:'BottomToTop',EProgressBarFillType_MAX:'EProgressBarFillType_MAX', };
declare type EProgressBarFillStyle = 'Mask' | 'Scale' | 'EProgressBarFillStyle_MAX';
declare var EProgressBarFillStyle : { Mask:'Mask',Scale:'Scale',EProgressBarFillStyle_MAX:'EProgressBarFillStyle_MAX', };
declare class ProgressBar extends Widget { 
	WidgetStyle: ProgressBarStyle;
	Style: SlateWidgetStyleAsset;
	BackgroundImage: SlateBrushAsset;
	FillImage: SlateBrushAsset;
	MarqueeImage: SlateBrushAsset;
	Percent: number;
	BarFillType: EProgressBarFillType;
	BarFillStyle: EProgressBarFillStyle;
	bIsMarquee: boolean;
	BorderPadding: Vector2D;
	PercentDelegate: UnrealEngineDelegate<() => number>;
	FillColorAndOpacity: LinearColor;
	FillColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	static Load(ResourceName: string): ProgressBar;
	static Find(Outer: UObject, ResourceName: string): ProgressBar;
	static GetDefaultObject(): ProgressBar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressBar;
	SetPercent(InPercent: number): void;
	SetIsMarquee(InbIsMarquee: boolean): void;
	SetFillColorAndOpacity(InColor: LinearColor): void;
	static C(Other: UObject | any): ProgressBar;
}

declare class RetainerBox extends ContentWidget { 
	bRetainRender: boolean;
	RenderOnInvalidation: boolean;
	RenderOnPhase: boolean;
	Phase: number;
	PhaseCount: number;
	EffectMaterial: MaterialInterface;
	TextureParameter: string;
	static Load(ResourceName: string): RetainerBox;
	static Find(Outer: UObject, ResourceName: string): RetainerBox;
	static GetDefaultObject(): RetainerBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RetainerBox;
	SetTextureParameter(TextureParameter: string): void;
	SetRetainRendering(bInRetainRendering: boolean): void;
	SetRenderingPhase(RenderPhase: number,TotalPhases: number): void;
	SetEffectMaterial(EffectMaterial: MaterialInterface): void;
	RequestRender(): void;
	GetEffectMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): RetainerBox;
}

declare class RichTextBlockDecorator extends UObject { 
	static Load(ResourceName: string): RichTextBlockDecorator;
	static Find(Outer: UObject, ResourceName: string): RichTextBlockDecorator;
	static GetDefaultObject(): RichTextBlockDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockDecorator;
	static C(Other: UObject | any): RichTextBlockDecorator;
}

declare class RichTextBlock extends TextLayoutWidget { 
	text: string;
	TextStyleSet: DataTable;
	DecoratorClasses: UnrealEngineClass[];
	bOverrideDefaultStyle: boolean;
	DefaultTextStyleOverride: TextBlockStyle;
	MinDesiredWidth: number;
	TextTransformPolicy: ETextTransformPolicy;
	TextOverflowPolicy: ETextOverflowPolicy;
	DefaultTextStyle: TextBlockStyle;
	InstanceDecorators: RichTextBlockDecorator[];
	static Load(ResourceName: string): RichTextBlock;
	static Find(Outer: UObject, ResourceName: string): RichTextBlock;
	static GetDefaultObject(): RichTextBlock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlock;
	SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;
	SetTextStyleSet(NewTextStyleSet: DataTable): void;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetDefaultTextStyle(InDefaultTextStyle: TextBlockStyle): void;
	SetDefaultStrikeBrush(InStrikeBrush?: SlateBrush): {InStrikeBrush: SlateBrush};
	SetDefaultShadowOffset(InShadowOffset: Vector2D): void;
	SetDefaultShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetDefaultFont(InFontInfo: SlateFontInfo): void;
	SetDefaultColorAndOpacity(InColorAndOpacity: SlateColor): void;
	SetAutoWrapText(InAutoTextWrap: boolean): void;
	RefreshTextLayout(): void;
	GetText(): string;
	GetDefaultDynamicMaterial(): MaterialInstanceDynamic;
	GetDecoratorByClass(DecoratorClass: UnrealEngineClass): RichTextBlockDecorator;
	ClearAllDefaultStyleOverrides(): void;
	static C(Other: UObject | any): RichTextBlock;
}

declare class RichTextBlockImageDecorator extends RichTextBlockDecorator { 
	ImageSet: DataTable;
	static Load(ResourceName: string): RichTextBlockImageDecorator;
	static Find(Outer: UObject, ResourceName: string): RichTextBlockImageDecorator;
	static GetDefaultObject(): RichTextBlockImageDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockImageDecorator;
	static C(Other: UObject | any): RichTextBlockImageDecorator;
}

declare class SafeZone extends ContentWidget { 
	PadLeft: boolean;
	PadRight: boolean;
	PadTop: boolean;
	PadBottom: boolean;
	static Load(ResourceName: string): SafeZone;
	static Find(Outer: UObject, ResourceName: string): SafeZone;
	static GetDefaultObject(): SafeZone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SafeZone;
	SetSidesToPad(InPadLeft: boolean,InPadRight: boolean,InPadTop: boolean,InPadBottom: boolean): void;
	static C(Other: UObject | any): SafeZone;
}

declare type EStretch = 'None' | 'Fill' | 'ScaleToFit' | 'ScaleToFitX' | 'ScaleToFitY' | 'ScaleToFill' | 'ScaleBySafeZone' | 'UserSpecified' | 'EStretch_MAX';
declare var EStretch : { None:'None',Fill:'Fill',ScaleToFit:'ScaleToFit',ScaleToFitX:'ScaleToFitX',ScaleToFitY:'ScaleToFitY',ScaleToFill:'ScaleToFill',ScaleBySafeZone:'ScaleBySafeZone',UserSpecified:'UserSpecified',EStretch_MAX:'EStretch_MAX', };
declare type EStretchDirection = 'Both' | 'DownOnly' | 'UpOnly' | 'EStretchDirection_MAX';
declare var EStretchDirection : { Both:'Both',DownOnly:'DownOnly',UpOnly:'UpOnly',EStretchDirection_MAX:'EStretchDirection_MAX', };
declare class ScaleBox extends ContentWidget { 
	Stretch: EStretch;
	StretchDirection: EStretchDirection;
	UserSpecifiedScale: number;
	IgnoreInheritedScale: boolean;
	static Load(ResourceName: string): ScaleBox;
	static Find(Outer: UObject, ResourceName: string): ScaleBox;
	static GetDefaultObject(): ScaleBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleBox;
	SetUserSpecifiedScale(InUserSpecifiedScale: number): void;
	SetStretchDirection(InStretchDirection: EStretchDirection): void;
	SetStretch(InStretch: EStretch): void;
	SetIgnoreInheritedScale(bInIgnoreInheritedScale: boolean): void;
	static C(Other: UObject | any): ScaleBox;
}

declare class ScrollBar extends Widget { 
	WidgetStyle: ScrollBarStyle;
	Style: SlateWidgetStyleAsset;
	bAlwaysShowScrollbar: boolean;
	bAlwaysShowScrollbarTrack: boolean;
	Orientation: EOrientation;
	Thickness: Vector2D;
	Padding: Margin;
	static Load(ResourceName: string): ScrollBar;
	static Find(Outer: UObject, ResourceName: string): ScrollBar;
	static GetDefaultObject(): ScrollBar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBar;
	SetState(InOffsetFraction: number,InThumbSizeFraction: number): void;
	static C(Other: UObject | any): ScrollBar;
}

declare type EDescendantScrollDestination = 'IntoView' | 'TopOrLeft' | 'Center' | 'BottomOrRight' | 'EDescendantScrollDestination_MAX';
declare var EDescendantScrollDestination : { IntoView:'IntoView',TopOrLeft:'TopOrLeft',Center:'Center',BottomOrRight:'BottomOrRight',EDescendantScrollDestination_MAX:'EDescendantScrollDestination_MAX', };
declare type EScrollWhenFocusChanges = 'NoScroll' | 'InstantScroll' | 'AnimatedScroll' | 'EScrollWhenFocusChanges_MAX';
declare var EScrollWhenFocusChanges : { NoScroll:'NoScroll',InstantScroll:'InstantScroll',AnimatedScroll:'AnimatedScroll',EScrollWhenFocusChanges_MAX:'EScrollWhenFocusChanges_MAX', };
declare class ScrollBox extends PanelWidget { 
	WidgetStyle: ScrollBoxStyle;
	WidgetBarStyle: ScrollBarStyle;
	Style: SlateWidgetStyleAsset;
	BarStyle: SlateWidgetStyleAsset;
	Orientation: EOrientation;
	ScrollBarVisibility: ESlateVisibility;
	ConsumeMouseWheel: EConsumeMouseWheel;
	ScrollbarThickness: Vector2D;
	ScrollbarPadding: Margin;
	AlwaysShowScrollbar: boolean;
	AlwaysShowScrollbarTrack: boolean;
	AllowOverscroll: boolean;
	BackPadScrolling: boolean;
	FrontPadScrolling: boolean;
	bAnimateWheelScrolling: boolean;
	NavigationDestination: EDescendantScrollDestination;
	NavigationScrollPadding: number;
	ScrollWhenFocusChanges: EScrollWhenFocusChanges;
	bAllowRightClickDragScrolling: boolean;
	WheelScrollMultiplier: number;
	OnUserScrolled: UnrealEngineMulticastDelegate<(CurrentOffset: number) => void>;
	static Load(ResourceName: string): ScrollBox;
	static Find(Outer: UObject, ResourceName: string): ScrollBox;
	static GetDefaultObject(): ScrollBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBox;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollWhenFocusChanges(NewScrollWhenFocusChanges: EScrollWhenFocusChanges): void;
	SetScrollOffset(NewScrollOffset: number): void;
	SetScrollBarVisibility(NewScrollBarVisibility: ESlateVisibility): void;
	SetScrollbarThickness(NewScrollbarThickness: Vector2D): void;
	SetScrollbarPadding(NewScrollbarPadding: Margin): void;
	SetOrientation(NewOrientation: EOrientation): void;
	SetNavigationDestination(NewNavigationDestination: EDescendantScrollDestination): void;
	SetConsumeMouseWheel(NewConsumeMouseWheel: EConsumeMouseWheel): void;
	SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean): void;
	SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean): void;
	SetAllowOverscroll(NewAllowOverscroll: boolean): void;
	ScrollWidgetIntoView(WidgetToFind: Widget,AnimateScroll: boolean,ScrollDestination: EDescendantScrollDestination,Padding: number): void;
	ScrollToStart(): void;
	ScrollToEnd(): void;
	GetViewOffsetFraction(): number;
	GetScrollOffsetOfEnd(): number;
	GetScrollOffset(): number;
	EndInertialScrolling(): void;
	static C(Other: UObject | any): ScrollBox;
}

declare class SizeBox extends ContentWidget { 
	WidthOverride: number;
	HeightOverride: number;
	MinDesiredWidth: number;
	MinDesiredHeight: number;
	MaxDesiredWidth: number;
	MaxDesiredHeight: number;
	MinAspectRatio: number;
	MaxAspectRatio: number;
	bOverride_WidthOverride: boolean;
	bOverride_HeightOverride: boolean;
	bOverride_MinDesiredWidth: boolean;
	bOverride_MinDesiredHeight: boolean;
	bOverride_MaxDesiredWidth: boolean;
	bOverride_MaxDesiredHeight: boolean;
	bOverride_MinAspectRatio: boolean;
	bOverride_MaxAspectRatio: boolean;
	static Load(ResourceName: string): SizeBox;
	static Find(Outer: UObject, ResourceName: string): SizeBox;
	static GetDefaultObject(): SizeBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SizeBox;
	SetWidthOverride(InWidthOverride: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetMinDesiredHeight(InMinDesiredHeight: number): void;
	SetMinAspectRatio(InMinAspectRatio: number): void;
	SetMaxDesiredWidth(InMaxDesiredWidth: number): void;
	SetMaxDesiredHeight(InMaxDesiredHeight: number): void;
	SetMaxAspectRatio(InMaxAspectRatio: number): void;
	SetHeightOverride(InHeightOverride: number): void;
	ClearWidthOverride(): void;
	ClearMinDesiredWidth(): void;
	ClearMinDesiredHeight(): void;
	ClearMinAspectRatio(): void;
	ClearMaxDesiredWidth(): void;
	ClearMaxDesiredHeight(): void;
	ClearMaxAspectRatio(): void;
	ClearHeightOverride(): void;
	static C(Other: UObject | any): SizeBox;
}

declare class SlateBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SlateBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SlateBlueprintLibrary;
	static GetDefaultObject(): SlateBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBlueprintLibrary;
	static TransformVectorLocalToAbsolute(Geometry: Geometry,LocalVector: Vector2D): Vector2D;
	static TransformVectorAbsoluteToLocal(Geometry: Geometry,AbsoluteVector: Vector2D): Vector2D;
	static TransformScalarLocalToAbsolute(Geometry: Geometry,LocalScalar: number): number;
	static TransformScalarAbsoluteToLocal(Geometry: Geometry,AbsoluteScalar: number): number;
	static ScreenToWidgetLocal(WorldContextObject: UObject,Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {LocalCoordinate: Vector2D};
	static ScreenToWidgetAbsolute(WorldContextObject: UObject,ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {AbsoluteCoordinate: Vector2D};
	static ScreenToViewport(WorldContextObject: UObject,ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	static LocalToViewport(WorldContextObject: UObject,Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static LocalToAbsolute(Geometry: Geometry,LocalCoordinate: Vector2D): Vector2D;
	static IsUnderLocation(Geometry: Geometry,AbsoluteCoordinate: Vector2D): boolean;
	static GetLocalTopLeft(Geometry: Geometry): Vector2D;
	static GetLocalSize(Geometry: Geometry): Vector2D;
	static GetAbsoluteSize(Geometry: Geometry): Vector2D;
	static EqualEqual_SlateBrush(A: SlateBrush,B: SlateBrush): boolean;
	static AbsoluteToViewport(WorldContextObject: UObject,AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static AbsoluteToLocal(Geometry: Geometry,AbsoluteCoordinate: Vector2D): Vector2D;
	static C(Other: UObject | any): SlateBlueprintLibrary;
}

declare class SlateMeshVertex { 
	position: Vector2f;
	Color: Color;
	UV0: Vector2f;
	UV1: Vector2f;
	UV2: Vector2f;
	UV3: Vector2f;
	UV4: Vector2f;
	UV5: Vector2f;
	clone() : SlateMeshVertex;
	static C(Other: UObject | any): SlateMeshVertex;
}

declare class SlateVectorArtData extends UObject { 
	MeshAsset: StaticMesh;
	SourceMaterial: MaterialInterface;
	VertexData: SlateMeshVertex[];
	IndexData: any[];
	Material: MaterialInterface;
	ExtentMin: Vector2D;
	ExtentMax: Vector2D;
	static Load(ResourceName: string): SlateVectorArtData;
	static Find(Outer: UObject, ResourceName: string): SlateVectorArtData;
	static GetDefaultObject(): SlateVectorArtData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateVectorArtData;
	static C(Other: UObject | any): SlateVectorArtData;
}

declare class SliderStyle extends SlateWidgetStyle { 
	NormalBarImage: SlateBrush;
	HoveredBarImage: SlateBrush;
	DisabledBarImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DisabledThumbImage: SlateBrush;
	BarThickness: number;
	clone() : SliderStyle;
	static C(Other: UObject | any): SliderStyle;
}

declare class Slider extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	MinValue: number;
	MaxValue: number;
	WidgetStyle: SliderStyle;
	Orientation: EOrientation;
	SliderBarColor: LinearColor;
	SliderHandleColor: LinearColor;
	IndentHandle: boolean;
	Locked: boolean;
	MouseUsesStep: boolean;
	RequiresControllerLock: boolean;
	StepSize: number;
	IsFocusable: boolean;
	OnMouseCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnMouseCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	static Load(ResourceName: string): Slider;
	static Find(Outer: UObject, ResourceName: string): Slider;
	static GetDefaultObject(): Slider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Slider;
	SetValue(InValue: number): void;
	SetStepSize(InValue: number): void;
	SetSliderHandleColor(InValue: LinearColor): void;
	SetSliderBarColor(InValue: LinearColor): void;
	SetMinValue(InValue: number): void;
	SetMaxValue(InValue: number): void;
	SetLocked(InValue: boolean): void;
	SetIndentHandle(InValue: boolean): void;
	GetValue(): number;
	GetNormalizedValue(): number;
	static C(Other: UObject | any): Slider;
}

declare class Spacer extends Widget { 
	Size: Vector2D;
	static Load(ResourceName: string): Spacer;
	static Find(Outer: UObject, ResourceName: string): Spacer;
	static GetDefaultObject(): Spacer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Spacer;
	SetSize(InSize: Vector2D): void;
	static C(Other: UObject | any): Spacer;
}

declare class SpinBox extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	WidgetStyle: SpinBoxStyle;
	Style: SlateWidgetStyleAsset;
	MinFractionalDigits: number;
	MaxFractionalDigits: number;
	bAlwaysUsesDeltaSnap: boolean;
	Delta: number;
	SliderExponent: number;
	Font: SlateFontInfo;
	Justification: ETextJustify;
	MinDesiredWidth: number;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	ForegroundColor: SlateColor;
	OnValueChanged: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	OnValueCommitted: UnrealEngineMulticastDelegate<(InValue: number, CommitMethod: ETextCommit) => void>;
	OnBeginSliderMovement: UnrealEngineMulticastDelegate<() => void>;
	OnEndSliderMovement: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	bOverride_MinValue: boolean;
	bOverride_MaxValue: boolean;
	bOverride_MinSliderValue: boolean;
	bOverride_MaxSliderValue: boolean;
	MinValue: number;
	MaxValue: number;
	MinSliderValue: number;
	MaxSliderValue: number;
	static Load(ResourceName: string): SpinBox;
	static Find(Outer: UObject, ResourceName: string): SpinBox;
	static GetDefaultObject(): SpinBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBox;
	SetValue(NewValue: number): void;
	SetMinValue(NewValue: number): void;
	SetMinSliderValue(NewValue: number): void;
	SetMinFractionalDigits(NewValue: number): void;
	SetMaxValue(NewValue: number): void;
	SetMaxSliderValue(NewValue: number): void;
	SetMaxFractionalDigits(NewValue: number): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	SetDelta(NewValue: number): void;
	SetAlwaysUsesDeltaSnap(bNewValue: boolean): void;
	GetValue(): number;
	GetMinValue(): number;
	GetMinSliderValue(): number;
	GetMinFractionalDigits(): number;
	GetMaxValue(): number;
	GetMaxSliderValue(): number;
	GetMaxFractionalDigits(): number;
	GetDelta(): number;
	GetAlwaysUsesDeltaSnap(): boolean;
	ClearMinValue(): void;
	ClearMinSliderValue(): void;
	ClearMaxValue(): void;
	ClearMaxSliderValue(): void;
	static C(Other: UObject | any): SpinBox;
}

declare class TextBinding extends PropertyBinding { 
	static Load(ResourceName: string): TextBinding;
	static Find(Outer: UObject, ResourceName: string): TextBinding;
	static GetDefaultObject(): TextBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBinding;
	GetTextValue(): string;
	GetStringValue(): string;
	static C(Other: UObject | any): TextBinding;
}

declare class TextBlock extends TextLayoutWidget { 
	text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	ColorAndOpacity: SlateColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => SlateColor>;
	Font: SlateFontInfo;
	StrikeBrush: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	ShadowColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	MinDesiredWidth: number;
	bWrapWithInvalidationPanel: boolean;
	bAutoWrapText: boolean;
	TextTransformPolicy: ETextTransformPolicy;
	TextOverflowPolicy: ETextOverflowPolicy;
	bSimpleTextMode: boolean;
	static Load(ResourceName: string): TextBlock;
	static Find(Outer: UObject, ResourceName: string): TextBlock;
	static GetDefaultObject(): TextBlock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlock;
	SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetStrikeBrush(InStrikeBrush: SlateBrush): void;
	SetShadowOffset(InShadowOffset: Vector2D): void;
	SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetOpacity(InOpacity: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	SetColorAndOpacity(InColorAndOpacity: SlateColor): void;
	SetAutoWrapText(InAutoTextWrap: boolean): void;
	GetText(): string;
	GetDynamicOutlineMaterial(): MaterialInstanceDynamic;
	GetDynamicFontMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): TextBlock;
}

declare class Throbber extends Widget { 
	NumberOfPieces: number;
	bAnimateHorizontally: boolean;
	bAnimateVertically: boolean;
	bAnimateOpacity: boolean;
	PieceImage: SlateBrushAsset;
	UImage: SlateBrush;
	static Load(ResourceName: string): Throbber;
	static Find(Outer: UObject, ResourceName: string): Throbber;
	static GetDefaultObject(): Throbber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Throbber;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	SetAnimateVertically(bInAnimateVertically: boolean): void;
	SetAnimateOpacity(bInAnimateOpacity: boolean): void;
	SetAnimateHorizontally(bInAnimateHorizontally: boolean): void;
	static C(Other: UObject | any): Throbber;
}

declare type EListItemAlignment = 'EvenlyDistributed' | 'EvenlySize' | 'EvenlyWide' | 'LeftAligned' | 'RightAligned' | 'CenterAligned' | 'Fill' | 'EListItemAlignment_MAX';
declare var EListItemAlignment : { EvenlyDistributed:'EvenlyDistributed',EvenlySize:'EvenlySize',EvenlyWide:'EvenlyWide',LeftAligned:'LeftAligned',RightAligned:'RightAligned',CenterAligned:'CenterAligned',Fill:'Fill',EListItemAlignment_MAX:'EListItemAlignment_MAX', };
declare class TileView extends ListView { 
	EntryHeight: number;
	EntryWidth: number;
	TileAlignment: EListItemAlignment;
	bWrapHorizontalNavigation: boolean;
	static Load(ResourceName: string): TileView;
	static Find(Outer: UObject, ResourceName: string): TileView;
	static GetDefaultObject(): TileView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileView;
	SetEntryWidth(NewWidth: number): void;
	SetEntryHeight(NewHeight: number): void;
	GetEntryWidth(): number;
	GetEntryHeight(): number;
	static C(Other: UObject | any): TileView;
}

declare class TreeView extends ListView { 
	BP_OnGetItemChildren: UnrealEngineDelegate<(Item: UObject, Children: UObject[]) => void>;
	BP_OnItemExpansionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsExpanded: boolean) => void>;
	static Load(ResourceName: string): TreeView;
	static Find(Outer: UObject, ResourceName: string): TreeView;
	static GetDefaultObject(): TreeView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TreeView;
	SetItemExpansion(Item: UObject,bExpandItem: boolean): void;
	ExpandAll(): void;
	CollapseAll(): void;
	static C(Other: UObject | any): TreeView;
}

declare class UniformGridPanel extends PanelWidget { 
	SlotPadding: Margin;
	MinDesiredSlotWidth: number;
	MinDesiredSlotHeight: number;
	static Load(ResourceName: string): UniformGridPanel;
	static Find(Outer: UObject, ResourceName: string): UniformGridPanel;
	static GetDefaultObject(): UniformGridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridPanel;
	SetSlotPadding(InSlotPadding: Margin): void;
	SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number): void;
	SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number): void;
	AddChildToUniformGrid(Content: Widget,InRow: number,InColumn: number): UniformGridSlot;
	static C(Other: UObject | any): UniformGridPanel;
}

declare class UserWidgetBlueprint extends Blueprint { 
	static Load(ResourceName: string): UserWidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): UserWidgetBlueprint;
	static GetDefaultObject(): UserWidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidgetBlueprint;
	static C(Other: UObject | any): UserWidgetBlueprint;
}

declare class VerticalBox extends PanelWidget { 
	static Load(ResourceName: string): VerticalBox;
	static Find(Outer: UObject, ResourceName: string): VerticalBox;
	static GetDefaultObject(): VerticalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBox;
	AddChildToVerticalBox(Content: Widget): VerticalBoxSlot;
	static C(Other: UObject | any): VerticalBox;
}

declare class Viewport extends ContentWidget { 
	BackgroundColor: LinearColor;
	static Load(ResourceName: string): Viewport;
	static Find(Outer: UObject, ResourceName: string): Viewport;
	static GetDefaultObject(): Viewport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Viewport;
	Spawn(ActorClass: UnrealEngineClass): Actor;
	SetViewRotation(Rotation: Rotator): void;
	SetViewLocation(Location: Vector): void;
	GetViewRotation(): Rotator;
	GetViewportWorld(): World;
	GetViewLocation(): Vector;
	static C(Other: UObject | any): Viewport;
}

declare class VisibilityBinding extends PropertyBinding { 
	static Load(ResourceName: string): VisibilityBinding;
	static Find(Outer: UObject, ResourceName: string): VisibilityBinding;
	static GetDefaultObject(): VisibilityBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisibilityBinding;
	GetValue(): ESlateVisibility;
	static C(Other: UObject | any): VisibilityBinding;
}

declare class BlueprintWidgetAnimationDelegateBinding { 
	Action: EWidgetAnimationEvent;
	AnimationToBind: string;
	FunctionNameToBind: string;
	UserTag: string;
	clone() : BlueprintWidgetAnimationDelegateBinding;
	static C(Other: UObject | any): BlueprintWidgetAnimationDelegateBinding;
}

declare class WidgetAnimationDelegateBinding extends DynamicBlueprintBinding { 
	WidgetAnimationDelegateBindings: BlueprintWidgetAnimationDelegateBinding[];
	static Load(ResourceName: string): WidgetAnimationDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationDelegateBinding;
	static GetDefaultObject(): WidgetAnimationDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationDelegateBinding;
	static C(Other: UObject | any): WidgetAnimationDelegateBinding;
}

declare class WidgetAnimationPlayCallbackProxy extends UObject { 
	Finished: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static GetDefaultObject(): WidgetAnimationPlayCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationPlayCallbackProxy;
	static CreatePlayAnimationTimeRangeProxyObject(Result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,EndAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {Result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static CreatePlayAnimationProxyObject(Result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {Result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static C(Other: UObject | any): WidgetAnimationPlayCallbackProxy;
}

declare class WidgetBinding extends PropertyBinding { 
	static Load(ResourceName: string): WidgetBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetBinding;
	static GetDefaultObject(): WidgetBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBinding;
	GetValue(): Widget;
	static C(Other: UObject | any): WidgetBinding;
}

declare class EventGraphFastCallPair { 
	FunctionToPatch: UFunction;
	EventGraphCallOffset: number;
	clone() : EventGraphFastCallPair;
	static C(Other: UObject | any): EventGraphFastCallPair;
}

declare class BlueprintGeneratedClass extends Class { 
	NumReplicatedProperties: number;
	bHasNativizedParent: boolean;
	bHasCookedComponentInstancingData: boolean;
	bIsSparseClassDataSerializable: boolean;
	DynamicBindingObjects: DynamicBlueprintBinding[];
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	SimpleConstructionScript: SimpleConstructionScript;
	InheritableComponentHandler: InheritableComponentHandler;
	UberGraphFramePointerProperty: StructProperty;
	UberGraphFunction: UFunction;
	FastCallPairs: EventGraphFastCallPair[];
	OverridenArchetypeForCDO: UObject;
	PropertyGuids: any;
	CalledFunctions: UFunction[];
	CookedComponentInstancingData: any;
	static Load(ResourceName: string): BlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): BlueprintGeneratedClass;
	static GetDefaultObject(): BlueprintGeneratedClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGeneratedClass;
	static C(Other: UObject | any): BlueprintGeneratedClass;
}

declare type EBindingKind = 'Function' | 'Property' | 'EBindingKind_MAX';
declare var EBindingKind : { Function:'Function',Property:'Property',EBindingKind_MAX:'EBindingKind_MAX', };
declare class DelegateRuntimeBinding { 
	ObjectName: string;
	PropertyName: string;
	FunctionName: string;
	SourcePath: DynamicPropertyPath;
	Kind: EBindingKind;
	clone() : DelegateRuntimeBinding;
	static C(Other: UObject | any): DelegateRuntimeBinding;
}

declare class WidgetBlueprintGeneratedClass extends BlueprintGeneratedClass { 
	WidgetTree: WidgetTree;
	bCanCallPreConstruct: boolean;
	bClassRequiresNativeTick: boolean;
	Bindings: DelegateRuntimeBinding[];
	Animations: WidgetAnimation[];
	NamedSlots: string[];
	static Load(ResourceName: string): WidgetBlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintGeneratedClass;
	static GetDefaultObject(): WidgetBlueprintGeneratedClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintGeneratedClass;
	static C(Other: UObject | any): WidgetBlueprintGeneratedClass;
}

declare class NavigationEvent extends InputEvent { 
	clone() : NavigationEvent;
	static C(Other: UObject | any): NavigationEvent;
	GetInputEventFromNavigationEvent(): InputEvent;
	static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;
}

declare class WidgetBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): WidgetBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintLibrary;
	static GetDefaultObject(): WidgetBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintLibrary;
	static UnlockMouse(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static Unhandled(): EventReply;
	static SetWindowTitleBarState(TitleBarContent: Widget,Mode: EWindowTitleBarMode,bTitleBarDragEnabled: boolean,bWindowButtonsVisible: boolean,bTitleBarVisible: boolean): void;
	static SetWindowTitleBarCloseButtonActive(bActive: boolean): void;
	static SetUserFocus(Reply?: EventReply,FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static SetMousePosition(Reply?: EventReply,NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	static SetInputMode_UIOnlyEx(PlayerController: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode): void;
	static SetInputMode_GameOnly(PlayerController: PlayerController): void;
	static SetInputMode_GameAndUIEx(PlayerController: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode,bHideCursorDuringCapture: boolean): void;
	static SetHardwareCursor(WorldContextObject: UObject,CursorShape: EMouseCursor,CursorName: string,HotSpot: Vector2D): boolean;
	static SetFocusToGameViewport(): void;
	static SetColorVisionDeficiencyType(Type: EColorVisionDeficiency,Severity: number,CorrectDeficiency: boolean,ShowCorrectionWithDeficiency: boolean): void;
	static SetBrushResourceToTexture(Brush?: SlateBrush,Texture?: Texture2D): {Brush: SlateBrush};
	static SetBrushResourceToMaterial(Brush?: SlateBrush,Material?: MaterialInterface): {Brush: SlateBrush};
	static RestorePreviousWindowTitleBarState(): void;
	static ReleaseMouseCapture(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static ReleaseJoystickCapture(Reply?: EventReply,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static NoResourceBrush(): SlateBrush;
	static MakeBrushFromTexture(Texture: Texture2D,Width: number,Height: number): SlateBrush;
	static MakeBrushFromMaterial(Material: MaterialInterface,Width: number,Height: number): SlateBrush;
	static MakeBrushFromAsset(BrushAsset: SlateBrushAsset): SlateBrush;
	static LockMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static IsDragDropping(): boolean;
	static Handled(): EventReply;
	static GetSafeZonePadding(WorldContextObject: UObject,SafePadding?: Vector4,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector4): {SafePadding: Vector4, SafePaddingScale: Vector2D, SpillOverPadding: Vector4};
	static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;
	static GetInputEventFromPointerEvent(Event: UPointerEvent): InputEvent;
	static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;
	static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;
	static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;
	static GetDynamicMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	static GetDragDroppingContent(): DragDropOperation;
	static GetBrushResourceAsTexture2D(Brush: SlateBrush): Texture2D;
	static GetBrushResourceAsMaterial(Brush: SlateBrush): MaterialInterface;
	static GetBrushResource(Brush: SlateBrush): UObject;
	static GetAllWidgetsWithInterface(WorldContextObject: UObject,FoundWidgets?: UserWidget[],Interface?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetAllWidgetsOfClass(WorldContextObject: UObject,FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static EndDragDrop(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static DrawTextFormatted(Context?: PaintContext,text?: string,position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
	static DrawText(Context?: PaintContext,InString?: string,position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	static DrawLines(Context?: PaintContext,Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	static DrawLine(Context?: PaintContext,PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	static DrawBox(Context?: PaintContext,position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	static DismissAllMenus(): void;
	static DetectDragIfPressed(UPointerEvent: UPointerEvent,WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	static DetectDrag(Reply?: EventReply,WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	static CreateDragDropOperation(OperationClass: UnrealEngineClass): DragDropOperation;
	static Create(WorldContextObject: UObject,WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	static ClearUserFocus(Reply?: EventReply,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static CaptureMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static CaptureJoystick(Reply?: EventReply,CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static CancelDragDrop(): void;
	static C(Other: UObject | any): WidgetBlueprintLibrary;
}

declare type EWidgetSpace = 'World' | 'Screen' | 'EWidgetSpace_MAX';
declare var EWidgetSpace : { World:'World',Screen:'Screen',EWidgetSpace_MAX:'EWidgetSpace_MAX', };
declare type EWidgetTimingPolicy = 'RealTime' | 'GameTime' | 'EWidgetTimingPolicy_MAX';
declare var EWidgetTimingPolicy : { RealTime:'RealTime',GameTime:'GameTime',EWidgetTimingPolicy_MAX:'EWidgetTimingPolicy_MAX', };
declare type EWindowVisibility = 'Visible' | 'SelfHitTestInvisible' | 'EWindowVisibility_MAX';
declare var EWindowVisibility : { Visible:'Visible',SelfHitTestInvisible:'SelfHitTestInvisible',EWindowVisibility_MAX:'EWindowVisibility_MAX', };
declare type EWidgetBlendMode = 'Opaque' | 'Masked' | 'Transparent' | 'EWidgetBlendMode_MAX';
declare var EWidgetBlendMode : { Opaque:'Opaque',Masked:'Masked',Transparent:'Transparent',EWidgetBlendMode_MAX:'EWidgetBlendMode_MAX', };
declare type EWidgetGeometryMode = 'Plane' | 'Cylinder' | 'EWidgetGeometryMode_MAX';
declare var EWidgetGeometryMode : { Plane:'Plane',Cylinder:'Cylinder',EWidgetGeometryMode_MAX:'EWidgetGeometryMode_MAX', };
declare type ETickMode = 'Disabled' | 'Enabled' | 'Automatic' | 'ETickMode_MAX';
declare var ETickMode : { Disabled:'Disabled',Enabled:'Enabled',Automatic:'Automatic',ETickMode_MAX:'ETickMode_MAX', };
declare class WidgetComponent extends MeshComponent { 
	Space: EWidgetSpace;
	TimingPolicy: EWidgetTimingPolicy;
	WidgetClass: UnrealEngineClass;
	DrawSize: IntPoint;
	bManuallyRedraw: boolean;
	bRedrawRequested: boolean;
	RedrawTime: number;
	CurrentDrawSize: IntPoint;
	bDrawAtDesiredSize: boolean;
	Pivot: Vector2D;
	bReceiveHardwareInput: boolean;
	bWindowFocusable: boolean;
	WindowVisibility: EWindowVisibility;
	bApplyGammaCorrection: boolean;
	OwnerPlayer: LocalPlayer;
	BackgroundColor: LinearColor;
	TintColorAndOpacity: LinearColor;
	OpacityFromTexture: number;
	BlendMode: EWidgetBlendMode;
	bIsTwoSided: boolean;
	TickWhenOffscreen: boolean;
	BodySetup: BodySetup;
	TranslucentMaterial: MaterialInterface;
	TranslucentMaterial_OneSided: MaterialInterface;
	OpaqueMaterial: MaterialInterface;
	OpaqueMaterial_OneSided: MaterialInterface;
	MaskedMaterial: MaterialInterface;
	MaskedMaterial_OneSided: MaterialInterface;
	RenderTarget: TextureRenderTarget2D;
	MaterialInstance: MaterialInstanceDynamic;
	bAddedToScreen: boolean;
	bEditTimeUsable: boolean;
	SharedLayerName: string;
	LayerZOrder: number;
	GeometryMode: EWidgetGeometryMode;
	CylinderArcAngle: number;
	TickMode: ETickMode;
	Widget: UserWidget;
	static Load(ResourceName: string): WidgetComponent;
	static Find(Outer: UObject, ResourceName: string): WidgetComponent;
	static GetDefaultObject(): WidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetComponent;
	SetWindowVisibility(InVisibility: EWindowVisibility): void;
	SetWindowFocusable(bInWindowFocusable: boolean): void;
	SetWidgetSpace(NewSpace: EWidgetSpace): void;
	SetWidget(Widget: UserWidget): void;
	SetTwoSided(bWantTwoSided: boolean): void;
	SetTintColorAndOpacity(NewTintColorAndOpacity: LinearColor): void;
	SetTickWhenOffscreen(bWantTickWhenOffscreen: boolean): void;
	SetTickMode(InTickMode: ETickMode): void;
	SetRedrawTime(InRedrawTime: number): void;
	SetPivot(InPivot: Vector2D): void;
	SetOwnerPlayer(LocalPlayer: LocalPlayer): void;
	SetManuallyRedraw(bUseManualRedraw: boolean): void;
	SetGeometryMode(InGeometryMode: EWidgetGeometryMode): void;
	SetDrawSize(Size: Vector2D): void;
	SetDrawAtDesiredSize(bInDrawAtDesiredSize: boolean): void;
	SetCylinderArcAngle(InCylinderArcAngle: number): void;
	SetBackgroundColor(NewBackgroundColor: LinearColor): void;
	RequestRenderUpdate(): void;
	RequestRedraw(): void;
	IsWidgetVisible(): boolean;
	GetWindowVisiblility(): EWindowVisibility;
	GetWindowFocusable(): boolean;
	GetWidgetSpace(): EWidgetSpace;
	GetWidget(): UserWidget;
	GetUserWidgetObject(): UserWidget;
	GetTwoSided(): boolean;
	GetTickWhenOffscreen(): boolean;
	GetRenderTarget(): TextureRenderTarget2D;
	GetRedrawTime(): number;
	GetPivot(): Vector2D;
	GetOwnerPlayer(): LocalPlayer;
	GetMaterialInstance(): MaterialInstanceDynamic;
	GetManuallyRedraw(): boolean;
	GetGeometryMode(): EWidgetGeometryMode;
	GetDrawSize(): Vector2D;
	GetDrawAtDesiredSize(): boolean;
	GetCylinderArcAngle(): number;
	GetCurrentDrawSize(): Vector2D;
	static C(Other: UObject | any): WidgetComponent;
}

declare type EWidgetInteractionSource = 'World' | 'Mouse' | 'CenterScreen' | 'Custom' | 'EWidgetInteractionSource_MAX';
declare var EWidgetInteractionSource : { World:'World',Mouse:'Mouse',CenterScreen:'CenterScreen',Custom:'Custom',EWidgetInteractionSource_MAX:'EWidgetInteractionSource_MAX', };
declare class WidgetInteractionComponent extends SceneComponent { 
	OnHoveredWidgetChanged: UnrealEngineMulticastDelegate<(WidgetComponent: WidgetComponent, PreviousWidgetComponent: WidgetComponent) => void>;
	VirtualUserIndex: number;
	PointerIndex: number;
	TraceChannel: ECollisionChannel;
	InteractionDistance: number;
	InteractionSource: EWidgetInteractionSource;
	bEnableHitTesting: boolean;
	bShowDebug: boolean;
	DebugSphereLineThickness: number;
	DebugLineThickness: number;
	DebugColor: LinearColor;
	CustomHitResult: HitResult;
	LocalHitLocation: Vector2D;
	LastLocalHitLocation: Vector2D;
	HoveredWidgetComponent: WidgetComponent;
	LastHitResult: HitResult;
	bIsHoveredWidgetInteractable: boolean;
	bIsHoveredWidgetFocusable: boolean;
	bIsHoveredWidgetHitTestVisible: boolean;
	ArrowComponent: ArrowComponent;
	static Load(ResourceName: string): WidgetInteractionComponent;
	static Find(Outer: UObject, ResourceName: string): WidgetInteractionComponent;
	static GetDefaultObject(): WidgetInteractionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetInteractionComponent;
	SetFocus(FocusWidget: Widget): void;
	SetCustomHitResult(HitResult: HitResult): void;
	SendKeyChar(Characters: string,bRepeat: boolean): boolean;
	ScrollWheel(ScrollDelta: number): void;
	ReleasePointerKey(Key: Key): void;
	ReleaseKey(Key: Key): boolean;
	PressPointerKey(Key: Key): void;
	PressKey(Key: Key,bRepeat: boolean): boolean;
	PressAndReleaseKey(Key: Key): boolean;
	IsOverInteractableWidget(): boolean;
	IsOverHitTestVisibleWidget(): boolean;
	IsOverFocusableWidget(): boolean;
	GetLastHitResult(): HitResult;
	GetHoveredWidgetComponent(): WidgetComponent;
	Get2DHitLocation(): Vector2D;
	static C(Other: UObject | any): WidgetInteractionComponent;
}

declare class WidgetLayoutLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): WidgetLayoutLibrary;
	static Find(Outer: UObject, ResourceName: string): WidgetLayoutLibrary;
	static GetDefaultObject(): WidgetLayoutLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetLayoutLibrary;
	static SlotAsWrapBoxSlot(Widget: Widget): WrapBoxSlot;
	static SlotAsWidgetSwitcherSlot(Widget: Widget): WidgetSwitcherSlot;
	static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
	static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
	static SlotAsSizeBoxSlot(Widget: Widget): SizeBoxSlot;
	static SlotAsScrollBoxSlot(Widget: Widget): ScrollBoxSlot;
	static SlotAsScaleBoxSlot(Widget: Widget): ScaleBoxSlot;
	static SlotAsSafeBoxSlot(Widget: Widget): SafeZoneSlot;
	static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
	static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
	static SlotAsGridSlot(Widget: Widget): GridSlot;
	static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
	static SlotAsBorderSlot(Widget: Widget): BorderSlot;
	static RemoveAllWidgets(WorldContextObject: UObject): void;
	static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController,WorldLocation: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	static GetViewportWidgetGeometry(WorldContextObject: UObject): Geometry;
	static GetViewportSize(WorldContextObject: UObject): Vector2D;
	static GetViewportScale(WorldContextObject: UObject): number;
	static GetPlayerScreenWidgetGeometry(PlayerController: PlayerController): Geometry;
	static GetMousePositionScaledByDPI(Player: PlayerController,LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	static GetMousePositionOnViewport(WorldContextObject: UObject): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
	static C(Other: UObject | any): WidgetLayoutLibrary;
}

declare class WidgetSwitcher extends PanelWidget { 
	ActiveWidgetIndex: number;
	static Load(ResourceName: string): WidgetSwitcher;
	static Find(Outer: UObject, ResourceName: string): WidgetSwitcher;
	static GetDefaultObject(): WidgetSwitcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSwitcher;
	SetActiveWidgetIndex(index: number): void;
	SetActiveWidget(Widget: Widget): void;
	GetWidgetAtIndex(index: number): Widget;
	GetNumWidgets(): number;
	GetActiveWidgetIndex(): number;
	GetActiveWidget(): Widget;
	static C(Other: UObject | any): WidgetSwitcher;
}

declare class WindowTitleBarArea extends ContentWidget { 
	bWindowButtonsEnabled: boolean;
	bDoubleClickTogglesFullscreen: boolean;
	static Load(ResourceName: string): WindowTitleBarArea;
	static Find(Outer: UObject, ResourceName: string): WindowTitleBarArea;
	static GetDefaultObject(): WindowTitleBarArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowTitleBarArea;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): WindowTitleBarArea;
}

declare class WindowTitleBarAreaSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): WindowTitleBarAreaSlot;
	static Find(Outer: UObject, ResourceName: string): WindowTitleBarAreaSlot;
	static GetDefaultObject(): WindowTitleBarAreaSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowTitleBarAreaSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): WindowTitleBarAreaSlot;
}

declare class WrapBox extends PanelWidget { 
	InnerSlotPadding: Vector2D;
	WrapWidth: number;
	WrapSize: number;
	bExplicitWrapWidth: boolean;
	bExplicitWrapSize: boolean;
	HorizontalAlignment: EHorizontalAlignment;
	Orientation: EOrientation;
	static Load(ResourceName: string): WrapBox;
	static Find(Outer: UObject, ResourceName: string): WrapBox;
	static GetDefaultObject(): WrapBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WrapBox;
	SetInnerSlotPadding(InPadding: Vector2D): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	AddChildToWrapBox(Content: Widget): WrapBoxSlot;
	static C(Other: UObject | any): WrapBox;
}

declare class MeshReconstructorBase extends UObject { 
	static Load(ResourceName: string): MeshReconstructorBase;
	static Find(Outer: UObject, ResourceName: string): MeshReconstructorBase;
	static GetDefaultObject(): MeshReconstructorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshReconstructorBase;
	StopReconstruction(): void;
	StartReconstruction(): void;
	PauseReconstruction(): void;
	IsReconstructionStarted(): boolean;
	IsReconstructionPaused(): boolean;
	DisconnectMRMesh(): void;
	ConnectMRMesh(Mesh: MRMeshComponent): void;
	static C(Other: UObject | any): MeshReconstructorBase;
}

declare type EMeshTrackerVertexColorMode = 'None' | 'Confidence' | 'Block' | 'EMeshTrackerVertexColorMode_MAX';
declare var EMeshTrackerVertexColorMode : { None:'None',Confidence:'Confidence',Block:'Block',EMeshTrackerVertexColorMode_MAX:'EMeshTrackerVertexColorMode_MAX', };
declare class MockDataMeshTrackerComponent extends SceneComponent { 
	OnMeshTrackerUpdated: UnrealEngineMulticastDelegate<(index: number, Vertices: Vector[], Triangles: number[], Normals: Vector[], Confidence: number[]) => void>;
	ScanWorld: boolean;
	RequestNormals: boolean;
	RequestVertexConfidence: boolean;
	VertexColorMode: EMeshTrackerVertexColorMode;
	BlockVertexColors: Color[];
	VertexColorFromConfidenceZero: LinearColor;
	VertexColorFromConfidenceOne: LinearColor;
	UpdateInterval: number;
	MRMesh: MRMeshComponent;
	static Load(ResourceName: string): MockDataMeshTrackerComponent;
	static Find(Outer: UObject, ResourceName: string): MockDataMeshTrackerComponent;
	static GetDefaultObject(): MockDataMeshTrackerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MockDataMeshTrackerComponent;
	DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	ConnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	static C(Other: UObject | any): MockDataMeshTrackerComponent;
}

declare class ARComponent extends SceneComponent { 
	NativeID: Guid;
	bUseDefaultReplication: boolean;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	MRMeshComponent: MRMeshComponent;
	MyTrackedGeometry: ARTrackedGeometry;
	static Load(ResourceName: string): ARComponent;
	static Find(Outer: UObject, ResourceName: string): ARComponent;
	static GetDefaultObject(): ARComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARComponent;
	UpdateVisualization(): void;
	SetNativeID(NativeID: Guid): void;
	ReceiveRemove(): void;
	OnRep_Payload(): void;
	GetMRMesh(): MRMeshComponent;
	static C(Other: UObject | any): ARComponent;
}

declare class ARActor extends Actor { 
	static GetDefaultObject(): ARActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARActor;
	AddARComponent(InComponentClass: UnrealEngineClass,NativeID: Guid): ARComponent;
	static C(Other: UObject | any): ARActor;
}

declare type EARCaptureType = 'Camera' | 'QRCode' | 'SpatialMapping' | 'SceneUnderstanding' | 'HandMesh' | 'EARCaptureType_MAX';
declare var EARCaptureType : { Camera:'Camera',QRCode:'QRCode',SpatialMapping:'SpatialMapping',SceneUnderstanding:'SceneUnderstanding',HandMesh:'HandMesh',EARCaptureType_MAX:'EARCaptureType_MAX', };
declare type EARWorldAlignment = 'Gravity' | 'GravityAndHeading' | 'Camera' | 'EARWorldAlignment_MAX';
declare var EARWorldAlignment : { Gravity:'Gravity',GravityAndHeading:'GravityAndHeading',Camera:'Camera',EARWorldAlignment_MAX:'EARWorldAlignment_MAX', };
declare type EARSessionType = 'None' | 'Orientation' | 'World' | 'Face' | 'Image' | 'ObjectScanning' | 'PoseTracking' | 'GeoTracking' | 'EARSessionType_MAX';
declare var EARSessionType : { None:'None',Orientation:'Orientation',World:'World',Face:'Face',Image:'Image',ObjectScanning:'ObjectScanning',PoseTracking:'PoseTracking',GeoTracking:'GeoTracking',EARSessionType_MAX:'EARSessionType_MAX', };
declare type EARPlaneDetectionMode = 'None' | 'HorizontalPlaneDetection' | 'VerticalPlaneDetection' | 'EARPlaneDetectionMode_MAX';
declare var EARPlaneDetectionMode : { None:'None',HorizontalPlaneDetection:'HorizontalPlaneDetection',VerticalPlaneDetection:'VerticalPlaneDetection',EARPlaneDetectionMode_MAX:'EARPlaneDetectionMode_MAX', };
declare type EARLightEstimationMode = 'None' | 'AmbientLightEstimate' | 'DirectionalLightEstimate' | 'EARLightEstimationMode_MAX';
declare var EARLightEstimationMode : { None:'None',AmbientLightEstimate:'AmbientLightEstimate',DirectionalLightEstimate:'DirectionalLightEstimate',EARLightEstimationMode_MAX:'EARLightEstimationMode_MAX', };
declare type EARFrameSyncMode = 'SyncTickWithCameraImage' | 'SyncTickWithoutCameraImage' | 'EARFrameSyncMode_MAX';
declare var EARFrameSyncMode : { SyncTickWithCameraImage:'SyncTickWithCameraImage',SyncTickWithoutCameraImage:'SyncTickWithoutCameraImage',EARFrameSyncMode_MAX:'EARFrameSyncMode_MAX', };
declare type EARCandidateImageOrientation = 'Landscape' | 'Portrait' | 'EARCandidateImageOrientation_MAX';
declare var EARCandidateImageOrientation : { Landscape:'Landscape',Portrait:'Portrait',EARCandidateImageOrientation_MAX:'EARCandidateImageOrientation_MAX', };
declare class ARCandidateImage extends DataAsset { 
	CandidateTexture: Texture2D;
	FriendlyName: string;
	Width: number;
	Height: number;
	Orientation: EARCandidateImageOrientation;
	static Load(ResourceName: string): ARCandidateImage;
	static Find(Outer: UObject, ResourceName: string): ARCandidateImage;
	static GetDefaultObject(): ARCandidateImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateImage;
	GetPhysicalWidth(): number;
	GetPhysicalHeight(): number;
	GetOrientation(): EARCandidateImageOrientation;
	GetFriendlyName(): string;
	GetCandidateTexture(): Texture2D;
	static C(Other: UObject | any): ARCandidateImage;
}

declare type EAREnvironmentCaptureProbeType = 'None' | 'Manual' | 'Automatic' | 'EAREnvironmentCaptureProbeType_MAX';
declare var EAREnvironmentCaptureProbeType : { None:'None',Manual:'Manual',Automatic:'Automatic',EAREnvironmentCaptureProbeType_MAX:'EAREnvironmentCaptureProbeType_MAX', };
declare class ARCandidateObject extends DataAsset { 
	CandidateObjectData: number[];
	FriendlyName: string;
	BoundingBox: Box;
	static Load(ResourceName: string): ARCandidateObject;
	static Find(Outer: UObject, ResourceName: string): ARCandidateObject;
	static GetDefaultObject(): ARCandidateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateObject;
	SetFriendlyName(NewName: string): void;
	SetCandidateObjectData(InCandidateObject: number[]): void;
	SetBoundingBox(InBoundingBox: Box): void;
	GetFriendlyName(): string;
	GetCandidateObjectData(): number[];
	GetBoundingBox(): Box;
	static C(Other: UObject | any): ARCandidateObject;
}

declare class ARVideoFormat { 
	FPS: number;
	Width: number;
	Height: number;
	clone() : ARVideoFormat;
	static C(Other: UObject | any): ARVideoFormat;
}

declare type EARFaceTrackingDirection = 'FaceRelative' | 'FaceMirrored' | 'EARFaceTrackingDirection_MAX';
declare var EARFaceTrackingDirection : { FaceRelative:'FaceRelative',FaceMirrored:'FaceMirrored',EARFaceTrackingDirection_MAX:'EARFaceTrackingDirection_MAX', };
declare type EARFaceTrackingUpdate = 'CurvesAndGeo' | 'CurvesOnly' | 'EARFaceTrackingUpdate_MAX';
declare var EARFaceTrackingUpdate : { CurvesAndGeo:'CurvesAndGeo',CurvesOnly:'CurvesOnly',EARFaceTrackingUpdate_MAX:'EARFaceTrackingUpdate_MAX', };
declare type EARSessionTrackingFeature = 'None' | 'PoseDetection2D' | 'PersonSegmentation' | 'PersonSegmentationWithDepth' | 'SceneDepth' | 'SmoothedSceneDepth' | 'EARSessionTrackingFeature_MAX';
declare var EARSessionTrackingFeature : { None:'None',PoseDetection2D:'PoseDetection2D',PersonSegmentation:'PersonSegmentation',PersonSegmentationWithDepth:'PersonSegmentationWithDepth',SceneDepth:'SceneDepth',SmoothedSceneDepth:'SmoothedSceneDepth',EARSessionTrackingFeature_MAX:'EARSessionTrackingFeature_MAX', };
declare type EARSceneReconstruction = 'None' | 'MeshOnly' | 'MeshWithClassification' | 'EARSceneReconstruction_MAX';
declare var EARSceneReconstruction : { None:'None',MeshOnly:'MeshOnly',MeshWithClassification:'MeshWithClassification',EARSceneReconstruction_MAX:'EARSceneReconstruction_MAX', };
declare class ARSessionPayload { 
	ConfigFlags: number;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	clone() : ARSessionPayload;
	static C(Other: UObject | any): ARSessionPayload;
}

declare class ARPlaneUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Center: Vector;
	Extents: Vector;
	BoundaryVertices: Vector[];
	ObjectClassification: EARObjectClassification;
	clone() : ARPlaneUpdatePayload;
	static C(Other: UObject | any): ARPlaneUpdatePayload;
}

declare type EPlaneComponentDebugMode = 'None' | 'ShowNetworkRole' | 'ShowClassification' | 'EPlaneComponentDebugMode_MAX';
declare var EPlaneComponentDebugMode : { None:'None',ShowNetworkRole:'ShowNetworkRole',ShowClassification:'ShowClassification',EPlaneComponentDebugMode_MAX:'EPlaneComponentDebugMode_MAX', };
declare class ARPlaneComponent extends ARComponent { 
	ReplicatedPayload: ARPlaneUpdatePayload;
	static Load(ResourceName: string): ARPlaneComponent;
	static Find(Outer: UObject, ResourceName: string): ARPlaneComponent;
	static GetDefaultObject(): ARPlaneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneComponent;
	static SetPlaneComponentDebugMode(NewDebugMode: EPlaneComponentDebugMode): void;
	static SetObjectClassificationDebugColors(InColors: any): void;
	ServerUpdatePayload(NewPayload: ARPlaneUpdatePayload): void;
	ReceiveUpdate(Payload: ARPlaneUpdatePayload): void;
	ReceiveAdd(Payload: ARPlaneUpdatePayload): void;
	static GetObjectClassificationDebugColors(): any;
	static C(Other: UObject | any): ARPlaneComponent;
}

declare class ARPointUpdatePayload { 
	clone() : ARPointUpdatePayload;
	static C(Other: UObject | any): ARPointUpdatePayload;
}

declare class ARPointComponent extends ARComponent { 
	ReplicatedPayload: ARPointUpdatePayload;
	static Load(ResourceName: string): ARPointComponent;
	static Find(Outer: UObject, ResourceName: string): ARPointComponent;
	static GetDefaultObject(): ARPointComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPointComponent;
	ServerUpdatePayload(NewPayload: ARPointUpdatePayload): void;
	ReceiveUpdate(Payload: ARPointUpdatePayload): void;
	ReceiveAdd(Payload: ARPointUpdatePayload): void;
	static C(Other: UObject | any): ARPointComponent;
}

declare type EARFaceTransformMixing = 'ComponentOnly' | 'ComponentLocationTrackedRotation' | 'ComponentWithTracked' | 'TrackingOnly' | 'EARFaceTransformMixing_MAX';
declare var EARFaceTransformMixing : { ComponentOnly:'ComponentOnly',ComponentLocationTrackedRotation:'ComponentLocationTrackedRotation',ComponentWithTracked:'ComponentWithTracked',TrackingOnly:'TrackingOnly',EARFaceTransformMixing_MAX:'EARFaceTransformMixing_MAX', };
declare class ARFaceUpdatePayload { 
	SessionPayload: ARSessionPayload;
	LeftEyePosition: Vector;
	RightEyePosition: Vector;
	LookAtTarget: Vector;
	clone() : ARFaceUpdatePayload;
	static C(Other: UObject | any): ARFaceUpdatePayload;
}

declare type EFaceComponentDebugMode = 'None' | 'ShowEyeVectors' | 'ShowFaceMesh' | 'EFaceComponentDebugMode_MAX';
declare var EFaceComponentDebugMode : { None:'None',ShowEyeVectors:'ShowEyeVectors',ShowFaceMesh:'ShowFaceMesh',EFaceComponentDebugMode_MAX:'EFaceComponentDebugMode_MAX', };
declare class ARFaceComponent extends ARComponent { 
	TransformSetting: EARFaceTransformMixing;
	bUpdateVertexNormal: boolean;
	bFaceOutOfScreen: boolean;
	ReplicatedPayload: ARFaceUpdatePayload;
	static Load(ResourceName: string): ARFaceComponent;
	static Find(Outer: UObject, ResourceName: string): ARFaceComponent;
	static GetDefaultObject(): ARFaceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceComponent;
	static SetFaceComponentDebugMode(NewDebugMode: EFaceComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARFaceUpdatePayload): void;
	ReceiveUpdate(Payload: ARFaceUpdatePayload): void;
	ReceiveAdd(Payload: ARFaceUpdatePayload): void;
	static C(Other: UObject | any): ARFaceComponent;
}

declare class ARImageUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	clone() : ARImageUpdatePayload;
	static C(Other: UObject | any): ARImageUpdatePayload;
}

declare type EImageComponentDebugMode = 'None' | 'ShowDetectedImage' | 'EImageComponentDebugMode_MAX';
declare var EImageComponentDebugMode : { None:'None',ShowDetectedImage:'ShowDetectedImage',EImageComponentDebugMode_MAX:'EImageComponentDebugMode_MAX', };
declare class ARImageComponent extends ARComponent { 
	ReplicatedPayload: ARImageUpdatePayload;
	static Load(ResourceName: string): ARImageComponent;
	static Find(Outer: UObject, ResourceName: string): ARImageComponent;
	static GetDefaultObject(): ARImageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARImageComponent;
	static SetImageComponentDebugMode(NewDebugMode: EImageComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARImageUpdatePayload): void;
	ReceiveUpdate(Payload: ARImageUpdatePayload): void;
	ReceiveAdd(Payload: ARImageUpdatePayload): void;
	static C(Other: UObject | any): ARImageComponent;
}

declare class ARQRCodeUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Extents: Vector;
	QRCode: string;
	clone() : ARQRCodeUpdatePayload;
	static C(Other: UObject | any): ARQRCodeUpdatePayload;
}

declare type EQRCodeComponentDebugMode = 'None' | 'ShowQRCode' | 'EQRCodeComponentDebugMode_MAX';
declare var EQRCodeComponentDebugMode : { None:'None',ShowQRCode:'ShowQRCode',EQRCodeComponentDebugMode_MAX:'EQRCodeComponentDebugMode_MAX', };
declare class ARQRCodeComponent extends ARComponent { 
	ReplicatedPayload: ARQRCodeUpdatePayload;
	static Load(ResourceName: string): ARQRCodeComponent;
	static Find(Outer: UObject, ResourceName: string): ARQRCodeComponent;
	static GetDefaultObject(): ARQRCodeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARQRCodeComponent;
	static SetQRCodeComponentDebugMode(NewDebugMode: EQRCodeComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARQRCodeUpdatePayload): void;
	ReceiveUpdate(Payload: ARQRCodeUpdatePayload): void;
	ReceiveAdd(Payload: ARQRCodeUpdatePayload): void;
	static C(Other: UObject | any): ARQRCodeComponent;
}

declare class ARPoseUpdatePayload { 
	WorldTransform: Transform;
	JointTransforms: Transform[];
	clone() : ARPoseUpdatePayload;
	static C(Other: UObject | any): ARPoseUpdatePayload;
}

declare type EPoseComponentDebugMode = 'None' | 'ShowSkeleton' | 'EPoseComponentDebugMode_MAX';
declare var EPoseComponentDebugMode : { None:'None',ShowSkeleton:'ShowSkeleton',EPoseComponentDebugMode_MAX:'EPoseComponentDebugMode_MAX', };
declare class ARPoseComponent extends ARComponent { 
	ReplicatedPayload: ARPoseUpdatePayload;
	static Load(ResourceName: string): ARPoseComponent;
	static Find(Outer: UObject, ResourceName: string): ARPoseComponent;
	static GetDefaultObject(): ARPoseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPoseComponent;
	static SetPoseComponentDebugMode(NewDebugMode: EPoseComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARPoseUpdatePayload): void;
	ReceiveUpdate(Payload: ARPoseUpdatePayload): void;
	ReceiveAdd(Payload: ARPoseUpdatePayload): void;
	static C(Other: UObject | any): ARPoseComponent;
}

declare class AREnvironmentProbeUpdatePayload { 
	WorldTransform: Transform;
	clone() : AREnvironmentProbeUpdatePayload;
	static C(Other: UObject | any): AREnvironmentProbeUpdatePayload;
}

declare class AREnvironmentProbeComponent extends ARComponent { 
	ReplicatedPayload: AREnvironmentProbeUpdatePayload;
	static Load(ResourceName: string): AREnvironmentProbeComponent;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentProbeComponent;
	static GetDefaultObject(): AREnvironmentProbeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentProbeComponent;
	ServerUpdatePayload(NewPayload: AREnvironmentProbeUpdatePayload): void;
	ReceiveUpdate(Payload: AREnvironmentProbeUpdatePayload): void;
	ReceiveAdd(Payload: AREnvironmentProbeUpdatePayload): void;
	static C(Other: UObject | any): AREnvironmentProbeComponent;
}

declare class ARObjectUpdatePayload { 
	WorldTransform: Transform;
	clone() : ARObjectUpdatePayload;
	static C(Other: UObject | any): ARObjectUpdatePayload;
}

declare class ARObjectComponent extends ARComponent { 
	ReplicatedPayload: ARObjectUpdatePayload;
	static Load(ResourceName: string): ARObjectComponent;
	static Find(Outer: UObject, ResourceName: string): ARObjectComponent;
	static GetDefaultObject(): ARObjectComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARObjectComponent;
	ServerUpdatePayload(NewPayload: ARObjectUpdatePayload): void;
	ReceiveUpdate(Payload: ARObjectUpdatePayload): void;
	ReceiveAdd(Payload: ARObjectUpdatePayload): void;
	static C(Other: UObject | any): ARObjectComponent;
}

declare class ARMeshUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	ObjectClassification: EARObjectClassification;
	clone() : ARMeshUpdatePayload;
	static C(Other: UObject | any): ARMeshUpdatePayload;
}

declare class ARMeshComponent extends ARComponent { 
	ReplicatedPayload: ARMeshUpdatePayload;
	static Load(ResourceName: string): ARMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ARMeshComponent;
	static GetDefaultObject(): ARMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshComponent;
	ServerUpdatePayload(NewPayload: ARMeshUpdatePayload): void;
	ReceiveUpdate(Payload: ARMeshUpdatePayload): void;
	ReceiveAdd(Payload: ARMeshUpdatePayload): void;
	static C(Other: UObject | any): ARMeshComponent;
}

declare type EARAltitudeSource = 'Precise' | 'Coarse' | 'UserDefined' | 'Unknown' | 'EARAltitudeSource_MAX';
declare var EARAltitudeSource : { Precise:'Precise',Coarse:'Coarse',UserDefined:'UserDefined',Unknown:'Unknown',EARAltitudeSource_MAX:'EARAltitudeSource_MAX', };
declare class ARGeoAnchorUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Longitude: number;
	Latitude: number;
	AltitudeMeters: number;
	AltitudeSource: EARAltitudeSource;
	AnchorName: string;
	clone() : ARGeoAnchorUpdatePayload;
	static C(Other: UObject | any): ARGeoAnchorUpdatePayload;
}

declare type EGeoAnchorComponentDebugMode = 'None' | 'ShowGeoData' | 'EGeoAnchorComponentDebugMode_MAX';
declare var EGeoAnchorComponentDebugMode : { None:'None',ShowGeoData:'ShowGeoData',EGeoAnchorComponentDebugMode_MAX:'EGeoAnchorComponentDebugMode_MAX', };
declare class ARGeoAnchorComponent extends ARComponent { 
	ReplicatedPayload: ARGeoAnchorUpdatePayload;
	static Load(ResourceName: string): ARGeoAnchorComponent;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchorComponent;
	static GetDefaultObject(): ARGeoAnchorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchorComponent;
	static SetGeoAnchorComponentDebugMode(NewDebugMode: EGeoAnchorComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARGeoAnchorUpdatePayload): void;
	ReceiveUpdate(Payload: ARGeoAnchorUpdatePayload): void;
	ReceiveAdd(Payload: ARGeoAnchorUpdatePayload): void;
	static C(Other: UObject | any): ARGeoAnchorComponent;
}

declare class ARSessionConfig extends DataAsset { 
	bGenerateMeshDataFromTrackedGeometry: boolean;
	bGenerateCollisionForMeshData: boolean;
	bGenerateNavMeshForMeshData: boolean;
	bUseMeshDataForOcclusion: boolean;
	bRenderMeshDataInWireframe: boolean;
	bTrackSceneObjects: boolean;
	bUsePersonSegmentationForOcclusion: boolean;
	bUseSceneDepthForOcclusion: boolean;
	bUseAutomaticImageScaleEstimation: boolean;
	bUseStandardOnboardingUX: boolean;
	WorldAlignment: EARWorldAlignment;
	SessionType: EARSessionType;
	PlaneDetectionMode: EARPlaneDetectionMode;
	bHorizontalPlaneDetection: boolean;
	bVerticalPlaneDetection: boolean;
	bEnableAutoFocus: boolean;
	LightEstimationMode: EARLightEstimationMode;
	FrameSyncMode: EARFrameSyncMode;
	bEnableAutomaticCameraOverlay: boolean;
	bEnableAutomaticCameraTracking: boolean;
	bResetCameraTracking: boolean;
	bResetTrackedObjects: boolean;
	CandidateImages: ARCandidateImage[];
	MaxNumSimultaneousImagesTracked: number;
	EnvironmentCaptureProbeType: EAREnvironmentCaptureProbeType;
	WorldMapData: number[];
	CandidateObjects: ARCandidateObject[];
	DesiredVideoFormat: ARVideoFormat;
	bUseOptimalVideoFormat: boolean;
	FaceTrackingDirection: EARFaceTrackingDirection;
	FaceTrackingUpdate: EARFaceTrackingUpdate;
	MaxNumberOfTrackedFaces: number;
	SerializedARCandidateImageDatabase: number[];
	EnabledSessionTrackingFeature: EARSessionTrackingFeature;
	SceneReconstructionMethod: EARSceneReconstruction;
	PlaneComponentClass: UnrealEngineClass;
	PointComponentClass: UnrealEngineClass;
	FaceComponentClass: UnrealEngineClass;
	ImageComponentClass: UnrealEngineClass;
	QRCodeComponentClass: UnrealEngineClass;
	PoseComponentClass: UnrealEngineClass;
	EnvironmentProbeComponentClass: UnrealEngineClass;
	ObjectComponentClass: UnrealEngineClass;
	MeshComponentClass: UnrealEngineClass;
	GeoAnchorComponentClass: UnrealEngineClass;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	static Load(ResourceName: string): ARSessionConfig;
	static Find(Outer: UObject, ResourceName: string): ARSessionConfig;
	static GetDefaultObject(): ARSessionConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSessionConfig;
	ShouldResetTrackedObjects(): boolean;
	ShouldResetCameraTracking(): boolean;
	ShouldRenderCameraOverlay(): boolean;
	ShouldEnableCameraTracking(): boolean;
	ShouldEnableAutoFocus(): boolean;
	SetWorldMapData(WorldMapData: number[]): void;
	SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: EARSessionTrackingFeature): void;
	SetSceneReconstructionMethod(InSceneReconstructionMethod: EARSceneReconstruction): void;
	SetResetTrackedObjects(bNewValue: boolean): void;
	SetResetCameraTracking(bNewValue: boolean): void;
	SetFaceTrackingUpdate(InUpdate: EARFaceTrackingUpdate): void;
	SetFaceTrackingDirection(InDirection: EARFaceTrackingDirection): void;
	SetEnableAutoFocus(bNewValue: boolean): void;
	SetDesiredVideoFormat(NewFormat: ARVideoFormat): void;
	SetCandidateObjectList(InCandidateObjects: ARCandidateObject[]): void;
	GetWorldMapData(): number[];
	GetWorldAlignment(): EARWorldAlignment;
	GetSessionType(): EARSessionType;
	GetSceneReconstructionMethod(): EARSceneReconstruction;
	GetPlaneDetectionMode(): EARPlaneDetectionMode;
	GetMaxNumSimultaneousImagesTracked(): number;
	GetLightEstimationMode(): EARLightEstimationMode;
	GetFrameSyncMode(): EARFrameSyncMode;
	GetFaceTrackingUpdate(): EARFaceTrackingUpdate;
	GetFaceTrackingDirection(): EARFaceTrackingDirection;
	GetEnvironmentCaptureProbeType(): EAREnvironmentCaptureProbeType;
	GetEnabledSessionTrackingFeature(): EARSessionTrackingFeature;
	GetDesiredVideoFormat(): ARVideoFormat;
	GetCandidateObjectList(): ARCandidateObject[];
	GetCandidateImageList(): ARCandidateImage[];
	AddCandidateObject(CandidateObject: ARCandidateObject): void;
	AddCandidateImage(NewCandidateImage: ARCandidateImage): void;
	static C(Other: UObject | any): ARSessionConfig;
	AddRuntimeCandidateImage(CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	StartARSession(): void;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static StartARSession(SessionConfig: ARSessionConfig): void;
}

declare type EARWorldMappingState = 'NotAvailable' | 'StillMappingNotRelocalizable' | 'StillMappingRelocalizable' | 'Mapped' | 'EARWorldMappingState_MAX';
declare var EARWorldMappingState : { NotAvailable:'NotAvailable',StillMappingNotRelocalizable:'StillMappingNotRelocalizable',StillMappingRelocalizable:'StillMappingRelocalizable',Mapped:'Mapped',EARWorldMappingState_MAX:'EARWorldMappingState_MAX', };
declare type EARTrackingQualityReason = 'None' | 'Initializing' | 'Relocalizing' | 'ExcessiveMotion' | 'InsufficientFeatures' | 'InsufficientLight' | 'BadState' | 'EARTrackingQualityReason_MAX';
declare var EARTrackingQualityReason : { None:'None',Initializing:'Initializing',Relocalizing:'Relocalizing',ExcessiveMotion:'ExcessiveMotion',InsufficientFeatures:'InsufficientFeatures',InsufficientLight:'InsufficientLight',BadState:'BadState',EARTrackingQualityReason_MAX:'EARTrackingQualityReason_MAX', };
declare type EARTrackingQuality = 'NotTracking' | 'OrientationOnly' | 'OrientationAndPosition' | 'EARTrackingQuality_MAX';
declare var EARTrackingQuality : { NotTracking:'NotTracking',OrientationOnly:'OrientationOnly',OrientationAndPosition:'OrientationAndPosition',EARTrackingQuality_MAX:'EARTrackingQuality_MAX', };
declare type EARTextureType = 'Unknown' | 'CameraImage' | 'CameraDepth' | 'EnvironmentCapture' | 'PersonSegmentationImage' | 'PersonSegmentationDepth' | 'SceneDepthMap' | 'SceneDepthConfidenceMap' | 'EARTextureType_MAX';
declare var EARTextureType : { Unknown:'Unknown',CameraImage:'CameraImage',CameraDepth:'CameraDepth',EnvironmentCapture:'EnvironmentCapture',PersonSegmentationImage:'PersonSegmentationImage',PersonSegmentationDepth:'PersonSegmentationDepth',SceneDepthMap:'SceneDepthMap',SceneDepthConfidenceMap:'SceneDepthConfidenceMap',EARTextureType_MAX:'EARTextureType_MAX', };
declare class ARTexture extends Texture { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): ARTexture;
	static Find(Outer: UObject, ResourceName: string): ARTexture;
	static GetDefaultObject(): ARTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTexture;
	static C(Other: UObject | any): ARTexture;
}

declare class ARLightEstimate extends UObject { 
	static Load(ResourceName: string): ARLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARLightEstimate;
	static GetDefaultObject(): ARLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLightEstimate;
	static C(Other: UObject | any): ARLightEstimate;
}

declare class ARCameraIntrinsics { 
	ImageResolution: IntPoint;
	FocalLength: Vector2D;
	PrincipalPoint: Vector2D;
	clone() : ARCameraIntrinsics;
	static C(Other: UObject | any): ARCameraIntrinsics;
	GetCameraIntrinsics(): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
}

declare class ARTextureCameraImage extends ARTexture { 
	static Load(ResourceName: string): ARTextureCameraImage;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraImage;
	static GetDefaultObject(): ARTextureCameraImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraImage;
	static C(Other: UObject | any): ARTextureCameraImage;
}

declare type EARDepthQuality = 'Unkown' | 'Low' | 'High' | 'EARDepthQuality_MAX';
declare var EARDepthQuality : { Unkown:'Unkown',Low:'Low',High:'High',EARDepthQuality_MAX:'EARDepthQuality_MAX', };
declare type EARDepthAccuracy = 'Unkown' | 'Approximate' | 'Accurate' | 'EARDepthAccuracy_MAX';
declare var EARDepthAccuracy : { Unkown:'Unkown',Approximate:'Approximate',Accurate:'Accurate',EARDepthAccuracy_MAX:'EARDepthAccuracy_MAX', };
declare class ARTextureCameraDepth extends ARTexture { 
	DepthQuality: EARDepthQuality;
	DepthAccuracy: EARDepthAccuracy;
	bIsTemporallySmoothed: boolean;
	static Load(ResourceName: string): ARTextureCameraDepth;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraDepth;
	static GetDefaultObject(): ARTextureCameraDepth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraDepth;
	static C(Other: UObject | any): ARTextureCameraDepth;
}

declare type EARSessionStatus = 'NotStarted' | 'Running' | 'NotSupported' | 'FatalError' | 'PermissionNotGranted' | 'UnsupportedConfiguration' | 'Other' | 'EARSessionStatus_MAX';
declare var EARSessionStatus : { NotStarted:'NotStarted',Running:'Running',NotSupported:'NotSupported',FatalError:'FatalError',PermissionNotGranted:'PermissionNotGranted',UnsupportedConfiguration:'UnsupportedConfiguration',Other:'Other',EARSessionStatus_MAX:'EARSessionStatus_MAX', };
declare class ARSessionStatus { 
	AdditionalInfo: string;
	Status: EARSessionStatus;
	clone() : ARSessionStatus;
	static C(Other: UObject | any): ARSessionStatus;
	static GetARSessionStatus(): ARSessionStatus;
}

declare class ARSkeletonDefinition { 
	NumJoints: number;
	JointNames: string[];
	ParentIndices: number[];
	clone() : ARSkeletonDefinition;
	static C(Other: UObject | any): ARSkeletonDefinition;
}

declare type EARJointTransformSpace = 'Model' | 'ParentJoint' | 'EARJointTransformSpace_MAX';
declare var EARJointTransformSpace : { Model:'Model',ParentJoint:'ParentJoint',EARJointTransformSpace_MAX:'EARJointTransformSpace_MAX', };
declare class ARPose3D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointTransforms: Transform[];
	IsJointTracked: boolean[];
	JointTransformSpace: EARJointTransformSpace;
	clone() : ARPose3D;
	static C(Other: UObject | any): ARPose3D;
}

declare class ARTrackedPose extends ARTrackedGeometry { 
	TrackedPose: ARPose3D;
	static Load(ResourceName: string): ARTrackedPose;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPose;
	static GetDefaultObject(): ARTrackedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPose;
	GetTrackedPoseData(): ARPose3D;
	static C(Other: UObject | any): ARTrackedPose;
}

declare class ARTrackedPoint extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARTrackedPoint;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPoint;
	static GetDefaultObject(): ARTrackedPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPoint;
	static C(Other: UObject | any): ARTrackedPoint;
}

declare type EARPlaneOrientation = 'Horizontal' | 'Vertical' | 'Diagonal' | 'EARPlaneOrientation_MAX';
declare var EARPlaneOrientation : { Horizontal:'Horizontal',Vertical:'Vertical',Diagonal:'Diagonal',EARPlaneOrientation_MAX:'EARPlaneOrientation_MAX', };
declare class ARPlaneGeometry extends ARTrackedGeometry { 
	Orientation: EARPlaneOrientation;
	Center: Vector;
	Extent: Vector;
	BoundaryPolygon: Vector[];
	SubsumedBy: ARPlaneGeometry;
	static Load(ResourceName: string): ARPlaneGeometry;
	static Find(Outer: UObject, ResourceName: string): ARPlaneGeometry;
	static GetDefaultObject(): ARPlaneGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneGeometry;
	GetSubsumedBy(): ARPlaneGeometry;
	GetOrientation(): EARPlaneOrientation;
	GetExtent(): Vector;
	GetCenter(): Vector;
	GetBoundaryPolygonInLocalSpace(): Vector[];
	static C(Other: UObject | any): ARPlaneGeometry;
}

declare class ARTrackedImage extends ARTrackedGeometry { 
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	static Load(ResourceName: string): ARTrackedImage;
	static Find(Outer: UObject, ResourceName: string): ARTrackedImage;
	static GetDefaultObject(): ARTrackedImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedImage;
	GetEstimateSize(): Vector2D;
	GetDetectedImage(): ARCandidateImage;
	static C(Other: UObject | any): ARTrackedImage;
}

declare class AREnvironmentCaptureProbeTexture extends TextureCube { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): AREnvironmentCaptureProbeTexture;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbeTexture;
	static GetDefaultObject(): AREnvironmentCaptureProbeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbeTexture;
}

declare class AREnvironmentCaptureProbe extends ARTrackedGeometry { 
	Extent: Vector;
	EnvironmentCaptureTexture: AREnvironmentCaptureProbeTexture;
	static Load(ResourceName: string): AREnvironmentCaptureProbe;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbe;
	static GetDefaultObject(): AREnvironmentCaptureProbe;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbe;
	GetExtent(): Vector;
	GetEnvironmentCaptureTexture(): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbe;
}

declare class ARPose2D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointLocations: Vector2D[];
	IsJointTracked: boolean[];
	clone() : ARPose2D;
	static C(Other: UObject | any): ARPose2D;
}

declare class ARBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ARBlueprintLibrary;
	static GetDefaultObject(): ARBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBlueprintLibrary;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
	static ToggleARCapture(bOnOff: boolean,CaptureType: EARCaptureType): boolean;
	static StopARSession(): void;
	static StartARSession(SessionConfig: ARSessionConfig): void;
	static SetEnabledXRCamera(bOnOff: boolean): void;
	static SetARWorldScale(InWorldScale: number): void;
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static SaveARPinToLocalStore(InSaveName: string,InPin: ARPin): boolean;
	static ResizeXRCamera(InSize: IntPoint): IntPoint;
	static RemovePin(PinToRemove: ARPin): void;
	static RemoveARPinFromLocalStore(InSaveName: string): void;
	static RemoveAllARPinsFromLocalStore(): void;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PauseARSession(): void;
	static LoadARPinsFromLocalStore(): any;
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static IsSessionTypeSupported(SessionType: EARSessionType): boolean;
	static IsSessionTrackingFeatureSupported(SessionType: EARSessionType,SessionTrackingFeature: EARSessionTrackingFeature): boolean;
	static IsSceneReconstructionSupported(SessionType: EARSessionType,SceneReconstructionMethod: EARSceneReconstruction): boolean;
	static IsARSupported(): boolean;
	static IsARPinLocalStoreSupported(): boolean;
	static IsARPinLocalStoreReady(): boolean;
	static GetWorldMappingStatus(): EARWorldMappingState;
	static GetTrackingQualityReason(): EARTrackingQualityReason;
	static GetTrackingQuality(): EARTrackingQuality;
	static GetSupportedVideoFormats(SessionType: EARSessionType): ARVideoFormat[];
	static GetSessionConfig(): ARSessionConfig;
	static GetPointCloud(): Vector[];
	static GetPersonSegmentationImage(): ARTexture;
	static GetPersonSegmentationDepthImage(): ARTexture;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static GetNumberOfTrackedFacesSupported(): number;
	static GetCurrentLightEstimate(): ARLightEstimate;
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraImage(): ARTextureCameraImage;
	static GetCameraDepth(): ARTextureCameraDepth;
	static GetARWorldScale(): number;
	static GetARTexture(TextureType: EARTextureType): ARTexture;
	static GetARSessionStatus(): ARSessionStatus;
	static GetAllTrackedPoses(): ARTrackedPose[];
	static GetAllTrackedPoints(): ARTrackedPoint[];
	static GetAllTrackedPlanes(): ARPlaneGeometry[];
	static GetAllTrackedImages(): ARTrackedImage[];
	static GetAllTrackedEnvironmentCaptureProbes(): AREnvironmentCaptureProbe[];
	static GetAllTracked2DPoses(): ARPose2D[];
	static GetAllPins(): ARPin[];
	static GetAllGeometriesByClass(GeometryClass: UnrealEngineClass): ARTrackedGeometry[];
	static GetAllGeometries(): ARTrackedGeometry[];
	static GetAlignmentTransform(): Transform;
	static FindTrackedPointsByName(PointName: string): ARTrackedPoint[];
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static CalculateClosestIntersection(StartPoints: Vector[],EndPoints: Vector[],ClosestIntersection?: Vector): {ClosestIntersection: Vector};
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static C(Other: UObject | any): ARBlueprintLibrary;
}

declare class ARTraceResultLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARTraceResultLibrary;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultLibrary;
	static GetDefaultObject(): ARTraceResultLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultLibrary;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static C(Other: UObject | any): ARTraceResultLibrary;
}

declare class ARBaseAsyncTaskBlueprintProxy extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARBaseAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBaseAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARBaseAsyncTaskBlueprintProxy;
}

declare class ARSaveWorldAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	static Load(ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARSaveWorldAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSaveWorldAsyncTaskBlueprintProxy;
	static ARSaveWorld(WorldContextObject: UObject): ARSaveWorldAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARSaveWorldAsyncTaskBlueprintProxy;
}

declare class ARGetCandidateObjectAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	static Load(ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static ARGetCandidateObject(WorldContextObject: UObject,Location: Vector,Extent: Vector): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARGetCandidateObjectAsyncTaskBlueprintProxy;
}

declare type EARServicePermissionRequestResult = 'Granted' | 'Denied' | 'EARServicePermissionRequestResult_MAX';
declare var EARServicePermissionRequestResult : { Granted:'Granted',Denied:'Denied',EARServicePermissionRequestResult_MAX:'EARServicePermissionRequestResult_MAX', };
declare type EARServiceInstallRequestResult = 'Installed' | 'DeviceNotCompatible' | 'UserDeclinedInstallation' | 'FatalError' | 'EARServiceInstallRequestResult_MAX';
declare var EARServiceInstallRequestResult : { Installed:'Installed',DeviceNotCompatible:'DeviceNotCompatible',UserDeclinedInstallation:'UserDeclinedInstallation',FatalError:'FatalError',EARServiceInstallRequestResult_MAX:'EARServiceInstallRequestResult_MAX', };
declare type EARServiceAvailability = 'UnknownError' | 'UnknownChecking' | 'UnknownTimedOut' | 'UnsupportedDeviceNotCapable' | 'SupportedNotInstalled' | 'SupportedVersionTooOld' | 'SupportedInstalled' | 'EARServiceAvailability_MAX';
declare var EARServiceAvailability : { UnknownError:'UnknownError',UnknownChecking:'UnknownChecking',UnknownTimedOut:'UnknownTimedOut',UnsupportedDeviceNotCapable:'UnsupportedDeviceNotCapable',SupportedNotInstalled:'SupportedNotInstalled',SupportedVersionTooOld:'SupportedVersionTooOld',SupportedInstalled:'SupportedInstalled',EARServiceAvailability_MAX:'EARServiceAvailability_MAX', };
